---
title: 数据库相关书籍阅读笔记
comments: true
toc: true
date: 2019-06-17 09:47:02
categories: Others
tags: MySQL
---

《数据库系统概念》、《高性能 MySQL》、《深入理解 MySQL》、《MySQL 技术内幕: InnoDB 存储引擎》等.

<!--more-->

## 事务（transaction）

### ACID

- 原子性（atomicity）:
事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；恢复系统 保证
- 一致性（consistency）:
执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；程序员 保证
- 隔离性（isolation）: 
并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；并发控制系统 保证
- 持久性（durability）:
一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。恢复系统 保证

### 状态变化

![](/images/sql-transaction.png)

### 并发问题及相应隔离级别

- 丢失修改（Lost to modify）:
指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
- 脏读（Dirty read）:
当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- 不可重复读（Unrepeatable read）:
指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- 幻读（Phantom read）:
幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
不可重复度和幻读区别：不可重复读的重点是修改，幻读的重点在于新增或者删除。

* 未提交读（read uncommitted）:
允许读取未提交数据.
* 已提交读（read committed）:
只允许读取已提交数据.
* 可重复读（repeatable read）:
只允许读取已提交数据, 而且在一个事务两次读取一个数据项期间, 其他事务不得更新该数据.
* 可串行化（serializable）:
通常保证可串行化调度.

|隔离级别|  |未提交读|  |已提交读|  |可重复读|  |可串行化|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|并发问题|丢失修改?| |脏读|  |不可重复读|    |幻读|  |

以上所有隔离级别都不允许脏写（dirty write）, 即如果一个数据项已经被另外一个尚未提交或中止的事务写入, 则不允许对该数据执行写操作.

"串行化"为最高隔离级别, 完全服从 ACID;

在 SQL 中, 除了接受系统的默认设置, 还可以显示地设置隔离性级别. 例如, "set transaction isolation serializable".

这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 SERIALIZABLE (可串行化)隔离级别。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失。

InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE (可串行化)隔离级别。

## 并发控制

机制: 锁、时间戳、多版本和快照隔离.

- 两段锁: 第一个阶段只获得锁不释放锁, 第二个阶段只释放锁不获得锁.

- 共享锁: 用于事务读的数据项
- 排他锁: 用于数据写的数据项

这两种锁模式以及两阶段封锁协议在保证可串行化的前提下允许数据的并发读.

## 索引（index）

索引是存储引擎用于快速找到记录的一种数据结构.

### 索引优点

1、索引大大减少了服务器需要扫描的数据量
2、索引可以帮助服务器避免排序和临时表
3、索引可以将随机 IO 变为顺序 IO

### 常用索引类别

- 顺序索引:

- 哈希索引:
基于哈希表实现, 只有精确匹配索引所有列的查询才有效, 即不支持部分索引列匹配查找, 也不支持任何范围查询. 只支持等值比较查询, 包括 =、IN()、<=>.
哈希索引数据并不是按照索引值顺序存储的, 所以也就无法排序.
在 MySQL 中只有 Memory 引擎显示支持哈希索引, 并且其支持非唯一哈希索引.
访问哈希索引的速度非常快, 除非有很多哈希冲突.
在数据仓库应用中有一种经典的星型 schema, 需要关联很多查找表, 哈希索引就非常适合查找表的需求.
InnoDB 有一个特殊功能"自适应哈希索引", 即针对某些使用频繁的索引值, 在内存中基于 B-Tree 索引之上再创建一个哈希索引, 使得 B-Tree 索引也具有哈希索引的一些优点. 也有创建自定义哈希索引的方法, 就是新增一个用于索引的哈希值列.

- B-Tree 索引:
B-Tree 索引适用于全键值、键值范围或键前缀查找, 其中键前缀查找只适用于根据最左前缀的查找（所以在优化性能的时候可能需要使用相同的列但顺序不同的索引来满足不同类型的查询请求）.
支持以下查询: 全值匹配、匹配最左前缀、匹配列前缀、匹配范围值、精确匹配某一列并范围匹配另一列、只访问索引的查询.

- R-Tree 索引（空间数据索引）:
MyISAM 表支持空间索引, 可以用作地理数据存储.

- full-text 索引（全文索引）:
全文索引是一种特殊类型的索引, 它查找的是文本中的关键词, 而不是直接比较索引中的值. 与其他几类索引的匹配方式完全不同.

聚集索引（主索引）
非聚集索引（辅助索引）

稠密索引
稀疏索引

### 索引评价

- 第一颗星:
索引将相关的记录放在一起

- 第二颗星:
索引中的数据顺序和查找中的排列顺序一致

- 第三颗星:
索引中的列包含了查询中需要的全部列

### 高性能的索引策略

正确地创建和使用索引是实现高性能查询的基础.

- 独立的列:
即索引列不能是表达式的一部分, 也不能是函数的参数.

- 前缀索引:
索引很长的字符列, 会让索引变得大且慢.
前缀索引是一种能使索引更小更快的有效办法.
MySQL无法使用前缀索引做 ORDER BY 和 GROUP BY 以及做覆盖扫描.
对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列, 必须使用前缀索引, 因为 MySQL 不允许索引这些列的完整长度.
后缀索引也有用途, 例如查找某个域名的所有电子邮件. MySQL 原生并不支持反向索引, 但是可以把字符串反转后存储, 并基于此建立前缀索引, 通过触发器维护这种索引.

- 多列索引
在多个列上建立单独的单列索引大部分情况下并不能提高 MySQL 的查询性能.
MySQL 5.0 之后引入了"索引合并"的策略, 一定程度上可以使用表上的多个单列索引来定位指定的行. 索引合并策略有时候是一种优化的结果, 但实际上更多时候说明表上的索引建得很糟糕.
当出现服务器对多个索引作相交操作时（通常有多个 AND 条件）, 通常意味着需要一个包含所有相关列的多列索引, 而不是多个独立的单列索引.

- 选择合适的索引列顺序


- 聚簇索引

- 覆盖索引

- 使用索引扫描来做排序

- 压缩（前缀压缩）索引

- 冗余和重复索引

- 未使用的索引

- 索引和锁

## 存储引擎（MyISAM 与 InnoDB）

对于索引,
前者使用前缀压缩技术使得索引更小;
后者按照原数据格式进行存储.
前者通过数据的物理位置引用被索引的行;
后者根据主键引用被索引的行.



