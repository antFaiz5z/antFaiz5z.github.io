---
title: 《Redis 设计与实现》阅读笔记
comments: true
toc: true
date: 2019-05-17 10:43:24
categories: C/C++
tags: Redis
---

第 1 版, 此书基于 Redis 2.9.

<!--more-->

## 数据结构与对象

Redis 没有直接使用以下几种数据结构来实现键值对数据库, 而是基于这些数据结构创建了一个对象系统.
Redis 的每个键值对都是由对象组成, 键总是一个字符串对象, 值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象.

### sds

Redis 使用 SDS 用作默认字符串表示, C 字符串只会作为字符串字面量用在一些无需对字符串进行修改的地方如打印日志.

![](/images/redis-sds.png)

### linkedlist

链表 (双向无环) 是列表键的底层实现之一.

![](/images/redis-list.png)

### dict/ht

Redis 的数据库使用字典来作为底层实现, 字典还是哈希键的底层实现之一.
字典 使用哈希表作为底层实现.
哈希表 使用链地址法 (separate chaining) 来解决键冲突.

![](/images/redis-ht.png)

### skiplist

Redis 使用跳跃表作为有序集合键的底层实现之一.
Redis 只在两个地方用到了跳跃表, 一个是实现有序集合键, 一个是在集群节点中用作内部数据结构.
每个跳跃表节点的层高都是 1~32 之间的随机数.
在同一跳跃表中, 多个节点可以包含相同的分值, 但每个节点的成员对象必须是唯一的.
跳跃表中的节点按照分值大小进行排序, 当分值相同时, 节点按照成员对象大小进行排序.

![](/images/redis-sl.png)

### intset

整数集合是集合键的底层实现之一.
证书集合的底层实现为数组, 这个数组以有序、无重复的方式保存几何元素, 在有需要的时候, 程序会根据新添加元素的类型，改变这个数组的类型. (类型有INSERT_ENC_INT16/32/64)
整数集合只支持升级操作, 不支持降级操作.

![](/images/redis-intset.png)

### ziplist

压缩列表被用作列表键和哈希键的底层实现之一.
压缩列表是一种为节约内存而开发的顺序性数据结构.
压缩列表可以包含多个节点, 每个节点可以保存一个字节数组或整数值.
在压缩列表中添加新节点或者删除节点, 可能会引发连锁更新操作, 但这种操作出现的几率并不高.

![](/images/redis-ziplist1.png)

![](/images/redis-ziplist2.png)

### 对象

当我们称呼一个键为 "列表键" 时, 我们指的是 "这个数据库键所对应的值为列表对象".

Redis 的对象系统实现了基于引用计数的内存回收机制, 继而实现了对象共享机制.
Redis 的对象带有访问时间记录信息, 可用于计算数据库键的空转时长, 在服务器启用了 maxmemory 功能的情况下, 空转时长较大的那些键可能会优先被服务器删除.

TYPE 命令返回数据库键对应的值对象的类型, 而不是键对象的类型.

字符串对象是 Redis 五种类型对象中唯一一种会被其他四种对象嵌套的对象.

Redis 只对包含整数值的字符串对象进行共享, 因为尽管共享更复杂对象可以节省更多内存, 但验证操作的时间复杂度也更高.

Redis 在初始化服务器时, 会预先创建一万个字符串对象用于共享, 包含从 0 至 9999 所有整数值.

## 单机数据库

### 数据库

过期键删除策略有定时删除、惰性删除、定期删除, Redis 采用的是后两种, 服务器可以很好地在合理使用 CPU 时间和避免浪费内存空间之间取得平衡.

### RDB 与 AOF 持久化

RDB 持久化通过保存数据库中的键值对来记录数据库状态, AOF (Append File Only) 持久化通过保存 Redis 服务器所执行的写命令来记录服务器状态.

由于 AOF 文件的更新频率比 RDB 文件更高, 所以如果服务器开启了 AOF 持久化功能, 服务器会优先使用 AOF 文件来还原服务器状态.

SAVE、BGSAVE (background) 命令用于生成 RDB 文件.
当 SAVE 命令执行时, Redis 服务器会被阻塞, 此时客户端所有命令请求都会被阻塞. 
而 BGSAVE 命令的保存工作是由子进程执行的, 所以执行时 Redis 服务器仍可以响应客户端请求.
服务器在载入 RDB 文件期间, 会一直处于阻塞状态, 直到载入工作完成.
可通过 save 选项配置 BGSAVE 自动间隔性执行.

Redis 将 AOF 重写程序同样也是放到子程序中执行, 以达到两个目的：
1、子进程进行 AOF 重写期间, 服务器进程 (父进程) 可以继续处理命令请求.
2、子进程带有服务器进程的数据副本, 使用子进程而不是线程, 可以在避免使用锁的情况下,  保证数据的安全性.
但是使用子进程有一个问题, 子进程在进行 AOF 重写期间, 数据库状态可能发生改变, 从而使得重写后的 AOF 所保存的数据库状态已经是过时的了.
为了解决这种数据不一致问题, Redis 服务器设置了一个 AOF 重写缓冲区, 即用来记录重写期间的服务器执行的写命令, 当子进程重写完成后会调用一个信号处理函数通知父进程, 将 AOF 重写缓冲区中的内容写入新 AOF 文件中并原子地覆盖原有 AOF 文件, 使得新 AOF 文件所保存的数据库状态和服务器当前的数据库状态一致.

### 事件

Redis 基于 Reactor 模式开发了自己的文件事件处理器 (file event handler), 采用单线程 I/O 多路复用.

### 客户端

### 服务器

## 多机数据库

## 独立功能

## 总结

## 其他参考

- [通过思维导图整理 redis 的重要知识点](https://github.com/Weiwf/redis-mindmap)

- [JavaGuide 中关于 redis 的总结](https://github.com/Snailclimb/JavaGuide/tree/master/docs/database/Redis)