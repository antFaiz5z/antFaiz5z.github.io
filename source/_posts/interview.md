---
title: 面试问题整理
comments: true
toc: true
date: 2019-03-21 15:37:13
categories: Others
tags: interview
---

本文主要针对于 C++ 面试中常见问题进行整理并尽量作口语化而非书面化的回答。

<!--more-->

# 正文

## C/C++基础

- 内存布局
- 内存对齐
- 指针与引用
- new、delete、malloc、free
- 虚函数、虚表、虚表指针
- 智能指针
- static_cast、dynamic_cast、const_cast、reinterpret_cast

### STL

- 容器：分类、复杂度
- vector
- set、map
- allocator
- iterator、traits

## TCP/IP

- TCP 与 UDP
- 三次握手

    首先，接收方调用 listen() 处于 LISTEN 状态，
    发送方调用 connect() 发送一个 SYN 包，转为 SYN_SNET 状态，
    接收方接收到后发送 SYN + 相应的 ACK 包，转为 SYN_RCVD 状态，
    发送方收到后转为 ESTABLISHED 状态，接着再发送相应的 ACK 包，
    接收方收到后也转为 ESTABLISHED 状态，
    至此，全双工通信的可靠连接建立完成。

    * 为什么TCP建立连接要三次握手

    首先得回答三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。然后可以回答为什么两次握手不行，两次握手可能因为丢包而出现死锁，假设在两次握手场景中，C向S发送请求，S收到并发送确认请求给C，这时候S认为连接已经建立，并开始发送数据给C，但是那个确认请求丢包了，C不认为请求建立了，C当然会拒绝接受S发送来的数据，并且再去请求连接。这样，一个资源就死锁了。最后回答握手当然可以四次五次一直握下去，但三次已经够了，就没有必要了。总结下来一句话，主要目的防止在网络发生延迟或者丢包的情况下浪费资源。

- 四次挥手

    首先，发送方主动调用 close() 发起连接断开请求，发送一个 FIN 包，进入 FIN_WAIT_1 状态，
    接收方收到后转为 CLOSE_WAIT 状态，
    接收方发送相应的 ACK 包，发送方收到后转为 FIN_WAIT_2 状态，
    接收方调用 close(), 发送一个 FIN 包，转为 LAST_ACK 状态，
    送方收到后转为 TIME_WAIT 状态，等待 2MSL 时间后关闭连接，
    发送方发送相应的 ACK 包，接收方收到后正式关闭连接。

- 流量控制、拥塞控制、重传
- 编程函数
- 报头

## HTTP[S]

- 版本变化：0.9/1.0/1.1/2.0
- get、post
- 证书、密钥
- 一次完整的访问网页的过程
- 报头
- 状态码

## 操作系统

- 进程、线程、协程
- 同步与互斥
- IPC
- 虚拟内存：高端内存、伙伴、slab、vmalloc
- IO 模型
- EPOLL

## 数据库

### MySQL

- SQL语言
- 索引
- MyISAM 与 InnoDB
- 四个原则
- 四个隔离级别
- 两段锁
- MVVC
- 分区、分表、分库

### Redis

- 为什么要用 redis/为什么要用缓存

    高性能：假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。并且由于局部性原理，某些数据被访问后极有可能被多次访问从而多次命中缓存。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
    高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

- 为什么要用 redis 而不用 map/guava 做缓存?

    缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
    使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。

- redis 和 memcached 的区别

    1、Redis支持更丰富的数据类型（支持更复杂的应用场景）：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。
    2、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。
    3、集群模式：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.
    4、Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。

## 分布式

- map_reduce
- 负载均衡
- CDN

# 参考
