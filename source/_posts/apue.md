---
title: 《APUE》阅读笔记
comments: true
toc: true
date: 2019-07-30 14:59:54
categories: Linux
tags: apue
---

《UNIX 环境高级编程(Advanced Programming in the UNIX Environment)》

<!--more-->

## 第7章 进程环境

## 第8章 进程控制

### 进程标识

ID 为 0 的进程通常是调度进程（交换进程）, 是内核的一部分, 不执行任何磁盘上的程序, 因此也被成为系统进程;
ID 为 1 的进程通常是 init 进程, 在自举过程结束时由内核调用, 负责在自举内核后启动一个 UNIX 系统, 负责接管所有孤儿进程, 不会终止, 是一个普通的用户进程, 但以超级用户特权运行.

### fork

子进程获得父进程的 数据空间、堆和栈的副本（拷贝地址空间）, 但不共享这些存储空间部分, 由于 fork 之后常常跟随 exec, 所以很多实现并不执行数据段、堆和栈的完全副本, 而使用 Copy-On-Write 技术.
父子进程共享正文段.

clone(2) 作为 fork 的推广形式, 它允许调用者控制哪些部分由父进程和子进程共享.

在 fork 之后, 父子进程的执行顺序是不确定的, 这取决于内核的调度算法.

write() 是不带缓冲的; 而标准 I/O 库（如 printf）是带缓冲的, 如果标准输出连到终端设备, 则它是行缓冲的, 否则（将标准输出重定向到一个文件时）它是全缓冲的, 这种情况下 fork 之前父进程 printf 的缓冲数据 fork 后将会被拷贝到子进程中, 若 printf 则会又打印出来.
`setbuf(stdout, NUll);`可将标准输出的缓冲设置为空, 使其实时输出.

fork 使得 子进程继承了父进程的：
    所有打开文件描述符;
        - 父子进程每个相同的打开描述符共享一个文件表项;（因此重定向父进程的标准输出时, 子进程的标准输出也被重定向）
        - 父子进程共享同一个文件偏移量;（因此一般 1. 父进程等待子进程完成; 2. 父子进程各自执行不同的程序段, 不干扰对方使用的文件描述符）
    实际用户 ID、实际组 ID、有效用户 ID、有效组 ID;
    附属组 ID;
    进程组 ID;
    会话 ID;
    控制终端;
    设置用户 ID 标志和设置组 ID 标志;
    当前工作目录;
    根目录;
    文件模式创建屏蔽字;
    信号屏蔽和安排;
    对任一打开文件描述符的执行关闭（close-on-exec）标志;
    环境;
    连接的共享存储段;
    存储映像;
    资源限制;

父子进程的区别如下：
    fork 的返回值不同;
    进程 ID 不同;
    父进程 ID 不同;
    子进程的 tms_utime、tms_stime、tms_cutime 和 tms_ustime 的值设置为 0;
    子进程不继承父进程设置的文件锁;
    子进程的未处理闹钟被清除;
    子进程的未处理信号集设置为空集;

### vfork

vfork 与 fork 的区别：
    1、vfork 创建的新进程的目的是 exec 一个新程序, 不过在子进程调用 exec 或 exit 之前会在父进程的空间运行;（因此并不将父进程的地址空间完全复制到子进程）
    2、vfork 保证子进程先运行, 在它调用 exec 或 exit 后父进程才可能被调度运行;（如果在调用这两个函数之前子进程依赖父进程的进一步动作则会导致死锁）

### exit

进程有 5 种正常终止和 3 中异常终止方式：
    1、main 函数中执行 return, 相当于对用 exit;
    2、调用 exit;（调用终止处理程序, 关闭所有标准 I/O 流等; 但不处理文件描述符、多进程以及作业控制; 由 ISO C 定义）
    3、调用 _exit 或 _Exit;(在 UNIX 系统中两种调用等价, 并不冲洗标准 I/O 流; 处理 UNIX 系统特定的细节; exit 调用 _exit; 由 POSIX.1 说明)
    4、在进程的最后一个线程在其启动例程中执行 return;（进程以终止状态 0 返回）
    5、进程的最后一个线程调用 pthread_exit 函数;
    1、调用 abort;（产生 SIGABRT 信号, 是下一种异常终止的一种特例）
    2、进程接收到某些信号;（信号可由进程自身（调用 abort）、其他进程或内核产生）
    3、最后一个线程对取消请求作出响应;

不论进程如何终止, 最后都会执行内核中的同一段代码, 即关闭描述符、释放存储器.
子进程正常或异常终止时, 内核向其父进程发送 SIGCHLD 信号.

父进程在子进程前终止：在父进程终止的时候, 内核逐个检查所有活动进程, 若是子进程则将其父进程改为 init 进程.
子进程在父进程前终止：子进程需要告知父进程其如何终止（1. 将退出状态（exit status）作为参数传递给 exit、_exit、_Exit; 2. 异常终止时内核而不是进程本身产生一个指示其异常终止原因的终止状态（termination status））,父进程使用 wait 或 waitpid 取得内核为每个终止子进程保存的一定量信息, 这些信息至少包括 进程 ID、进程终止状态、进程使用的 CPU 时间总量.

一个已经终止而其父进程还未对其获取信息及释放资源的进程称为僵死进程.（ps(1) 打印其状态为 Z）

为防止系统中塞满僵死进程, init 进程设计成只要有子进程终止就会调用 wait 获取其终止状态. 如果一个进程 fork 一个子进程, 但不想父进程等待子进程终止, 也不想子进程处于僵死状态直到父进程终止, 方法是调用 fork 两次, 即通过让子进程终止使子子进程被 init 进程接管.

### wait 和 waitpid

waitpid 可等待一个特定的进程, 而 wait 返回任一终止进程的状态;
waitpid 提供了一个 wait 的非阻塞版本;
waitpid 通过 WUNTRACED 和 WCONTINUED 选项支持作业控制.

历史遗留：waitid()、wait3()、wait4().

## 第10章 信号

## 第11章 线程

### 线程概念

多线程作用：
1、通过为每种事件类型分配单独的处理线程, 可以简化处理异步事件的代码;
2、多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符放入共享, 而多个线程自动地可以访问相同的存储地址空间和文件描述符;
3、有些问题可以分解从而提高整个程序的吞吐量;
4、交互的程序可以通过多线程改善响应时间;

即使程序运行在单核处理器上, 仍然可以享受多线程模型的好处, 可以改善响应时间和吞吐量.

### 线程标示

进程 ID (pid_t) 在整个系统中是唯一的, 而线程 ID (pthread_t) 只有在它所属的进程上下文中才有意义.

### 线程创建

### 线程终止

进程中任意线程调用 exit、_Exit 或者 _exit, 那么整个进程就会终止.

单个线程可以通过 3 中方式退出：
1、简单地从启动例程中返回, 返回值是线程的退出码 (return);
2、被同一进程中的其他线程取消 (pthread_cancel);
3、线程调用 pthread_exit (pthread_exit);

线程通过调用 return 返回或者调用 pthread_exit 退出, 进程中的其他线程可以通过调用 pthread_join 获得该线程的退出状态. 默认情况下, 线程的终止状态会保存直到对该线程调用 pthread_join.

pthread_exit 和 pthread_create 的 void* 参数可以是一个简单数值, 也可以是一个复杂结构体. 只是这个结构所使用的的内存在调用者完成调用以后必须是有效的, 比如 pthread_join 会试图使用该结构. 因此可以使用全局结构或用 malloc 分配堆空间.

pthread_cancel 并不等待线程终止, 它仅仅提出请求, 对方线程可以选择忽略取消或者控制如何被取消.

使用 pthread_cleanup_push 注册的线程清理函数 rtn 只有当线程采取以下动作时才会被调用：
1、调用 pthread_exit 时;
2、相应取消请求时;
3、用非零参数调用 pthread_cleanup_pop 时;

而简单使用 return 返回时不会执行线程清理程序.

并且线程处理函数注册在栈中, 因此执行顺序与它们注册时相反.

### 线程同步

#### 互斥量

如果线程试图对同一个互斥量加锁两次, 那么它自身就会陷入死锁状态.

如果锁的粒度太粗, 就会出现很多线程阻塞等待相同的锁, 这可能并不能改善并发性;
如果锁的粒度太细, 那么过多的锁开销就会使系统性能受到影响;
程序员需要在代码复杂性和性能之间找到正确的平衡.

#### 条件变量

#### 读写锁

读写锁非常适合于对数据结构读的次数远大于写的情况. 与互斥量相比, 读写锁在使用之前必须初始化, 在释放它们底层的内存之前必须销毁.

#### 自旋锁

| 同步原语 | 进程 | 线程 posix| 线程 STL |
|------|-----|-----|-----|
|获取 ID|getpid()|pthread_t pthread_self(void)|this_thread::get_id()|
|创建|fork()|int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg)||
|终止|exit()|pthread_exit||
|非正常终止|abort()|pthread_cancel||
|终止时清理|atexit()|pthread_cleanup_push</br>pthread_cleanup_pop||
|互斥量||int pthread_mutex_init</br>int pthread_mutex_destroy</br>int pthread_mutex_lock</br>int pthread_mutex_trylock</br>int pthread_mutex_unlock</br>int pthread_mutex_timedlock||
|条件变量||||
|读写锁||||
|自旋锁||||

## 第15章 进程间通信
