---
title: 《APUE》阅读笔记
comments: true
toc: true
date: 2019-07-30 14:59:54
categories: Linux
tags: apue
---

《UNIX 环境高级编程(Advanced Programming in the UNIX Environment)》

<!--more-->

## 第7章 进程环境

### 进程标识

ID 为 0 的进程通常是调度进程（交换进程）, 是内核的一部分, 不执行任何磁盘上的程序, 因此也被成为系统进程;
ID 为 1 的进程通常是 init 进程, 在自举过程结束时由内核调用, 负责在自举内核后启动一个 UNIX 系统, 负责接管所有孤儿进程, 不会终止, 是一个普通的用户进程, 但以超级用户特权运行.

### fork

子进程获得父进程的 数据空间、堆和栈的副本（拷贝地址空间）, 但不共享这些存储空间部分, 由于 fork 之后常常跟随 exec, 所以很多实现并不执行数据段、堆和栈的完全副本, 而使用 Copy-On-Write 技术.
父子进程共享正文段.

clone(2) 作为 fork 的推广形式, 它允许调用者控制哪些部分由父进程和子进程共享.

在 fork 之后, 父子进程的执行顺序是不确定的, 这取决于内核的调度算法.

write() 是不带缓冲的; 而标准 I/O 库（如 printf）是带缓冲的, 如果标准输出连到终端设备, 则它是行缓冲的, 否则（将标准输出重定向到一个文件时）它是全缓冲的, 这种情况下 fork 之前父进程 printf 的缓冲数据 fork 后将会被拷贝到子进程中, 若 printf 则会又打印出来.

fork 使得 子进程继承了父进程的：
    所有打开文件描述符;
        父子进程每个相同的打开描述符共享一个文件表项;（因此重定向父进程的标准输出时, 子进程的标准输出也被重定向）
        父子进程共享同一个文件偏移量;（因此一般 1. 父进程等待子进程完成; 2. 父子进程各自执行不同的程序段, 不干扰对方使用的文件描述符）
    实际用户 ID、实际组 ID、有效用户 ID、有效组 ID;
    附属组 ID;
    进程组 ID;
    会话 ID;
    控制终端;
    设置用户 ID 标志和设置组 ID 标志;
    当前工作目录;
    根目录;
    文件模式创建屏蔽字;
    信号屏蔽和安排;
    对任一打开文件描述符的执行关闭（close-on-exec）标志;
    环境;
    连接的共享存储段;
    存储映像;
    资源限制;

父子进程的区别如下：
    fork 的返回值不同;
    进程 ID 不同;
    父进程 ID 不同;
    子进程的 tms_utime、tms_stime、tms_cutime 和 tms_ustime 的值设置为 0;
    子进程不继承父进程设置的文件锁;
    子进程的未处理闹钟被清除;
    子进程的未处理信号集设置为空集;

### vfork

vfork 与 fork 的区别：
    1、vfork 创建的新进程的目的是 exec 一个新程序, 不过在子进程调用 exec 或 exit 之前会在父进程的空间运行;（因此并不将父进程的地址空间完全复制到子进程）
    2、vfork 保证子进程先运行, 在它调用 exec 或 exit 后父进程才可能被调度运行;（如果在调用这两个函数之前子进程依赖父进程的进一步动作则会导致死锁）

### exit

进程有 5 种正常终止和 3 中异常终止方式：
    1、main 函数中执行 return, 相当于对用 exit;
    2、调用 exit;（调用终止处理程序, 关闭所有标准 I/O 流等; 但不处理文件描述符、多进程以及作业控制; 由 ISO C 定义）
    3、调用 _exit 或 _Exit;(在 UNIX 系统中两种调用等价, 并不冲洗标准 I/O 流; 处理 UNIX 系统特定的细节; exit 调用 _exit; 由 POSIX.1 说明)
    4、在进程的最后一个线程在其启动例程中执行 return;（进程以终止状态 0 返回）
    5、进程的最后一个线程调用 pthread_exit 函数;
    1、调用 abort;（产生 SIGABRT 信号, 是下一种异常终止的一种特例）
    2、进程接收到某些信号;（信号可由进程自身（调用 abort）、其他进程或内核产生）
    3、最后一个线程对取消请求作出响应;

不论进程如何终止, 最后都会执行内核中的同一段代码, 即关闭描述符、释放存储器.
子进程正常或异常终止时, 内核向其父进程发送 SIGCHLD 信号.

父进程在子进程前终止：在父进程终止的时候, 内核逐个检查所有活动进程, 若是子进程则将其父进程改为 init 进程.
子进程在父进程前终止：子进程需要告知父进程其如何终止（1. 将退出状态（exit status）作为参数传递给 exit、_exit、_Exit; 2. 异常终止时内核而不是进程本身产生一个指示其异常终止原因的终止状态（termination status））,父进程使用 wait 或 waitpid 取得内核为每个终止子进程保存的一定量信息, 这些信息至少包括 进程 ID、进程终止状态、进程使用的 CPU 时间总量.

一个已经终止而其父进程还未对其获取信息及释放资源的进程称为僵死进程.（ps(1) 打印其状态为 Z）

为防止系统中塞满僵死进程, init 进程设计成只要有子进程终止就会调用 wait 获取其终止状态. 如果一个进程 fork 一个子进程, 但不想父进程等待子进程终止, 也不想子进程处于僵死状态直到父进程终止, 方法是调用 fork 两次, 即通过让子进程终止使子子进程被 init 进程接管.

### wait 和 waitpid

waitpid 可等待一个特定的进程, 而 wait 返回任一终止进程的状态;
waitpid 提供了一个 wait 的非阻塞版本;
waitpid 通过 WUNTRACED 和 WCONTINUED 选项支持作业控制.

历史遗留：waitid()、wait3()、wait4().

## 第8章 进程控制

## 第10章 信号

## 第11章 线程

## 第15章 进程间通信
