<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>antFaiz5z&#39;s Fantastic Fertilizer</title>
  
  <subtitle>Coding the World.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://antfaiz5z.github.io/"/>
  <updated>2019-05-27T12:38:50.703Z</updated>
  <id>https://antfaiz5z.github.io/</id>
  
  <author>
    <name>antFaiz5z</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>科学上网 与 路由器 All in One</title>
    <link href="https://antfaiz5z.github.io/2019/05/27/fqrouter/"/>
    <id>https://antfaiz5z.github.io/2019/05/27/fqrouter/</id>
    <published>2019-05-27T12:22:34.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>one for all.</p><a id="more"></a><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><h3 id="vps"><a href="#vps" class="headerlink" title="vps"></a>vps</h3><h3 id="shadowsocks-R-、V2Ray"><a href="#shadowsocks-R-、V2Ray" class="headerlink" title="shadowsocks(R)、V2Ray"></a>shadowsocks(R)、V2Ray</h3><h3 id="数字移民"><a href="#数字移民" class="headerlink" title="数字移民"></a>数字移民</h3><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><h3 id="路由器选购"><a href="#路由器选购" class="headerlink" title="路由器选购"></a>路由器选购</h3><h3 id="软路由、旁路由"><a href="#软路由、旁路由" class="headerlink" title="软路由、旁路由"></a>软路由、旁路由</h3><h3 id="openwrt、LEDE"><a href="#openwrt、LEDE" class="headerlink" title="openwrt、LEDE"></a>openwrt、LEDE</h3><h3 id="DNS、花生壳"><a href="#DNS、花生壳" class="headerlink" title="DNS、花生壳"></a>DNS、花生壳</h3><h3 id="NAS、内网穿透"><a href="#NAS、内网穿透" class="headerlink" title="NAS、内网穿透"></a>NAS、内网穿透</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;one for all.&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="router" scheme="https://antfaiz5z.github.io/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>《Redis 设计与实现》阅读笔记</title>
    <link href="https://antfaiz5z.github.io/2019/05/17/redis/"/>
    <id>https://antfaiz5z.github.io/2019/05/17/redis/</id>
    <published>2019-05-17T02:43:24.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>第 1 版, 此书基于 Redis 2.9.</p><a id="more"></a><h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><p>Redis 没有直接使用以下几种数据结构来实现键值对数据库, 而是基于这些数据结构创建了一个对象系统.<br>Redis 的每个键值对都是由对象组成, 键总是一个字符串对象, 值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象.</p><h3 id="sds"><a href="#sds" class="headerlink" title="sds"></a>sds</h3><p>Redis 使用 SDS 用作默认字符串表示, C 字符串只会作为字符串字面量用在一些无需对字符串进行修改的地方如打印日志.</p><p><img src="/images/redis-sds.png" alt></p><h3 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h3><p>链表 (双向无环) 是列表键的底层实现之一.</p><p><img src="/images/redis-list.png" alt></p><h3 id="dict-ht"><a href="#dict-ht" class="headerlink" title="dict/ht"></a>dict/ht</h3><p>Redis 的数据库使用字典来作为底层实现, 字典还是哈希键的底层实现之一.<br>字典 使用哈希表作为底层实现.<br>哈希表 使用链地址法 (separate chaining) 来解决键冲突.</p><p><img src="/images/redis-ht.png" alt></p><h3 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h3><p>Redis 使用跳跃表作为有序集合键的底层实现之一.<br>Redis 只在两个地方用到了跳跃表, 一个是实现有序集合键, 一个是在集群节点中用作内部数据结构.<br>每个跳跃表节点的层高都是 1~32 之间的随机数.<br>在同一跳跃表中, 多个节点可以包含相同的分值, 但每个节点的成员对象必须是唯一的.<br>跳跃表中的节点按照分值大小进行排序, 当分值相同时, 节点按照成员对象大小进行排序.</p><p><img src="/images/redis-sl.png" alt></p><h3 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h3><p>整数集合是集合键的底层实现之一.<br>证书集合的底层实现为数组, 这个数组以有序、无重复的方式保存几何元素, 在有需要的时候, 程序会根据新添加元素的类型，改变这个数组的类型. (类型有INSERT_ENC_INT16/32/64)<br>整数集合只支持升级操作, 不支持降级操作.</p><p><img src="/images/redis-intset.png" alt></p><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>压缩列表被用作列表键和哈希键的底层实现之一.<br>压缩列表是一种为节约内存而开发的顺序性数据结构.<br>压缩列表可以包含多个节点, 每个节点可以保存一个字节数组或整数值.<br>在压缩列表中添加新节点或者删除节点, 可能会引发连锁更新操作, 但这种操作出现的几率并不高.</p><p><img src="/images/redis-ziplist1.png" alt></p><p><img src="/images/redis-ziplist2.png" alt></p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>当我们称呼一个键为 “列表键” 时, 我们指的是 “这个数据库键所对应的值为列表对象”.</p><p>Redis 的对象系统实现了基于引用计数的内存回收机制, 继而实现了对象共享机制.<br>Redis 的对象带有访问时间记录信息, 可用于计算数据库键的空转时长, 在服务器启用了 maxmemory 功能的情况下, 空转时长较大的那些键可能会优先被服务器删除.</p><p>TYPE 命令返回数据库键对应的值对象的类型, 而不是键对象的类型.</p><p>字符串对象是 Redis 五种类型对象中唯一一种会被其他四种对象嵌套的对象.</p><p>Redis 只对包含整数值的字符串对象进行共享, 因为尽管共享更复杂对象可以节省更多内存, 但验证操作的时间复杂度也更高.</p><p>Redis 在初始化服务器时, 会预先创建一万个字符串对象用于共享, 包含从 0 至 9999 所有整数值.</p><h2 id="单机数据库"><a href="#单机数据库" class="headerlink" title="单机数据库"></a>单机数据库</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>过期键删除策略有定时删除、惰性删除、定期删除, Redis 采用的是后两种, 服务器可以很好地在合理使用 CPU 时间和避免浪费内存空间之间取得平衡.</p><h3 id="RDB-与-AOF-持久化"><a href="#RDB-与-AOF-持久化" class="headerlink" title="RDB 与 AOF 持久化"></a>RDB 与 AOF 持久化</h3><p>RDB 持久化通过保存数据库中的键值对来记录数据库状态, AOF (Append File Only) 持久化通过保存 Redis 服务器所执行的写命令来记录服务器状态.</p><p>由于 AOF 文件的更新频率比 RDB 文件更高, 所以如果服务器开启了 AOF 持久化功能, 服务器会优先使用 AOF 文件来还原服务器状态.</p><p>SAVE、BGSAVE (background) 命令用于生成 RDB 文件.<br>当 SAVE 命令执行时, Redis 服务器会被阻塞, 此时客户端所有命令请求都会被阻塞.<br>而 BGSAVE 命令的保存工作是由子进程执行的, 所以执行时 Redis 服务器仍可以响应客户端请求.<br>服务器在载入 RDB 文件期间, 会一直处于阻塞状态, 直到载入工作完成.<br>可通过 save 选项配置 BGSAVE 自动间隔性执行.</p><p>Redis 将 AOF 重写程序同样也是放到子程序中执行, 以达到两个目的：<br>1、子进程进行 AOF 重写期间, 服务器进程 (父进程) 可以继续处理命令请求.<br>2、子进程带有服务器进程的数据副本, 使用子进程而不是线程, 可以在避免使用锁的情况下,  保证数据的安全性.<br>但是使用子进程有一个问题, 子进程在进行 AOF 重写期间, 数据库状态可能发生改变, 从而使得重写后的 AOF 所保存的数据库状态已经是过时的了.<br>为了解决这种数据不一致问题, Redis 服务器设置了一个 AOF 重写缓冲区, 即用来记录重写期间的服务器执行的写命令, 当子进程重写完成后会调用一个信号处理函数通知父进程, 将 AOF 重写缓冲区中的内容写入新 AOF 文件中并原子地覆盖原有 AOF 文件, 使得新 AOF 文件所保存的数据库状态和服务器当前的数据库状态一致.</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Redis 服务器是一个事件驱动程序, 其中存在文件事件和时间事件两种事件类型.</p><p>文件事件包括可写事件与可读事件.<br>Redis 基于 Reactor 模式开发了自己的文件事件处理器 (file event handler), 采用单线程 I/O 多路复用.<br>如果一个套接字可读又可写的话, 服务器会先读再写.</p><p>时间事件包括定时事件与周期性事件<br>目前版本 (2.9) Redis  只使用周期性事件, 没有使用定时事件.<br>服务器将所有时间事件放入一个无序链表中, 每次需要遍历查找整个链表中已到达的时间事件, 但无序并不影响时间事件处理器的性能.</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区内, 每个客户端状态都有两个输出缓冲区可用, 一个大小固定, 一个大小可变 (通过使用链表连接多个字符串对象), 前者用于保存那些长度较小的回复 (比如 OK, 简短的字符串值, 整数值, 错误回复等等), 后者用于保存那些长度较大的回复.</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>serverCron 函数默认以每 100 毫秒一次的频率更新 unixtime 和 mstime, 所以其精度并不高.<br>服务器只会在打印日志、更新服务器的 LRU 时间、决定是否执行持久化任务、计算服务器上线时间这类对时间精确度要求不高的功能上使用 unixtime 和 mstime.<br>对于为键设置过期时间、添加慢查询日志这种需要高精度时间的功能来说, 服务器还是会再次执行系统调用, 从而获得最准确的系统当前时间.</p><p>Redis 将服务器进程的 SIGTERM 信号关联到信号关联处理器 sigtermHandler 函数. 服务器在关闭自身之前会进行 RDB 持久化操作, 这也是服务器拦截 SIGTERM 信号的原因, 如果服务器一接到 SIGTERM 信号就立即关闭, 那它就没办法进行持久化操作了.</p><h2 id="多机数据库"><a href="#多机数据库" class="headerlink" title="多机数据库"></a>多机数据库</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>部分重同步通过复制偏移量、复制积压缓冲区、服务器运行 ID 三个部分实现.<br>复制积压缓冲区是由主服务器维护的一个固定长度的 FIFO 队列.</p><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h2 id="独立功能"><a href="#独立功能" class="headerlink" title="独立功能"></a>独立功能</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><ul><li><p><a href="https://github.com/Weiwf/redis-mindmap" target="_blank" rel="noopener">通过思维导图整理 redis 的重要知识点</a></p></li><li><p><a href="https://github.com/Snailclimb/JavaGuide/tree/master/docs/database/Redis" target="_blank" rel="noopener">JavaGuide 中关于 redis 的总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第 1 版, 此书基于 Redis 2.9.&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="Redis" scheme="https://antfaiz5z.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《STL 源码剖析》阅读笔记</title>
    <link href="https://antfaiz5z.github.io/2019/04/29/stl-source/"/>
    <id>https://antfaiz5z.github.io/2019/04/29/stl-source/</id>
    <published>2019-04-29T09:01:15.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>本书针对于 SGI STL.</p><a id="more"></a><h2 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h2><h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>最常用到的迭代器相应型别有五种:</p><ul><li>value type</li><li>difference type</li><li>pointer</li><li>reference</li><li>iterator category</li></ul><p>针对最后一种型别, 根据移动特性和施行措施, 迭代器被分为五类:</p><ul><li>Input Iterator<br>  (struct input_iterator_tag)</li><li>Output Iterator<br>  (struct output_iterator_tag)</li><li>Forward Iterator<br>  (struct forward_iterator_tag)</li><li>Bidirectional Iterator<br>  (struct bidirectional_iterator_tag)</li><li>Random Access Iterator<br>  (struct random_access_iterator_tag)</li></ul><p><img src="/images/iterator.png" alt="各迭代器继承关系"></p><p>原生指针是一种 Random Access Iterator.</p><p>traits 编程技法大量运用于 STL 实现品中. 它利用”内嵌型别”的编程级别与编译器的 template 参数推导功能, 增强 C++ 未能提供的关于型别认证方面的能力, 弥补 C++ 不为强型别 (strong typed) 语言的遗憾.</p><p>iterator_traits 负责萃取迭代器的特性, __type_traits 负责萃取型别 (type) 的特性. 此处关注的型别特性是指, 这个型别是否具有 default cto？ 是否具有 non-trivial copy ctor？ 是否具有 non-trivial assignment operator? 是否具有 non-trivial dtor? 等. 如果答案是否定的, 在对这个型别进行构造、析构、拷贝、赋值操作时, 就可以采用内存直接处理操作如 malloc()、memcpy 等, 获得最高效率.</p><ul><li>__type_traits&lt;T>::has_trivial_constructor</li><li>__type_traits&lt;T>::has_trivial_copy_constructor</li><li>__type_traits&lt;T>::has_trivial_assignment_operator</li><li>__type_traits&lt;T>::has_trivial_destructor</li><li>__type_traits&lt;T>::is_POD_type</li></ul><p>上述式子的返回值不是只是简单的 bool 值, 而是空的结构体: struct <code>__true_type</code> 和 struct <code>__false_type</code>, 因为如此编译器可以做类型推导. 一般具现体 (general instantiation), 内含对所有型别都必定有效的保守值. 上述各个 has_trivial_xxx 及 is_POD_type 型别都被定义为 <code>__false_type</code>, 就是对所有型别都必定有效的保守值. 而对于 C++ 基本型别 (char、int、unsigned int 等) 在 &lt;type_traits.h&gt; 中提供特化版本, 上述每一个成员的值都是 <code>__true_type</code>, 表示这些型别可以采用最快速方式 (例如 memcpy) 来进行拷贝或赋值操作.</p><h2 id="container"><a href="#container" class="headerlink" title="container"></a>container</h2><p><img src="/images/container.png" alt="SGI STL 的各种容器 (以内缩方式表示基层与衍生层关系)"></p><p>这里所谓的衍生并非派生 (inheritance) 关系, 而是内含 (containment) 关系. 例如<br>heap 内含一个 vector,<br>priority_queue 内含一个 heap,<br>stack 和 queue 内含一个 deque,<br>set/map/multiset/multimap 都内含一个 RB-tree,<br>hash_&lt;set/map/multiset/multimap&gt; 都内含一个 hashtable.</p><h3 id="sequence-containers"><a href="#sequence-containers" class="headerlink" title="sequence containers"></a>sequence containers</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>vector 默认使用 alloc 作为空间配置器.<br>vector 的迭代器是普通指针, 也就是 Random Access Iterator.</p><p>增加新元素时若超过 capacity, 则 capacity 扩充至两倍 (不同 STL 实现此数字可不同), 若两倍仍不足则继续扩充. 容量的扩充必须经历”重新配置、元素移动、释放原空间”等过程.<br>重新配置: 如果原大小为 0, 则配置 1 (个元素大小), 不为 0 则配置为原来的两倍.<br>元素移动: 先将原 vector 从 start 至 position (插入点) 的部分拷贝至新 vector (此时新 vector 的 finish == position), 再将新 vector 从 finish 开始的剩余部分赋初值 x (原插入值), 接着 ++finish (相当于已将 x 插入), 最后将原 vector 从 position 开始的剩余部分拷贝至新 vector.<br>释放原空间: 调用 destroy() 和 deallocate().</p><p>在 push_back() 中因备用空间不够而调用的 insert_aux() 即是采用上述流程, 然而在 push_back() 中实际上插入点 position 已经等于 finish, 所以流程中后半部分的将 position 到 finish 部分进行拷贝是否必要有待商榷, 书中提到了译者侯捷对此也抱有疑问.</p><p>在 insert() 中便区分有三种情况: (finish - position) &gt; n、(finish - position) &lt;= n、备用空间不够， 其中 n 为插入个数. 第三种情况即是采用上述流程, 稍微不同的是中间是插入 n 个 x 而不是简单的 ++finish. 第一种情况直接将插入点后的元素向后拷贝 copy_backward(), 第二中情况先在 finish 之后填充 x 再 copy_backward() 再在 finish 之前覆盖 x.</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list 默认使用 alloc 作为空间配置器，并据此定义了一个 list_node_allocator.<br>list 不仅是一个双向链表, 还是一个环状双向链表, 所以它只需要一个指针便可以完整表现整个链表. 所以 list 提供的是 Bidirectional Iterator.</p><p>list 进行 insert() 和 spice() 操作都不会使迭代器失效 (而 vector 的插入操作可能会使内存重新配置而导致所有迭代器失效), 甚至 erase() 操作也只会使指向被删除元素的迭代器失效其他不受影响.</p><p>list 初始化时即有一个空白节点, begin() 初始时指向此, end() 始终指向于此.</p><p>(<code>p138</code>) ??? next = first // 修正区段范围</p><p>list 不能使用 STL 算法 sort(), 必须使用自己的 sort() 成员函数 (使用了快排<code>p142</code>), 因为前者只接受 RandomAccessIterator.</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque 没有所谓容量 (capacity) 概念, 因为它是以分段连续空间组合而成, 随时可以增加一段新的空间并链接起来.</p><p>deque 提供 Random Access Iterator, 但它的迭代器并不是普通指针, 其复杂度高 (实现代码分量比 vector 和 list 多得多).</p><p>中控器 map (非 STL 中的 map 容器), 一个 map 要管理多个节点, 最少8个, 最多是 “所需节点数加 2”(前后各预留一个, 扩充时可用).</p><p>(<code>p151</code>) ??? __deque_iterator&lt;&gt; 没有为 (finish -1) 定义运算子.<br>         ??? // 下行最后有两个 ‘;’, 虽奇怪但符合语法</p><p>deque 自行定义了两个专属的空间配置器: data_allocator (每次配置一个元素大小)、map_allocator (每次配置一个指针大小)</p><p>deque 的最初状态 (无任何元素时) 保留有一个缓冲区, y因此 clear() 完成后恢复初始状态也一样保留一个缓冲区：若 start 与 finish 在不同缓冲区, 将除头缓冲区与尾缓冲区之外的缓冲区内的所有元素析构并释放缓冲区内存, 再将头尾缓冲区的元素析构并释放尾缓冲区的内存而保留头缓冲区; 若 start 与 finish 在同一缓冲区, 则析构这唯一缓冲区所有元素并保留此缓冲区.</p><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>SGI STL 默认以 deuqe 作为 stack 的底部结构 (以 list 同样可以做到), 因此其实现非常简单. 往往被归类为容器配接器.</p><p>stack 不提供遍历功能, 也不提供迭代器.</p><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>SGI STL 默认以 deuqe 作为 queue 的底部结构 (以 list 同样可以做到), 因此其实现非常简单. 往往被归类为容器配接器.</p><p>queue 不提供遍历功能, 也不提供迭代器.</p><h4 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h4><p>heap 不属于 STL 容器组件, 扮演 priority_queue 的助手. priority_queue 的复杂度最好介于 queue 与 binary search tree 之间, 因此 binary heap 便是这种条件下的适当候选人. 所谓 binary heap 就是一种 complete binary tree.</p><p>一种 array 隐式表述 tree 的方式: 将 array 的 #0 元素保留, 那么当某个节点位于 array 的 #i 处, 它的左子节点位于 #2i 处, 右子节点位于 #2i +1处, 父节点位于 #i/2 处.</p><p>推荐使用 vector 而不是 array, array无法动态改变大小, 因此不可以对满载的 array 进行 push_heap() 操作.</p><p>按照元素排列方式, heap 可分为 max-heap 和 min-heap, STL 提供的是 max-heap.</p><p>heap 不提供遍历功能, 也不提供迭代器.</p><h5 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap()"></a>push_heap()</h5><p>percolate up (上溯)：<br>新加入的元素首先一定放在最下一层作为叶节点, 填补在从左至右第一个空格, 也就是插入到 vector 的 end() 处.<br>为满足 mxa-heap 的条件 (每个节点的键值都大于等于其子节点键值), 如果键值比父节点大, 就父子对换键值, 直到不需对换或到根节点为止.</p><p>该函数接受两个迭代器用来表现 heap 底部容器 vector 的头尾, 并且前提是新元素已插入到 end().</p><p>(<code>p175</code>) ??? parent = (holeIndex - 1) /2<br>意味着具体实现并不是如上所述将 #0 保留的隐式表述法?</p><h5 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap()"></a>pop_heap()</h5><p>percoalte down (下溯)：<br>pop_heap() 操作取走根节点 (具体实现中是首先将根节点与最右下节点键值对换, 最后用 pop_back() 原根节点, pop_heap() 中未调用 pop_back()), 任务是将最右下的元素重新找一个合适的位置, 首先将其填入根节点位置, 再与左右子节点比较键值, 如果其键值较小, 则与较大子节点对换键值, 直到不需对换或下放到叶节点为止.</p><p>该函数接受两个迭代器用来表现 heap 底部容器 vector 的头尾.</p><p>(<code>p177</code>) ??? 未比较 value 与左右子节点键值大小<br>总是小于右子节点？</p><h5 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap()"></a>sort_heap()</h5><p>多次 pop_heap() 且每次操作范围从后向前缩减一个元素 (pop_heap() 会将最大元素放在底部容器最尾端), 最后便得到一个递增序列. 排序过后, 原来的 heap 就不是一个合法的 heap 了.</p><p>该函数接受两个迭代器用来表现 heap 底部容器 vector 的头尾.</p><h5 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap()"></a>make_heap()</h5><p>这个算法用来将一段现有的数据转化为一个 heap, 主要依据前文所述的隐式表述法.</p><p>(<code>p180</code>) ??? parent = (len -2) /2<br>最后一层叶子节点在后续的 adjust_heap() 中自然会归于上下有序.</p><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>priority_queue 默认使用一个 max-heap 完成.</p><p>SGI STL 默认以 vector 作为 priority_queue 的底部结构, 再加上 heap 处理规则, 因此其实现非常简单. 往往被归类为容器配接器.</p><p>priority_queue 不提供遍历功能, 也不提供迭代器.</p><p>构造函数调用 make_heap();<br>push() 先后调用 push_back()、push_heap();<br>pop() 先后调用 pop_heap()、pop_back();</p><h4 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h4><p>SGI STL 提供单向链表, 不在标准之内.</p><p>slist 和 list 的主要区别在于前者的迭代器属于 Forward Iterator, 而后者为 Bidirectional Iterator.</p><p>基于效率考虑, slist 特别提供了 insert_after() 和 erase_after(), 并不提供 push_back(), 只提供 push_front().</p><p>??? end() 指向空, 不是如 list 一般的空节点.</p><h3 id="associative-containers"><a href="#associative-containers" class="headerlink" title="associative containers"></a>associative containers</h3><p>RB-tree 有自动排序功能, 而 hashtable 没有. 意味着 [multi]&lt;set/map&gt; 有自动排序功能, 而 hash_[multi]&lt;set/map&gt; 没有. 如果表格足够大, 后者可出现排序假象.</p><h4 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h4><p>为了更大的弹性, SGI 将 RB-tree 迭代器实现为两层 (双层节点结构与双层迭代器结构设计), 这种设计理念和 slist 类似.</p><p>RB-tree 迭代器属于 Bidrectional Iterator, 其提领操作和成员访问操作与 list 十分相似.</p><p>(<code>p216</code>) ??? node-&gt;parent-&gt;parent = node<br>实现上的技巧: header-&gt;parent == root; root-&gt;parent == header; header-&gt;left == leftmost; header-&gt;right == rightmost;<br>??? RB-tree 的 begin() == leftmost; end() == header;<br>RB-tree 初始化时产生一个 header 节点空间, 令其为红色, header 左右子节点为自己.</p><p>RB-tree 一开始即要求用户必须明确设定所谓的 KeyOfValue 仿函数, 从实值 (value) 取出键值 (key).</p><p>(<code>p224</code>) !!! insert_unique()<br>             __rb_tree_rebalance()</p><h4 id="multi-lt-set-map-gt"><a href="#multi-lt-set-map-gt" class="headerlink" title="[multi]&lt;set/map&gt;"></a>[multi]&lt;set/map&gt;</h4><p>set\<t>::iterator 被定义为底层 RB-tree 的 const_iterator, 杜绝写入操作, 也就是说, set 的 iterator 是一种 constant iterator, 相对于 mutable iterator 来说.<br>map 的键值不可改变, 实值可以改变, 因此 map 的 iterator 既不是 constant iterator 也不是 mutable iterator.</t></p><p>几乎所有的 set、map 操作行为都只是转调 RB-tree 的操作行为而已.</p><p>set、map 一定使用 RB-tree 的 insert_unique(), multiset、multimap 才使用 RB-tree 的 insert_equal().</p><p><code>template &lt;... class Compare = less&lt;key&gt; ...&gt;</code>: 默认采用递增排序.</p><p>面对关联容器, 应该使用其所提供的 find 函数来搜寻元素, 会比使用 STL 的算法 find() 更有效率, 因为后者只是循序搜寻.</p><h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><p>bst 具有对数平均时间的表现, 而 hashtable 具有常数平均时间的表现, 且这种表现是以统计为基础, 不需仰赖输入元素的随机性.</p><p>包括有: 线性探测 (linear probing)、二次探测 (quadratic probing)、开链 (separate chaining)<br>前二者负载系数永远在 0~1 之间, 而开链策略可以大于 1.<br>SGI STL 的 hashtable 便是采用 开链.</p><p>元素的删除必须采用惰性删除, 也就是只标记删除记号, 实际删除操作则待表格重新整理 (rehashing) 时再进行, 这是因为hashtable 中每个元素不仅表述自己, 也关系到其他元素的排列.<br>二次探测主要用来解决主集团 (primary clustering) 的问题, 但却可能造成次集团 (secondary clustering) 的问题 (两个元素经 hash function 计算出来的位置若相同, 则插入时所探测的位置也相同, 造成某种浪费), 当然消除次集团的办法也有, 例如复式散列 (double hashing). 如果我们假设表格大小为<code>质数</code>, 而且永远保持负载系数在 0.5 以下, 那么就可以确定每插入一个新元素所需要的探测次数不多于 2.</p><p>在 SGI STL 中采用开链策略的 hashtable 中, buckets 以 vector 完成, bucket 所维护的链表, 并不采用 STL 的 list 或 slist, 而是自行维护 struct __hashtable_node.<br>迭代器为 Forward Iterator, operator++ 操作为 尝试访问当前节点的 next, 非空即是结果, 否则即是链表的尾端, 就跳至下一个 bucket.<br>虽然开链法不要求表格大小必须为质数, 但 SGI STL 仍然以质数来设计表格大小, 并且先将 28 个质数 (逐渐呈现约两倍的关系, 53、97、193、389…) 计算好, 以备随时访问.<br>插入行为可 insert_unique() (对应于非 multi) 与 insert_equal() (对应于 multi).<br>“表格重建与否”的判断原则为: 拿元素个数 (包括新增元素) 和 bucket vector 的大小比较, 如果前者大于后者就重建表格. 重建时, 先建立一个新 bucket vector, 将每个节点重新计算应该落在哪个 bucket 上后转移到新 bucket vector 上,最后与旧 bucket vector 进行 swap().</p><p>hashtable.size() 变化, 而不一定等于 hashtable.bucket_count(), 后者发生重建时变化.</p><p>SGI hashtable 无法处理 string (char* 却可以)、double、float 这些型别 (insert() 时才出错), 欲处理这些型别, 用户必须自行为它们定义 hash function.</p><h4 id="hash-multi-lt-set-map-gt"><a href="#hash-multi-lt-set-map-gt" class="headerlink" title="hash_[multi]&lt;set/map&gt;"></a>hash_[multi]&lt;set/map&gt;</h4><p>hash_[multi]&lt;set/map&gt; 默认表格大小为 100 (根据 STL 的设计, 采用质数 193).</p><h2 id="algorithms"><a href="#algorithms" class="headerlink" title="algorithms"></a>algorithms</h2><p><code>#include &lt;numeric&gt;</code> <code>#include &lt;algorithm&gt;</code></p><p>质变算法, 诸如拷贝 (copy)、互换(swap)、替换(replace)、填写(fill)、删除(remove)、排列组合(permutation)、分割(partition)、随机重排(random shuffing)、排序(sort).<br>如果将此类算法运用于一个常数区间上, 编译器将会报错.<br>非质变算法, 诸如查找 (find)、匹配 (search)、计数 (count)、巡访 (for_each)、比较 (equal, mismatch)、寻找极值 (max, min).</p><p>所有泛型算法的前两个参数都是一对迭代器 [first, last), 必要条件是能够经由 increment 操作符的反复运用从 first 到达 last, 而编译器本身无法强求这一点, 如果不成立将会导致不可预期的结果.</p><p>将无效或者说不匹配的迭代器传给某个算法, 虽然是一种错误, 但却不能保证在编译期就能够被捕捉, 因为所谓”迭代器类型”并不是真正的型别, 它们只是一种型别参数 (type parameters).</p><h2 id="functors-function-objects"><a href="#functors-function-objects" class="headerlink" title="functors / function objects"></a>functors / function objects</h2><p><code>#include &lt;functional&gt;</code></p><p>虽然函数指针可以达到”将整组操作当做算法的参数”, 但其不能满足 STL 对抽象性的要求, 且无法和 STL 其他组件 (如 adapter) 搭配, 产生更灵活的变化.</p><p>仿函数按操作数 (operand) 个数分为 一元和二元 (STL 不支持三元仿函数), 按功能分为 算术运算 (Arithmetic)、关系运算 (Rational)、逻辑运算 (Logical).</p><p>证同 (identity)、选择 (select)、投射 (project) 仿函数并不在 C++标准规格之内, 但它们常常存在于各个实现品中作为内部使用<br>证同: 直接返回参数. 在 …set 中用来指定 RB-tree 所需的 KeyOfValue op, 因为 set 的键值即其实值.<br>选择: 接收 pair, 直接返回 first 或 last. 在 …map 中用来指定 RB-tree 所需的 KeyOfValue op, 因为 map 的键值即 pair 的 first.<br>投射: 接收两个参数, 直接返回第一参数或第二参数.</p><h2 id="adapters"><a href="#adapters" class="headerlink" title="adapters"></a>adapters</h2><p>container adapters: 包括 queue 和 stack 即是修饰 deque 的接口而成.<br>iterator adapters: 包括 insert iterator、reverse iterator、iostream iterator.<br>functor/funciton adapters: 配接操作包括 绑定 (bind)、否定 (negate)、组合 (compose).</p><p>所有期望获得配接能力的组件, 本身必须是可配接的 (adaptable). 换句话说, 一元仿函数必须继承自 unary_function, 二元仿函数必须继承自 binary_function, 成员函数必须以 mem_fun 处理过, 一般函数必须以 ptr_fun 处理过. 一个未经 ptr_fun 处理过的一般函数, 虽然也可以函数指针的形式传给 STL 算法使用, 却无法拥有任何配接能力.</p><p>insert iterator 有三种: back_insert_iterator、front_insert_iterator、insert_iterator, 其 iterator_category 都为 output_iterator_tag;<br>reverse_iterator<iterator> 的 5 种相应型别都与其对应的正向迭代器相同;<br>istream_iterator 的 iterator_category 为 input_iterator_tag;<br>ostream_iterator 的 iterator_category 为 output_iterator_tag.</iterator></p><p><img src="/images/riterator.png" alt="reverse iterator"></p><p>container adapter 内藏了一个 container member;<br>insert iterator   内藏了一个 pointer to container (并因而取得其 iterator);<br>reverse iterator  内藏了一个 iterator number;<br>stream iterator   内藏了一个 pointer to stream;<br>function adapter  内藏了一个 member object, 其型别等同于它所要配接的对象 (这个对象当然是一个 adaptable functor).</p><p>源码中经常出现的 pred 一次, 是 predicate 的缩写, 意指会返回真假值 (bool)  的表达式.</p><h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>容器以 class template 完成;<br>算法以 function templates 完成;<br>仿函数是一种将 operator() 重载的 class template;<br>迭代器是一种将 operator++ 和 operator* 等指针习惯常行为重载的 class template;<br>配接器中的 container adapter 和 iterator adapter 都是一种 class template, 而 function adapter.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本书针对于 SGI STL.&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="STL" scheme="https://antfaiz5z.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》等阅读笔记</title>
    <link href="https://antfaiz5z.github.io/2019/04/26/effective-cpp/"/>
    <id>https://antfaiz5z.github.io/2019/04/26/effective-cpp/</id>
    <published>2019-04-26T06:23:29.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 书籍阅读笔记</p><a id="more"></a><h2 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h2><h2 id="Effective-Modern-C"><a href="#Effective-Modern-C" class="headerlink" title="Effective Modern C++"></a>Effective Modern C++</h2><h3 id="Item-3-理解-decltype"><a href="#Item-3-理解-decltype" class="headerlink" title="Item 3: 理解 decltype"></a>Item 3: 理解 decltype</h3><p>decltyp e大多数情况下总是不加修改地产出变量和表达式的类型, 对于 T 类型的 lvalue 表达式, decltype 总是产出 T&amp;.</p><p>C++14 支持 decltype(auto), 和auto一样, 他从一个初始化器中推导类型, 只不过使用的是 decltype 类型推导规则. 这一开始看起来可能有点矛盾的东西确实完美地结合在一起：auto明确了类型需要被推导, decltype 明确了推导时使用 decltype 推导规则.</p><p>在 C++11 中，也许 decltype 最主要的用途就是用来声明 返回值类型依赖于参数类型的 函数模板.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line">cosnt Widget&amp; cw = w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw;</span><br><span class="line"><span class="comment">//myWidget1的类型是Widget</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw</span><br><span class="line"><span class="comment">//myWidget2的类型是const Widget&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) f1()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x;   <span class="comment">//decltypex(x)是int，所以f1返回int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) f2()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (x); <span class="comment">//decltype((x))是int&amp;，所以f2返回int&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//记住f2不仅仅是返回值和f1不同，它还返回了一个局部变量。这是一种把你推向未定义行为的陷阱代码</span></span><br></pre></td></tr></table></figure><p>rvalue 不能和 lvalue 引用绑定 (除非是 const 左值引用( lvalue-references-to-const ))</p><h3 id="Item-18-22-智能指针"><a href="#Item-18-22-智能指针" class="headerlink" title="Item 18-22: 智能指针"></a>Item 18-22: 智能指针</h3><p>auto_ptr 和 unique_ptr 采用的是 ownership (建立所有权) 概念, 对于特定对象, 只能被一个智能指针所拥有, 这样, 只有拥有该对象的智能指针的析构函数才会删除该对象, 然后要注意的是, 赋值操作会转让操作权.<br>虽然 auto_ptr 和 unique_ptr 都采用该策略, 但是 unique_ptr 的策略更严格. 当出现上述情况时, 程序会编译出错 (这是因为 unique_ptr 内部将拷贝构造函数给 delete 了, 但赋值是允许的), 而 auto_ptr 则会在执行阶段 core dumped.<br>shared_ptr 则采用 reference counting (引用计数) 的策略, 例如, 赋值时, 计数 +1, 指针过期时, 计数 -1. 只有当计数为 0 时, 即最后一个指针过期时, 才会被析构掉.</p><p>要安全的重用 unique_ptr 指针, 可给它赋新值. C++为其提供了 std::move() 方法. 而 auto_ptr 由于策略没有 unique_ptr 严格, 无需使用move方法. 由于 unique_ptr 使用了 C++11 新增的移动构造函数和右值引用, 所以可以区分安全和不安全的用法.</p><p>auto_ptr 和 shared_ptr 可以和 new 一起使用, 但不可以和 new[] 一起使用, 但是 unique_ptr 可以和 new[] 一起使用.</p><p>weak_ptr 是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少, 没有重载 * 和 -&gt; 但可以使用 lock() 获得一个可用的 shared_ptr 对象.<br>weak_ptr 的一个重要用途是通过 lock() 获得 this 指针的 shared_ptr, 使对象自己能够生产 shared_ptr 来管理自己, 但助手类 enable_shared_from_this 的 shared_from_this 会返回 this 的 shared_ptr, 只需要让想被 shared_ptr 管理的类从它继承即可.</p><p>当多个对象指向同一个对象的指针时, 应选择 shared_ptr.<br>用 new 申请的内存, 返回指向这块内存的指针时, 选择 unique_ptr 就不错.<br>unique_ptr 为右值(不准确的说类似无法寻址)时, 可以赋给shared_ptr.</p><h3 id="Item-23-理解-std-move-与-std-forward"><a href="#Item-23-理解-std-move-与-std-forward" class="headerlink" title="Item 23: 理解 std::move 与 std::forward"></a>Item 23: 理解 std::move 与 std::forward</h3><p>std::move 无条件将它的参数转化为 rvalue, 只作转换, 不作 move, 且建议参数为非 const 的 rvalue reference, 这是由于 const 的参数被转换成 const rvalue, 将会被传递给 copy constructor, 实际上并没有 “move”. 这样的行为对于保持const 的正确性是必须的. 从一个对象里 move 出一个值通常会改变这个对象, 所以语言不允许将 const 对象传递给像 move constructor 这样的会改变对象的函数.</p><p>std::forward 的情况和 std::move 相类似, 但 std::forward 是一个有条件的转换, 它只把用 rvalue 初始化的参数转换成 rvalue.</p><p>注意 std::move 只需要一个函数参数, 而 std::forward 却需要一个函数参数以及一个模板类型参数. std::move 和 std::forward 在运行期都没有做任何事情.</p><h2 id="C-Concurrency-In-Action"><a href="#C-Concurrency-In-Action" class="headerlink" title="C++ Concurrency In Action"></a>C++ Concurrency In Action</h2><h2 id="Essential-C"><a href="#Essential-C" class="headerlink" title="Essential C++"></a>Essential C++</h2><h2 id="More-Effective-C"><a href="#More-Effective-C" class="headerlink" title="More Effective C++"></a>More Effective C++</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 书籍阅读笔记&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="effective" scheme="https://antfaiz5z.github.io/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>面试问题整理</title>
    <link href="https://antfaiz5z.github.io/2019/03/21/interview/"/>
    <id>https://antfaiz5z.github.io/2019/03/21/interview/</id>
    <published>2019-03-21T07:37:13.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对于 C++ 面试中常见问题进行整理并尽量作口语化而非书面化的回答。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="C-C-基础"><a href="#C-C-基础" class="headerlink" title="C/C++基础"></a>C/C++基础</h2><ul><li>内存布局</li><li>内存对齐</li><li>指针与引用</li><li>new、delete、malloc、free</li><li>虚函数、虚表、虚表指针</li><li>智能指针</li><li>static_cast、dynamic_cast、const_cast、reinterpret_cast</li></ul><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><ul><li>容器：分类、复杂度</li><li>vector</li><li>set、map</li><li>allocator</li><li>iterator、traits</li></ul><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ul><li>TCP 与 UDP</li><li><p>三次握手</p><p>  首先，接收方调用 listen() 处于 LISTEN 状态，<br>  发送方调用 connect() 发送一个 SYN 包，转为 SYN_SNET 状态，<br>  接收方接收到后发送 SYN + 相应的 ACK 包，转为 SYN_RCVD 状态，<br>  发送方收到后转为 ESTABLISHED 状态，接着再发送相应的 ACK 包，<br>  接收方收到后也转为 ESTABLISHED 状态，<br>  至此，全双工通信的可靠连接建立完成。</p><ul><li><p>为什么TCP建立连接要三次握手</p><p>首先得回答三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。然后可以回答为什么两次握手不行，两次握手可能因为丢包而出现死锁，假设在两次握手场景中，C向S发送请求，S收到并发送确认请求给C，这时候S认为连接已经建立，并开始发送数据给C，但是那个确认请求丢包了，C不认为请求建立了，C当然会拒绝接受S发送来的数据，并且再去请求连接。这样，一个资源就死锁了。最后回答握手当然可以四次五次一直握下去，但三次已经够了，就没有必要了。总结下来一句话，主要目的防止在网络发生延迟或者丢包的情况下浪费资源。</p></li></ul></li><li><p>四次挥手</p><p>  首先，发送方主动调用 close() 发起连接断开请求，发送一个 FIN 包，进入 FIN_WAIT_1 状态，<br>  接收方收到后转为 CLOSE_WAIT 状态，<br>  接收方发送相应的 ACK 包，发送方收到后转为 FIN_WAIT_2 状态，<br>  接收方调用 close(), 发送一个 FIN 包，转为 LAST_ACK 状态，<br>  送方收到后转为 TIME_WAIT 状态，等待 2MSL 时间后关闭连接，<br>  发送方发送相应的 ACK 包，接收方收到后正式关闭连接。</p></li><li><p>流量控制、拥塞控制、重传</p></li><li>编程函数</li><li>报头</li></ul><h2 id="HTTP-S"><a href="#HTTP-S" class="headerlink" title="HTTP[S]"></a>HTTP[S]</h2><ul><li>版本变化：0.9/1.0/1.1/2.0</li><li>get、post</li><li>证书、密钥</li><li>一次完整的访问网页的过程</li><li>报头</li><li>状态码</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>进程、线程、协程</li><li>同步与互斥</li><li>IPC</li><li>虚拟内存：高端内存、伙伴、slab、vmalloc</li><li>IO 模型</li><li>EPOLL</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul><li>SQL语言</li><li>索引</li><li>MyISAM 与 InnoDB</li><li>四个原则</li><li>四个隔离级别</li><li>两段锁</li><li>MVVC</li><li>分区、分表、分库</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul><li>map_reduce</li><li>负载均衡</li><li>CDN</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要针对于 C++ 面试中常见问题进行整理并尽量作口语化而非书面化的回答。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="interview" scheme="https://antfaiz5z.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>使用 LaTeX 进行学术写作</title>
    <link href="https://antfaiz5z.github.io/2019/01/10/latex/"/>
    <id>https://antfaiz5z.github.io/2019/01/10/latex/</id>
    <published>2019-01-10T04:56:17.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<pre><code>待填坑.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;待填坑.
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="Academic" scheme="https://antfaiz5z.github.io/categories/Academic/"/>
    
    
      <category term="latex" scheme="https://antfaiz5z.github.io/tags/latex/"/>
    
      <category term="tex live" scheme="https://antfaiz5z.github.io/tags/tex-live/"/>
    
  </entry>
  
  <entry>
    <title>利用 Travis CI 自动部署博客</title>
    <link href="https://antfaiz5z.github.io/2018/11/30/travis/"/>
    <id>https://antfaiz5z.github.io/2018/11/30/travis/</id>
    <published>2018-11-30T04:22:36.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续集成到共享主线（mainline）的一种举措。</p></blockquote><p>简单来说，我们通过持续集成，能够简化 Hexo 发布博客的步骤，即：将清除缓存 hexo clean，生成静态文件 hexo generate 和部署到 GitHub Pages hexo deploy 这些步骤通过持续集成工具来帮助我们自动执行。</p><p>这样我们在本地对博客文件进行修改、新增博文内容或者新增博客文章，只需要通过 git 推送到 GitHub 仓库之后，持续集成工具就可以帮助我们在线构建博客静态文件并直接部署到 GitHub Pages。这之后，我们发布博客内容就不需要本地三步走了。</p><h3 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h3><p>我们所利用的持续集成平台是 Travis CI.<br>首先，我们到 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 官网，用自己的 GitHub 账户直接关联登录，并允许 Travis CI 查看自己的公有仓库。</p><p>然后我们到 Travis CI 账户页面 开启我们的博客仓库。</p><h3 id="配置持续集成文件"><a href="#配置持续集成文件" class="headerlink" title="配置持续集成文件"></a>配置持续集成文件</h3><p>.travis.yml 是 Travis CI 的部署配置文件，Travis CI 部署时会自动读取我们每次 Commit 中是否包含 .travis.yml，有此文件才会开始部署。</p><p>在博客项目源代码分支下创建文件 .travis.yml，并添加如下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">whopro</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">export</span> <span class="string">TZ='Asia/Shanghai'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span> <span class="bullet">-g</span> <span class="string">cnpm</span> <span class="bullet">--registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cnpm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="bullet">-g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  provider:</span> <span class="string">pages</span></span><br><span class="line"><span class="attr">  skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  github_token:</span> <span class="string">$GITHUB_TOKEN</span></span><br><span class="line"><span class="attr">  local_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$GIT_NAME</span></span><br><span class="line"><span class="attr">  email:</span> <span class="string">$GIT_EMAIL</span></span><br><span class="line"><span class="attr">  keep-history:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  target-branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  on:</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">whopro</span></span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><p>language：编译语言、环境；</p></li><li><p>node_js：Node.js 版本；</p></li><li><p>sudo：需要管理员权限；</p></li><li><p>install：安装环境 npm；</p></li><li><p>branches：工作仓库分支（hexo 分支）；</p></li><li><p>before_install：配置时区为中国时区东八区（UTC + 8），安装组件 hexo；</p></li><li><p>install：安装依赖 npm install；</p></li><li><p>script：执行脚本，清除缓存，生成静态文件并放在 public 文件夹下；</p></li><li><p>deploy：执行部署。</p></li></ul><blockquote><p>其他文档可能提到了利用 hexo-deployer-git 进行部署，但是由于 Travis CI 本身支持直接部署到 GitHub Pages 的工具，因此无需另行安装 hexo-deployer-git 了；<br><br>其他文档也可能提到在 .travis.yml 中加入如下内容，来缓存 node_modules 下的内容，从而加快编译速度。但是经过我的尝试，node_modules 经常会由于没有及时更新，在添加其他组件之后出现「博客生成静态文件步骤」失败的情况，因此建议不进行缓存处理。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules</span></span><br></pre></td></tr></table></figure><h3 id="在-Travis-CI-中配置变量"><a href="#在-Travis-CI-中配置变量" class="headerlink" title="在 Travis CI 中配置变量"></a>在 Travis CI 中配置变量</h3><p>在配置文件中我们使用了三个变量：</p><ul><li><p>$GIT_NAME：git 用户名</p></li><li><p>$GIT_EMAIL：git 用户邮箱</p></li><li><p>$GITHUB_TOKEN：GitHub 通行证 (token) 字符串</p></li></ul><p>最后一项 GitHub 通行证 (token) 我们在 GitHub 中进行申请：</p><p>访问 GitHub 账户设置 &gt; Tokens</p><p>生成新 Token: Generate new token</p><p>填入 Token 描述，并给予 Token 第一项 repo 的全部权限</p><p>将生成的 Token 复制，保存（生成 Token 的页面只有一次机会看见，请保存妥当。）</p><p>在 Travis CI 仓库配置中，将三个变量填入设置（位于 Settings &gt; Environment Variables 处并保存：</p><p>在 Travis CI 仓库配置中，将三个变量填入设置（位于 Settings &gt; Environment Variables 处并保存：</p><p>这样，在每次我们将博客的源文件通过 git 推送到 GitHub 的 hexo 分支上后，Travis CI 就会自动检测并主动开始构建我们的博客静态文件，并自动部署到 GitHub Pages 中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续集成到共享主线（mainline）的一种举措。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，我们通过持续集
      
    
    </summary>
    
      <category term="CI" scheme="https://antfaiz5z.github.io/categories/CI/"/>
    
    
      <category term="hexo" scheme="https://antfaiz5z.github.io/tags/hexo/"/>
    
      <category term="travis" scheme="https://antfaiz5z.github.io/tags/travis/"/>
    
  </entry>
  
  <entry>
    <title>Back to Windows With WSL or CygWin ?</title>
    <link href="https://antfaiz5z.github.io/2018/11/27/wsl/"/>
    <id>https://antfaiz5z.github.io/2018/11/27/wsl/</id>
    <published>2018-11-27T03:07:09.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><p>初学 C/C++, 在windows上使用 codeblocks 写写算法甚是不错,  visual studio 宇宙最强 IDE 自然也是不虚(大概是太强了, 至今没有玩明白…).</p><p>后接触 linux  开发, 便使用上了 vmware , 快照回滚、双机调试、镜像备份等特别适合于折腾 ubuntu 时环境复现、编译内核啥的.</p><p>之后看到了 deepin , 自带 wine 与软件商店尤适合于日常使用, 于是一直执着于纯 deepin 或是 deepin + windows 双系统.</p><p>现觉, linux 总是会出现各种兼容性问题比如显卡驱动、办公软件等, 诚然, linux 的斜杠与 LF 和 windows 的反斜杠与 CRLF 相比, “人类”与”反人类”必定是前者令人心驰神往, 但时常由于工作场景需要在双系统或双机器间来回切换总归令人不快, 便寻摸着如何回归 windows…</p><p>其实, cmake、git、docker、node等一直都有提供 windows 平台对应的十分成熟的软件，甚至提供 GUI 工具, 于是问题便在于可编写跨平台程序的 C/C++ 编译器.</p><h2 id="几种方案"><a href="#几种方案" class="headerlink" title="几种方案"></a>几种方案</h2><h3 id="CygWin"><a href="#CygWin" class="headerlink" title="CygWin"></a>CygWin</h3><p>MinGW 与 CygWin 都能让你在 windows 下编译 unix 风格的 C/C++ 代码. MinGW 与 CygWin 的区别:</p><ol><li>修改编译器, 让 windows 下的编译器把诸如 fork 的调用翻译成等价的形式, 这就是 MinGW 的做法.</li><li>修改库, 让 windows 提供一个类似 unix 提供的库,他们对程序的接口如同 unix 一样, 而这些库当然是由 win32 的 API 实现的, 这就是 CygWin 的做法.</li></ol><p>CygWin 与 MinGW 的最大区别在于：使用 CygWin 可以在 windows 下调用 unix-like 的 API （如fork、spawn、signals、select、sockets 等）. 但是如果调用了 unix 特有的 API 函数, 在 windows 环境下不能正常运行, 如果想在 windows 下正常运行的，就必须依赖 cygwin1.dll , 速度上会有些影响.</p><p>而用 MinGW 编译出来的程序, 如果源代码里面调用了 unix 环境的 API , 则 MinGW 会把这些对 UNIX 的 API 调用翻译成 win32 下等价的形式. 同时这个程序是不能在 windows 下运行的.</p><p>如果你是想在 windows 环境下开发 linux 运行程序, 那么 CygWin 是你的不二之选. 而如果你想开发的是 windows 运行程序, 并且追求速度, 那么二者相比而言, MinGW 是更好的选择.</p><h3 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h3><p>全称 Windows Subsystem for Linux</p><p>如今可在 windows 10 应用商店直接下载安装多个版本的 linux .</p><h4 id="初次安装配置"><a href="#初次安装配置" class="headerlink" title="初次安装配置"></a>初次安装配置</h4><p>1、设置 -&gt; 开发者选项 -&gt; 开发人员模式</p><p>2、控制面板 -&gt; 程序 -&gt; 启用或关闭Windows功能  -&gt; 适用于Linux的Windows子系统</p><p>3、Microsoft Store 下载安装任意版本Linux</p><p>4、PowerShell（管理员）（Win + X） -&gt;  <code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code> -&gt; 重启</p><h4 id="使用-wslconfig-命令进行管理"><a href="#使用-wslconfig-命令进行管理" class="headerlink" title="使用 wslconfig 命令进行管理"></a>使用 wslconfig 命令进行管理</h4><ol><li>设置默认运行的 linux 系统</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /setdefault &lt;DistributionName&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>卸载 linux 系统</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /unregister &lt;DistributionName&gt;</span><br></pre></td></tr></table></figure><p>当系统出现问题，我们可以卸载后重新安装。如：wslconfig /unregeister ubuntu</p><ol start="3"><li>查看已安装的 linux 系统</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /list</span><br></pre></td></tr></table></figure><h4 id="文件系统互相访问"><a href="#文件系统互相访问" class="headerlink" title="文件系统互相访问"></a>文件系统互相访问</h4><ol><li>WSL中访问本地文件</li></ol><p>在“/mnt”目录下有“c”、“d”、“e”等文件夹, 分别表示本地的 C 盘、D 盘、E 盘.</p><ol start="2"><li>本地访问 WSL 的根目录</li></ol><p><code>C:\Users\XXXX\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs</code></p><p>不过不建议在外部直接对其文件进行编辑、新建等操作，因为会出现一些问题。</p><h2 id="安装图形界面"><a href="#安装图形界面" class="headerlink" title="安装图形界面"></a>安装图形界面</h2><ul><li><a href="http://csuncle.com/2017/08/08/Windows-linux%E5%AD%90%E7%B3%BB%E7%BB%9F-%E5%85%A5%E9%97%A8%E5%88%B0GUI/" target="_blank" rel="noopener">Windows linux子系统–入门到GUI</a></li><li><a href="https://blog.csdn.net/novasliver/article/details/83190269" target="_blank" rel="noopener">Win10Linux子系统（WSL）图形界面的安装</a></li></ul><h2 id="Clion-与-WSL"><a href="#Clion-与-WSL" class="headerlink" title="Clion 与 WSL"></a>Clion 与 WSL</h2><p>利用 xServer 与 xLaunch 安装 WSL 的图形界面实际上是在本地利用 ssh 与子系统进行通信, 缺点是反应太慢．于是从常用工具同样是宇宙最强 IDE inteliJ 的开发商开发的 C/C++ IDE Clion 出发考虑其他方案．</p><ul><li><a href="http://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-clion.html" target="_blank" rel="noopener">JetBrains官方指导：Working with WSL Environment</a></li></ul><p>于是乎 Clion 采用的是子系统中的编译工具链, 完全无需考虑兼容性问题．</p><h3 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h3><p>windows 的终端界面和字体实在太丑, 可下载 cmder 工具．由于 WSL 已提供 bash, 于是下载 mini 版即可．</p><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><ul><li><p><a href="https://www.cnblogs.com/xiaoliangge/p/9134585.html" target="_blank" rel="noopener">在Linux的Windows子系统上(WSL)使用Docker（Ubuntu）</a></p></li><li><p><a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北（简体中文版）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;心路历程&quot;&gt;&lt;a href=&quot;#心路历程&quot; class=&quot;headerlink&quot; title=&quot;心路历程&quot;&gt;&lt;/a&gt;心路历程&lt;/h2&gt;&lt;p&gt;初学 C/C++, 在windows上使用 codeblocks 写写算法甚是不错,  visual studio 宇宙最强
      
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="WSL" scheme="https://antfaiz5z.github.io/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>Deepin 下笔记本外接显示器问题</title>
    <link href="https://antfaiz5z.github.io/2018/11/05/xrandr/"/>
    <id>https://antfaiz5z.github.io/2018/11/05/xrandr/</id>
    <published>2018-11-05T12:04:29.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>最近用小米游戏本的HDMI口外接显示器时发现，只有启动时有Deepin logo一闪而过，之后无信号输出。</p><p>解决办法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ xrandr --listproviders <span class="comment"># 如果有多个provider，那么可能是不同显示口在不同显卡上</span></span><br><span class="line">$ xrandr --setprovideroutputsource 0 1 <span class="comment"># 或</span></span><br><span class="line">$ xrandr --setprovideroutputsource 1 0 <span class="comment"># 做下链接，就可以看到所有硬件接口</span></span><br><span class="line">$ xrandr --output xxx --auto <span class="comment"># 设置输出,xxx形如VGA-1、HDMI-1-1等</span></span><br></pre></td></tr></table></figure><p>问题是重启失效，于是设置开机自启脚本：</p><p>将上设置命令保存到新建文件<code>10custom_init_xrandr</code>，保存至<code>/etc/X11/Xsession.d/</code>目录中。</p><p><code>xrandr --output</code>指令示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ xrandr --output VGA --same-as LVDS --auto</span><br><span class="line"><span class="comment"># 打开外接显示器(--auto:最高分辨率)，与笔记本液晶屏幕显示同样内容（克隆）</span></span><br><span class="line">$ xrandr --output VGA --same-as LVDS --mode 1280x1024</span><br><span class="line"><span class="comment"># 打开外接显示器(分辨率为1280x1024)，与笔记本液晶屏幕显示同样内容（克隆）</span></span><br><span class="line">$ xrandr --output VGA --right-of LVDS --auto</span><br><span class="line"><span class="comment"># 打开外接显示器(--auto:最高分辨率)，设置为右侧扩展屏幕</span></span><br><span class="line">$ xrandr --output VGA --off</span><br><span class="line"><span class="comment"># 关闭外接显示器</span></span><br><span class="line">$ xrandr --output VGA --auto --output LVDS --off</span><br><span class="line"><span class="comment"># 打开外接显示器，同时关闭笔记本液晶屏幕（只用外接显示器工作）</span></span><br><span class="line">xrandr --output VGA --off --output LVDS --auto</span><br><span class="line"><span class="comment"># 关闭外接显示器，同时打开笔记本液晶屏幕 （只用笔记本液晶屏）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近用小米游戏本的HDMI口外接显示器时发现，只有启动时有Deepin logo一闪而过，之后无信号输出。&lt;/p&gt;
&lt;p&gt;解决办法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="deepin" scheme="https://antfaiz5z.github.io/tags/deepin/"/>
    
      <category term="xrandr" scheme="https://antfaiz5z.github.io/tags/xrandr/"/>
    
  </entry>
  
  <entry>
    <title>设计模式原则及分类</title>
    <link href="https://antfaiz5z.github.io/2018/11/05/design-pattern/"/>
    <id>https://antfaiz5z.github.io/2018/11/05/design-pattern/</id>
    <published>2018-11-05T02:39:55.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<ol><li>设计模式的六大原则</li></ol><ul><li>单一职责原则（SRP，Single Responsibility Principle）</li><li>里氏替换原则（LSP，Liskov Substitution Principle）</li><li>依赖倒置原则（DIP，Dependence Inversion Principle）</li><li>接口隔离原则（ISP，Interface Segregation Principle）</li><li>迪米特法则（LoD，Law of Demeter）</li><li>开放封闭原则（OCP，Open Close Principle）</li></ul><ol start="2"><li>设计模式分类</li></ol><table><thead><tr><th>范围</th><th>创建型</th><th>结构型</th><th>行为型</th></tr></thead><tbody><tr><td>类</td><td>Factory Method（工厂方法）</td><td>Adapter(类) （适配器）</td><td>Interpreter（解释器）<br>Template Method（模版方法）</td></tr><tr><td>对象</td><td>Abstract Factory（抽象工厂）<br>Builder（建造者）<br>Prototype（原型）<br>Singleton（单例）</td><td>Adapter(对象)（适配器）<br>Bridge（桥接）<br>Composite（组合）<br>Decorator（装饰者）<br>Façade（外观）<br>Flyweight（享元）<br>Proxy（代理）</td><td>Chain of Responsibility（职责链）<br>Command（命令）<br>Iterator（迭代器）<br>Mediator（中介者）<br>Memento（备忘录）<br>Observer（观察者）<br>State（状体）<br>Strategy（策略）<br>Visitor（访问者）</td></tr></tbody></table><ol start="3"><li>设计模式分类细分</li></ol><table><thead><tr><th>范围</th><th>创建型</th><th>结构型</th><th>行为型</th></tr></thead><tbody><tr><td>对象创建</td><td>Singleton（单例）<br>Prototype（原型）<br>Factory Method（工厂方法）<br>Abstract Factory（抽象工厂）<br>Builder（建造者）</td><td></td><td></td></tr><tr><td>接口适配</td><td></td><td>Adapter（适配器）<br>Bridge（桥接）<br>Façade（外观）</td><td></td></tr><tr><td>对象去耦</td><td></td><td></td><td>Mediator（中介者）<br>Observer（观察者）</td></tr><tr><td>抽象集合</td><td></td><td>Composite（组合）</td><td>Iterator（迭代器）</td></tr><tr><td>行为扩展</td><td></td><td>Decorator（装饰）</td><td>Visitor（访问者）<br>Chain of Responsibility（职责链）</td></tr><tr><td>算法封装</td><td></td><td></td><td>Template Method（模板方法）<br>Strategy（策略）<br>Command（命令）</td></tr><tr><td>性能与对象访问</td><td></td><td>Flyweight（享元）<br>Proxy（代理）</td><td></td></tr><tr><td>对象状态</td><td></td><td></td><td>Memento（备忘录）<br>State（状态）</td></tr><tr><td>其它</td><td></td><td></td><td>Interpreter（解释器）  </td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;设计模式的六大原则&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则（SRP，Single Responsibility Principle）&lt;/li&gt;
&lt;li&gt;里氏替换原则（LSP，Liskov Substitution Principle）&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="design pattern" scheme="https://antfaiz5z.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>IO Multiplexing</title>
    <link href="https://antfaiz5z.github.io/2018/10/25/networking-IO/"/>
    <id>https://antfaiz5z.github.io/2018/10/25/networking-IO/</id>
    <published>2018-10-25T03:36:40.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><ul><li><p>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。</p></li><li><p>异步 I/O：不会阻塞。</p></li></ul><p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。</p><p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p><p><img src="/images/io_models.png" alt="五大 I/O 模型比较"></p><h2 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h2><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p><p>select 会修改描述符，而 poll 不会；<br>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 的描述符类型使用链表实现，没有描述符数量的限制；<br>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。<br>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</p><h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><p>select 和 poll 速度都比较慢。</p><p>select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p><p>select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。</p><p>epoll是select/poll的增强版本，其实现和使用方式与select/poll有很多不同，epoll通过一组函数来完成有关任务，而不是一个函数。</p><p>epoll之所以高效，是因为epoll将用户关心的文件描述符放到内核里的一个事件表中，而不是像select/poll每次调用都需要重复传入文件描述符集或事件集。比如当一个事件发生（比如说读事件），epoll无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入就绪队列的描述符集合就行了。</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><ol><li>select 应用场景</li></ol><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p><p>select 可移植性更好，几乎被所有主流平台所支持。</p><ol start="2"><li>poll 应用场景</li></ol><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p><ol start="3"><li>epoll 应用场景</li></ol><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p><p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p><p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p><p>epoll 仅适用于 Linux OS。</p><p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。LT是select/poll使用的触发方式，比较低效；而ET是epoll的高速工作方式。</p><ol><li>LT 模式</li></ol><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p><ol start="2"><li>ET 模式</li></ol><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p><p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><p>通俗理解（是挺俗的）就是，比如说有一堆女孩，有的很漂亮，有的很凤姐。现在你想找漂亮的女孩聊天，LT就是你需要把这一堆女孩全都看一遍，才可以找到其中的漂亮的（就绪事件）；而ET是你的小弟（内核）将N个漂亮的女孩编号告诉你，你直接去看就好，所以epoll很高效。另外，采用非阻塞方式，小明还需要每隔十分钟回来看一下（select）；如果小明有小弟（内核）帮他守在大门口，女神回来了，小弟会主动打电话，告诉小明女神回来了，快来处理吧！这就是epoll。</p><h2 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h2><ol><li>单线程服务器的常用编程模型：Reactor模式和Proactor模式</li></ol><p>Reactor模式，即“non-blocking IO + IO multiplexing”，程序的基本结构是一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑。其中 IO multiplexing 指的是IO线程的复用，不是IO的复用，具体的话是用select(2)和poll(2)，epoll(4)来监听感兴趣的fd。但是这个编程模型也有一个本质的缺点，它要求回调函数必须是非阻塞的。</p><ol start="2"><li>多线程服务器的常用编程模型：non-blocking IO+ one loop per thread模式</li></ol><p>one loop per thread：每个IO线程有一个event loop（或者叫Reactor）用作IO multiplexing，配合non-blocking IO和定时器用于处理读写和定时事件。</p><p>thread pool用作计算，可以使用生产者消费者队列。</p><p>也就是可以有多个IO线程或单个IO线程，每个IO线程最多有一个event loop，使用线程池作为计算线程，每个计算线程使用blocking queue缓存代办任务。</p><p>在non-blocking网络编程中应用层实现并使用buffer是必需的，buffer使IO线程只阻塞于IO multiplexing函数上，如select/poll/epoll_wait，而不阻塞read()或者write()</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li><p>RAII(资源获取即初始化)，这是C++中用来管理资源的一种方式，即通过栈空间上执行对象的构造和析构实现对资源的获取和释放。书中例子也用到了这种方法来实现互斥锁的加锁解锁，条件变量的使用。</p></li><li><p>善用shared_ptr实现线程安全的对象释放，但是要注意再多个线程读写同一个shared_ptr对象时，需要加锁。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IO模型&quot;&gt;&lt;a href=&quot;#IO模型&quot; class=&quot;headerlink&quot; title=&quot;IO模型&quot;&gt;&lt;/a&gt;IO模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="multi-thread" scheme="https://antfaiz5z.github.io/tags/multi-thread/"/>
    
      <category term="networking" scheme="https://antfaiz5z.github.io/tags/networking/"/>
    
      <category term="io" scheme="https://antfaiz5z.github.io/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>C++ 11 多线程编程</title>
    <link href="https://antfaiz5z.github.io/2018/09/19/multithreads/"/>
    <id>https://antfaiz5z.github.io/2018/09/19/multithreads/</id>
    <published>2018-09-19T00:47:18.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 新标准中引入了五个头文件来支持多线程编程，它们分别是 <code>&lt;atomic&gt;</code>, <code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;condition_variable&gt;</code> 和 <code>&lt;future&gt;</code>。</p><a id="more"></a><ul><li><p><code>&lt;thread&gt;</code>：该头文件主要声明了 std::thread 类，另外 <code>std::this_thread</code> 命名空间也在该头文件中。</p></li><li><p><code>&lt;mutex&gt;</code>：该头文件主要声明了与互斥量(Mutex)相关的类，包括 <code>std::mutex_*</code> 一系列类，<code>std::lock_guard</code>, <code>std::unique_lock</code>, 以及其他的类型和函数。</p></li><li><p><code>&lt;condition_variable&gt;</code>：该头文件主要声明了与条件变量相关的类，包括 <code>std::condition_variable</code> 和 <code>std::condition_variable_any</code>。</p></li><li><p><code>&lt;future&gt;</code>：该头文件主要声明了 <code>std::promise</code>, <code>std::package_task</code> 两个 Provider 类，以及 <code>std::future</code> 和 <code>std::shared_future</code> 两个 Future 类，另外还有一些与之相关的类型和函数，<code>std::async()</code> 函数就声明在此头文件中。</p><ul><li><p><code>&lt;future&gt;</code> 头文件中包含了以下几个类和函数：</p><ul><li><p>Providers 类：<code>std::promise</code>, <code>std::package_task</code></p></li><li><p>Futures 类：<code>std::future</code>, <code>std::shared_future</code></p></li><li><p>Providers 函数：<code>std::async()</code></p></li><li><p>其他类型：<code>std::future_error</code>, <code>std::future_errc</code>, <code>std::future_status</code>, <code>std::launch</code></p></li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化时该 std::future 对象处于为 invalid 状态.</span></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; foo, bar;</span><br><span class="line"><span class="comment">// move 赋值, foo 变为 valid.</span></span><br><span class="line">foo = <span class="built_in">std</span>::async(do_get_value);</span><br><span class="line"><span class="comment">// move 赋值, bar 变为 valid, 而 move 赋值以后 foo 变为 invalid.</span></span><br><span class="line">bar = <span class="built_in">std</span>::move(foo);</span><br></pre></td></tr></table></figure><ul><li><code>&lt;atomic&gt;</code>：该头文主要声明了两个类, <code>std::atomic</code> 和 <code>std::atomic_flag</code>，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++11 新标准中引入了五个头文件来支持多线程编程，它们分别是 &lt;code&gt;&amp;lt;atomic&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;thread&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;mutex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;condition_variable&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;future&amp;gt;&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="multi-thread" scheme="https://antfaiz5z.github.io/tags/multi-thread/"/>
    
  </entry>
  
  <entry>
    <title>新装系统环境配置流程</title>
    <link href="https://antfaiz5z.github.io/2018/09/05/new-machine-init/"/>
    <id>https://antfaiz5z.github.io/2018/09/05/new-machine-init/</id>
    <published>2018-09-05T11:27:04.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>Personal.</p><a id="more"></a><h3 id="git-github"><a href="#git-github" class="headerlink" title="git/github"></a>git/github</h3><ol><li><p>查看电脑上是否已经存在SSH密钥：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure><p> 若显示“No such file or directoy”,则需要创建新的ssh key</p></li><li><p>创建新的ssh key:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"&lt;youremail&gt;"</span></span><br></pre></td></tr></table></figure><p> 执行这条命令会提示文件保存路径，可以直接Enter，默认保存在当前用户目录。然后提示输入passphrase，可以直接Enter，即无密码.</p></li><li><p>复制ssh key到Github</p><p> 用编辑器打开.ssh目录下的id_rsa.pub文件，复制里面的全部内容，add ssh key</p></li><li><p>测试ssh连接Github：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p> 期间会提示输入密码，若无则无</p></li><li><p>设置自己的git信息：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"username"</span> </span><br><span class="line">（此处username可修改也不是用于登录github的登录名）</span><br><span class="line">$ git config --global user.email <span class="string">"&lt;youremail&gt;"</span></span><br></pre></td></tr></table></figure><p> 设置自己的git信息即完成安装和设置，可以输入</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><p> 查看自己的git信息</p></li></ol><h3 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure><p>设置系统代理-&gt;手动:</p><p>Socks代理: 127.0.0.1</p><p>本地端口: 1080</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y zsh</span><br></pre></td></tr></table></figure><p>OhMyZsh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>reboot terminal</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.zshrc</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">"agnoster"</span></span><br></pre></td></tr></table></figure><p>为了展示 Agnoster 主题提示符里的三角形，需要 Powerline 字体库的支持。</p><p>使用 Git Clone下来字体库仓库，进入仓库根目录，执行 install.sh 安装。</p><p>字体库链接：<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a> 或直接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install fonts-powerline</span><br></pre></td></tr></table></figure><h3 id="nvm-node-npm"><a href="#nvm-node-npm" class="headerlink" title="nvm/node/npm"></a>nvm/node/npm</h3><p>访问 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a> 查看nvm最新release版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</span><br></pre></td></tr></table></figure><p>访问 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a> 查看node最新LTS版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install [version]</span><br></pre></td></tr></table></figure><p>npm换源：</p><ol><li><p>临时使用</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm --registry https://registry.npm.taobao.org install express</span><br></pre></td></tr></table></figure></li><li><p>持久使用</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p> 配置后可通过下面方式来验证是否成功 </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get registry</span><br></pre></td></tr></table></figure></li><li><p>通过cnpm使用</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p> npm命令都可用cnpm代替。</p></li></ol><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install cmake gcc clang gdb build-essential</span><br></pre></td></tr></table></figure><h3 id="anacode"><a href="#anacode" class="headerlink" title="anacode"></a>anacode</h3><p><a href="https://www.anaconda.com/download/#linux" target="_blank" rel="noopener">https://www.anaconda.com/download/#linux</a></p><h3 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h3><p><a href="https://antfaiz5z.github.io/2017/07/12/hexo/">https://antfaiz5z.github.io/2017/07/12/hexo/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Personal.&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>常用 Git 命令</title>
    <link href="https://antfaiz5z.github.io/2018/08/17/git/"/>
    <id>https://antfaiz5z.github.io/2018/08/17/git/</id>
    <published>2018-08-17T02:32:01.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;path&gt;/&lt;file&gt;</span><br><span class="line">$ git commit -m <span class="string">"&lt;commit_msg&gt;"</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git remote [-v | --verbose]</span><br><span class="line">$ git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;</span><br><span class="line">$ git remote rename &lt;old&gt; &lt;new&gt;</span><br><span class="line">$ git remote remove &lt;name&gt;</span><br><span class="line">$ git remote <span class="built_in">set</span>-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)</span><br><span class="line">$ git remote <span class="built_in">set</span>-branches [--add] &lt;name&gt; &lt;branch&gt;…​</span><br><span class="line">$ git remote get-url [--push] [--all] &lt;name&gt;</span><br><span class="line">$ git remote <span class="built_in">set</span>-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]</span><br><span class="line">$ git remote <span class="built_in">set</span>-url --add [--push] &lt;name&gt; &lt;newurl&gt;</span><br><span class="line">$ git remote <span class="built_in">set</span>-url --delete [--push] &lt;name&gt; &lt;url&gt;</span><br><span class="line">$ git remote [-v | --verbose] show [-n] &lt;name&gt;…​</span><br><span class="line">$ git remote prune [-n | --dry-run] &lt;name&gt;…​</span><br><span class="line">$ git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br></pre></td></tr></table></figure><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># 查看当前分支修改状态</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># log命令可以显示所有提交过的版本信息</span></span><br><span class="line">$ git <span class="built_in">log</span> - -pretty=oneline</span><br><span class="line"><span class="comment"># 将只会显示提交的commit id号和对应的注释。</span></span><br><span class="line">$ git reflog</span><br><span class="line"><span class="comment"># 如果在回退以后又想再次回到之前的版本，git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录</span></span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#本地分支暂存区回退</span></span><br><span class="line">$ git rm [-r] &lt;path&gt;/&lt;file&gt;</span><br><span class="line"><span class="comment"># 对应于git add，使文件不加入版本管理</span></span><br><span class="line">$ git checkout -- &lt;file&gt;</span><br><span class="line"><span class="comment"># 让&lt;file&gt;这个文件回到最近一次git commit或git add时的状态</span></span><br><span class="line"><span class="comment"># 一种是&lt;file&gt;自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</span></span><br><span class="line"><span class="comment"># 一种是&lt;file&gt;已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#本地分支提交回退</span></span><br><span class="line">$ git reset HEAD~</span><br><span class="line">$ git reset HEAD &lt;file&gt;</span><br><span class="line"><span class="comment"># git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本.</span></span><br><span class="line">$ git reset [--hard] &lt;commit_id&gt;</span><br><span class="line"><span class="comment"># hard选项，表示彻底将工作区、暂存区和版本库记录恢复到指定的版本库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#远程分支版本回退</span></span><br><span class="line"><span class="comment"># 远程版本回退可在本地回退后再强制推送至远程分支</span></span><br><span class="line">$ git push -f origin &lt;branch&gt;</span><br><span class="line"><span class="comment"># 本地分支回滚后，版本将落后远程分支，必须使用强制推送覆盖远程分支，否则无法推送到远程分支</span></span><br></pre></td></tr></table></figure><p><img src="/images/reset_and_checkout.png" alt="reset and checkout"></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line"><span class="comment"># 查看当前分支情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#本地新建分支</span></span><br><span class="line">$ git branch &lt;new_branch&gt;</span><br><span class="line"><span class="comment"># 以当前分支为源创建&lt;new branch&gt;分支</span></span><br><span class="line">$ git checkout &lt;new_branch&gt;</span><br><span class="line"><span class="comment"># 进入&lt;new branch&gt;分支</span></span><br><span class="line"><span class="comment">#合体</span></span><br><span class="line">$ git checkout -b &lt;new_branch&gt;</span><br><span class="line"><span class="comment"># 以当前分支为源创建新分支&lt;new branch&gt;，并进入&lt;new branch&gt;分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#远程分支创建</span></span><br><span class="line"><span class="comment"># 本地分支创建后推送至远程仓库即可</span></span><br><span class="line">$ git push origin &lt;new_branch&gt;:master</span><br><span class="line"><span class="comment"># 提交本地&lt;new_branch&gt;分支作为远程的master分支</span></span><br><span class="line">$ git push origin &lt;new_branch&gt;:&lt;new_branch&gt;</span><br><span class="line"><span class="comment"># 提交本地&lt;new_branch&gt;分支作为远程的&lt;new_branch&gt;分支</span></span><br><span class="line">$ git push origin :&lt;new_branch&gt;</span><br><span class="line"><span class="comment"># 刚提交到远程的&lt;new_branch&gt;分支将被删除，但是本地还会保存</span></span><br></pre></td></tr></table></figure><h2 id="子仓库"><a href="#子仓库" class="headerlink" title="子仓库"></a>子仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在仓库当前路径添加子模块</span></span><br><span class="line">git submodule add &lt;git_url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#克隆包含子模块的仓库</span></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="comment">#克隆项目，子模块目录默认被克隆，但是是空的</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;git_url&gt;</span><br><span class="line"><span class="comment">#初始化子模块：初始化本地配置文件</span></span><br><span class="line">$ git submodule init</span><br><span class="line"><span class="comment">#该项目中抓取所有数据并检出父项目中列出的合适的提交</span></span><br><span class="line">$ git submodule update</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="comment">#用--recursive命令，跟方法一样达到效果</span></span><br><span class="line">$ git <span class="built_in">clone</span> --recursive &lt;git_url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新子模块</span></span><br><span class="line">$ git submodule update --remote --merge</span><br><span class="line"><span class="comment"># 或者进入子模块目录如普通仓库一样操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除子模块</span></span><br><span class="line">$ git rm --cached [name]</span><br><span class="line">$ rm -rf [name]</span><br><span class="line">$ rm .gitmodules</span><br><span class="line">$ vim .git/config</span><br><span class="line"><span class="comment"># 删除子模块相关内容，例如下面的内容</span></span><br><span class="line">[submodule <span class="string">"submodule"</span>]</span><br><span class="line">        url = git@gitee.com:xxx.com/submodule.git</span><br><span class="line">        active = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#主仓库推送</span></span><br><span class="line">$ git push --recurse-submodules=check</span><br><span class="line"><span class="comment"># 主仓库推送时，确保子模块的修改已经推送，下面命令会检查子模块修改的内容是否推送，如果没有，主仓库推送也会失败</span></span><br><span class="line">$ git push --recurse-submodules=on-demand</span><br><span class="line"><span class="comment"># 检查到子模块没有推送，会自动推送子模块，然后再推送主模块（如果子模块推送失败，那么主模块也推送失败）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常规&quot;&gt;&lt;a href=&quot;#常规&quot; class=&quot;headerlink&quot; title=&quot;常规&quot;&gt;&lt;/a&gt;常规&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git add &amp;lt;path&amp;gt;/&amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -m &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;commit_msg&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Git" scheme="https://antfaiz5z.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://antfaiz5z.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>mbedTLS (PolarSSL) 的几点问题</title>
    <link href="https://antfaiz5z.github.io/2018/07/20/mbedtls/"/>
    <id>https://antfaiz5z.github.io/2018/07/20/mbedtls/</id>
    <published>2018-07-20T07:54:55.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<ol><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_conf_authmode( &amp;conf, MBEDTLS_SSL_VERIFY_REQUIRED );</span><br></pre></td></tr></table></figure></li></ol><p>第二个参数不建议用MBEDTLS_SSL_VERIFY_OPTIONAL，不然验证通不过的时候也能用，意义不大</p><ol start="2"><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_set_hostname( &amp;ssl, <span class="string">"MQTT"</span> )</span><br></pre></td></tr></table></figure></li></ol><p>第二个参数一定要和生成证书时所指定的CN字段一样</p><ol start="3"><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_conf_max_version(&amp;conf, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_1);</span><br><span class="line">mbedtls_ssl_conf_min_version(&amp;conf, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_1);</span><br></pre></td></tr></table></figure></li></ol><p>这两条语句有可能会用到</p><ol start="4"><li><p>实现收发数据的接口时一定要注意采用阻塞方式还是超时方式，不然可能会死锁</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="mbedTLS" scheme="https://antfaiz5z.github.io/tags/mbedTLS/"/>
    
  </entry>
  
  <entry>
    <title>HTTPs相关</title>
    <link href="https://antfaiz5z.github.io/2018/07/20/certificates/"/>
    <id>https://antfaiz5z.github.io/2018/07/20/certificates/</id>
    <published>2018-07-20T03:51:21.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CA Certificate Authority 认证授权机构</span><br><span class="line">cert Certificate 证书</span><br><span class="line">csr Certificate Signing Request 证书签名申请</span><br><span class="line">pk public key</span><br><span class="line">psk pre-shared key</span><br><span class="line">encryption 加密</span><br><span class="line">decryption 解密</span><br><span class="line">symmetric encryption 对称加密</span><br><span class="line">asymmetric encryption 非对称加密</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h1><p>CA证书顾名思义就是由CA机构发布的数字证书。</p><p>包含有：</p><ul><li>颁发者</li><li>使用者</li><li>版本</li><li>签名算法</li><li>签名哈希算法</li><li>使用者</li><li>公钥</li><li>指纹</li><li>指纹算法</li><li>……</li></ul><p>证书的认证是安装证书链执行的，证书链的意思是有一个证书机构A，A生成证书B，B也可以生成证书C，A证书或者certification authority of wosign证书在整个证书链上就被称为根证书。证书验证的机制是只要根证书是受信任的，那么它的子证书都是可信的。如果一个证书的根证书是不可信的，那么这个证书肯定也是不可信任的。</p><p>中国的安全认证体系分为金融CA和非金融CA。在金融CA方面，根证书由中国人民银行管理，在非金融CA方面，由中国电信负责。中国CA又可分为行业性CA和区域性CA,行业性CA中影响最大是中国金融认证中心和中国电信认证中国；区域性CA主要是以政府为背景，以企业机制运行，其中广东CA中心和上海CA中影响最大。</p><h1 id="SSL与TLS"><a href="#SSL与TLS" class="headerlink" title="SSL与TLS"></a>SSL与TLS</h1><p>https就是http加SSL，SSL（security sockets layer，安全套接层）是为网络通信提供安全及数据完整性的一种安全协议，SSL协议位于TCP/IP协议与各种应用层协议（包括http）之间，SSL3.0版本以后又被称为TLS (transport layer security，传输层安全 )。</p><h1 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h1><ol><li><p>对称加密就是发送双发使用相同的密钥对消息进行加解密。</p><p> 常见的对称加密为DES、3DES、AES等。</p></li><li><p>非对称加密是发送双方各自拥有一对公钥私钥，其中公钥是公开的，私钥是保密的。当发送方向接收方发送消息时，发送方利用接收方的公钥对消息进行加密，接收方收到消息后，利用自己的私钥解密就能得到消息的明文。</p><p> 其中非对称加密方法有RSA、Elgamal、ECC等。</p></li></ol><p>解决第三方冒充的方法是将发送内容进行二次加密，并且通讯双方有可靠的途径知道对方的公钥:</p><ul><li>A发送给B时候，先用A的私钥加密，然后再用B的公钥加密。</li><li>B收到后，先用B的私钥解密，再用A的公钥解密，得到明文。</li></ul><p>获取公钥的可靠途径不一样，就可以有不容的实现方式：</p><ol><li><p>通信双方事先有对方的公钥，这种方法比较麻烦，要面对面交换。显然不适合大规模应用，用在夫妻之间到是比较好的！</p></li><li><p>第三方的数字签名，这个就比较好了，大家都把公钥放在第三方CA那里，通信发起方问CA要双方的公钥，并传给对方。</p></li></ol><p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证安全性，之后使用对称密钥加密进行通信来保证效率。（下图中的 Session Key 就是对称密钥）</p><p><img src="/images/How-HTTPS-Works.png" alt="How HTTPs works"></p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p>通信开始时，客户端需要使用服务器的公开密钥将自己的私有密钥传输给服务器，之后再进行对称密钥加密。</p><p><img src="/images/ca.png" alt="Sign and verify"></p><h1 id="数字签名与签名认证-digital-signature"><a href="#数字签名与签名认证-digital-signature" class="headerlink" title="数字签名与签名认证 digital signature"></a>数字签名与签名认证 digital signature</h1><p>发方将原文用哈希算法求得数字摘要，用签名私钥对数字摘要加密得数字签名，发方将原文与数字签名一起发送给接受方。<br>数字签名的操作过程需要有发方的签名数字证书的私钥及其验证公钥。具体过程如下：首先是生成被签名的电子文件（《电子签名法》中称数据电文），然后对电子文件用哈希算法做数字摘要，再对数字摘要用签名私钥做非对称加密，即做数字签名；之后是将以上的签名和电子文件原文以及签名证书的公钥加在一起进行封装，形成签名结果发送给收方，待收方验证。</p><p>接收方收到数字签名的结果，其中包括数字签名、电子原文和发方公钥，即待验证的数据。接收方进行签名验证。验证过程是：接收方首先用发方公钥解密数字签名，导出数字摘要，并对电子文件原文作同样哈希算法得一个新的数字摘要，将两个摘要的哈希值进行结果比较，结果相同签名得到验证，否则签名无效。这就作到了《电子签名法》中所要求的对签名不能改动，对签署的内容和形式也不能改动的要求。</p><h2 id="摘要-digest"><a href="#摘要-digest" class="headerlink" title="摘要 digest"></a>摘要 digest</h2><p>OpenSSL支持的摘要算法</p><ul><li>md5</li><li>md4</li><li>mdc2</li><li>sha1</li><li>sha</li><li>sha224</li><li>ripemd160</li><li>dss1</li><li>whirlpool</li></ul><h2 id="签名-signature"><a href="#签名-signature" class="headerlink" title="签名 signature"></a>签名 signature</h2><p>签名的一般过程：先对数据进行摘要计算，然后对摘要值用私钥进行签名。</p><h3 id="RSA私钥签名验签"><a href="#RSA私钥签名验签" class="headerlink" title="RSA私钥签名验签"></a>RSA私钥签名验签</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成RSA密钥对</span></span><br><span class="line">$ openssl genrsa -out rsa_private.key</span><br><span class="line"></span><br><span class="line"><span class="comment">#由公钥导出私钥</span></span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> rsa_private.key -pubout -out rsa_public.key</span><br><span class="line"></span><br><span class="line"><span class="comment">#用RSA私钥对SHA1计算得到的摘要值`签名`</span></span><br><span class="line">$ openssl dgst -sign rsa_private.key -sha1 -out sha1_rsa_file.sign file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#用相应的公钥和相同的摘要算法进行`验签`，否则会失败</span></span><br><span class="line">$ openssl dgst -verify rsa_public.key -sha1 -signature sha1_rsa_file.sign file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以使用相同的私钥和相同的摘要算法进行验证</span></span><br><span class="line">$ openssl dgst -prverify rsa_private.key -sha1 -signature sha1_rsa_file.sign file.txt</span><br></pre></td></tr></table></figure><h3 id="DSA密钥签名验签"><a href="#DSA密钥签名验签" class="headerlink" title="DSA密钥签名验签"></a>DSA密钥签名验签</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成DSA参数</span></span><br><span class="line">$ openssl dsaparam -out dsa.param 1024</span><br><span class="line"></span><br><span class="line"><span class="comment">#由DSA参数产生DSA私钥</span></span><br><span class="line">$ openssl gendsa -out dsa_private.key dsa.param</span><br><span class="line"></span><br><span class="line"><span class="comment">#由DSA私钥生成DSA公钥</span></span><br><span class="line">$ openssl dsa -<span class="keyword">in</span> dsa_private.key -out dsa_public.key -pubout</span><br><span class="line"></span><br><span class="line"><span class="comment">#用DSA私钥对SHA384计算的摘要值进行签名。</span></span><br><span class="line">$ openssl dgst -sign dsa_private.key -sha384 -out sha384_dsa.sign file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#用相应的公钥和摘要算法进行验签</span></span><br><span class="line">$ openssl dgst -verify dsa_public.key -sha384 -signature sha384_dsa.sign file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#用相同的私钥和摘要算法验签</span></span><br><span class="line">$ openssl dgst -prverify dsa_private.key -sha384 -signature sha384_dsa.sign file.txt</span><br></pre></td></tr></table></figure><blockquote><p>DSA在每次签名时,使用了随机数k,如果对同一消息进行多次签名,签名结果是不同的,所以DSA是一种随机式数字签名。</p></blockquote><h1 id="SSL握手-handshake"><a href="#SSL握手-handshake" class="headerlink" title="SSL握手 handshake"></a>SSL握手 handshake</h1><ul><li>客户端访问服务器,发送ssl版本、客户端支持的加密算法、随机数等消息。</li><li>服务器向客户端发送ssl版本、随机数、加密算法、证书（证书出现了）等消息。</li><li>客户端收到消息后，判断证书是否可信（如何判断可信，看下文介绍），若可信，则继续通信，发送消息包括：向服务器发送一个随机数，从证书中获取服务器端的公钥，对随机数加密；编码改变通知，表示随后信息都将使用双方协定的加密方法和密钥发送；客户端握手结束通知。</li><li>服务器端对数据解密得到随机数，发送消息：编码改变通知，表示随后信息都将使用双方协定的加密方法和密钥发送。</li></ul><p>非对称加密算法对数据加密非常慢，效率低，而对称加密加密效率很高，因此在整个握手过程要生成一个对称加密密钥，然后数据传输中使用对称加密算法对数据加密。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CA Certificate Authority 认证授权机构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cert Certificate 证书&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;csr Certificate Signing Request 证书签名申请&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pk public key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;psk pre-shared key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;encryption 加密&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;decryption 解密&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;symmetric encryption 对称加密&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;asymmetric encryption 非对称加密&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="CA" scheme="https://antfaiz5z.github.io/tags/CA/"/>
    
      <category term="encryption" scheme="https://antfaiz5z.github.io/tags/encryption/"/>
    
  </entry>
  
  <entry>
    <title>Library paho.mqtt.c API</title>
    <link href="https://antfaiz5z.github.io/2018/07/13/paho-mqtt-c/"/>
    <id>https://antfaiz5z.github.io/2018/07/13/paho-mqtt-c/</id>
    <published>2018-07-13T08:35:34.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MQTT客户端分为同步客户端和异步客户端.　一般流程如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个客户端对象；</span><br><span class="line">  2.设置连接MQTT服务器的选项；</span><br><span class="line">  3.如果多线程（异步模式）操作被使用则设置回调函数；</span><br><span class="line">  4.订阅客户端需要接收的任意话题；</span><br><span class="line">  5.重复以下操作直到结束：</span><br><span class="line">    a.发布客户端需要的任意信息；</span><br><span class="line">    b.处理所有接收到的信息；</span><br><span class="line">  6.断开客户端连接；</span><br><span class="line">  7.释放客户端使用的所有内存。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="重要变量"><a href="#重要变量" class="headerlink" title="重要变量"></a>重要变量</h1><h2 id="typedef-void-MQTTClient"><a href="#typedef-void-MQTTClient" class="headerlink" title="typedef void* MQTTClient"></a>typedef void* MQTTClient</h2><blockquote><p>A handle representing an MQTT client. A valid client handle is available following a successful call to MQTTClient_create().</p></blockquote><p>使用MQTTClient_create()创建新连接前需预先定义一个MQTTClient，初始为空指针。</p><h2 id="typedef-int-MQTTClient-deliveryToken-amp-typedef-int-MQTTClient-token"><a href="#typedef-int-MQTTClient-deliveryToken-amp-typedef-int-MQTTClient-token" class="headerlink" title="typedef int MQTTClient_deliveryToken &amp;  typedef int MQTTClient_token"></a>typedef int MQTTClient_deliveryToken &amp; <br> typedef int MQTTClient_token</h2><blockquote><p>A value representing an MQTT message. A delivery token is returned to the client application when a message is published. The token can then be used to check that the message was successfully delivered to its destination.</p></blockquote><p>一般用于异步客户端中，token用于记录当前客户端成功发送message所返回的token，若确认message成功发送则使deliveryToken等于当前token，此时即可安全断开客户端与服务器的连接。</p><h1 id="重要结构体"><a href="#重要结构体" class="headerlink" title="重要结构体"></a>重要结构体</h1><h2 id="MQTTClient-connectOptions"><a href="#MQTTClient-connectOptions" class="headerlink" title="MQTTClient_connectOptions"></a>MQTTClient_connectOptions</h2><blockquote><p>MQTTClient_connectOptions defines several settings that control the way the client connects to an MQTT server.<br>Note: Default values are not defined for members of MQTTClient_connectOptions so it is good practice to specify all settings. If the MQTTClient_connectOptions structure is defined as an automatic variable, all members are set to random values and thus must be set by the client application. If the MQTTClient_connectOptions structure is defined as a static variable, initialization (in compliant compilers) sets all values to 0 (NULL for pointers). A keepAliveInterval setting of 0 prevents correct operation of the client and so you must at least set a value for keepAliveInterval.</p></blockquote><p>客户端连接选项。</p><table><thead><tr><th>类型</th><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>struct_id [4]</td><td>必须为”MQTC”</td></tr><tr><td>int</td><td>struct_version</td><td>0: 无SSL选项和serverURIs;<br>1,2,3,4,5,6略</td></tr><tr><td>int</td><td>keepAliveInterval</td><td>最大通信间隔时间（秒）</td></tr><tr><td>int</td><td>cleansession</td><td>布尔值，是否清除session</td></tr><tr><td>int</td><td>reliable</td><td>布尔值。<br>1:上一条message发送完毕才发送下一条；<br> 0:最多允许10条message同时发送</td></tr><tr><td>MQTTClient_willOptions *</td><td>will</td><td>遗嘱选项</td></tr><tr><td>const char *</td><td>username</td><td>用户名（MQTTv3.1.1提供）</td></tr><tr><td>const char *</td><td>password</td><td>密码（MQTTv3.1.1提供）</td></tr><tr><td>int</td><td>connectTimeout</td><td>连接超时</td></tr><tr><td>int</td><td>retryInterval</td><td>重试间隔</td></tr><tr><td>MQTTClient_SSLOptions *</td><td>ssl</td><td>SSL选项</td></tr><tr><td>int</td><td>serverURIcount</td><td>可选的serverURIs数组入口数量，默认0</td></tr><tr><td>char <em>const </em></td><td>serverURIs</td><td>可选的serverURIs数组，形如：protocol://host:port</td></tr><tr><td>int</td><td>MQTTVersion</td><td>MQTT版本，默认先使用v3.1.1</td></tr><tr><td>struct {<br>const char *   serverURI <br>int MQTTVersion <br> int   sessionPresent<br>}</td><td>returned</td><td>连接返回值</td></tr><tr><td>struct {<br>int   len <br>const void *   data<br>}</td><td>binarypwd</td><td>二进制密码</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQTTClient_connectOptions_initializer &#123; &#123;<span class="meta-string">'M'</span>, <span class="meta-string">'Q'</span>, <span class="meta-string">'T'</span>, <span class="meta-string">'C'</span>&#125;, 6, 60, 1, 1, NULL, NULL, NULL, 30, 20, NULL, 0, NULL, MQTTVERSION_DEFAULT, &#123;NULL, 0, 0&#125;, &#123;0, NULL&#125;, -1, 0&#125;</span></span><br></pre></td></tr></table></figure><h2 id="MQTTClient-willOptions"><a href="#MQTTClient-willOptions" class="headerlink" title="MQTTClient_willOptions"></a>MQTTClient_willOptions</h2><blockquote><p>MQTTClient_willOptions defines the MQTT “Last Will and Testament” (LWT) settings for the client. In the event that a client unexpectedly loses its connection to the server, the server publishes the LWT message to the LWT topic on behalf of the client. This allows other clients (subscribed to the LWT topic) to be made aware that the client has disconnected. To enable the LWT function for a specific client, a valid pointer to an MQTTClient_willOptions structure is passed in the MQTTClient_connectOptions structure used in the MQTTClient_connect() call that connects the client to the server. The pointer to MQTTClient_willOptions can be set to NULL if the LWT function is not required.</p></blockquote><p>客户端遗嘱选项。当客户端意外丢失连接，服务器会替此客户端发送LWT主题的LWT消息，订阅了LWT主题的其他客户端可以此知道此客户端已断开连接。</p><table><thead><tr><th>类型</th><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>struct_id [4]</td><td>必须为”MQTW”</td></tr><tr><td>int</td><td>struct_version</td><td>布尔值。0:无二进制payload选项</td></tr><tr><td>const char *</td><td>topicName</td><td>LWT主题</td></tr><tr><td>const char *</td><td>message</td><td>LWT消息</td></tr><tr><td>int</td><td>retained</td><td>是否保留LWT消息</td></tr><tr><td>int</td><td>qos</td><td>quality of service</td></tr><tr><td>struct {<br>int   len<br>const void *   data<br>}<br></td><td>payload</td><td>二进制LWT payload</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQTTClient_willOptions_initializer &#123; &#123;<span class="meta-string">'M'</span>, <span class="meta-string">'Q'</span>, <span class="meta-string">'T'</span>, <span class="meta-string">'W'</span>&#125;, 1, NULL, NULL, 0, 0, &#123;0, NULL&#125; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="MQTTClient-SSLOptions"><a href="#MQTTClient-SSLOptions" class="headerlink" title="MQTTClient_SSLOptions"></a>MQTTClient_SSLOptions</h2><blockquote><p>MQTTClient_sslProperties defines the settings to establish an SSL/TLS connection using the OpenSSL library. It covers the following scenarios:<br>Server authentication: The client needs the digital certificate of the server. It is included in a store containting trusted material (also known as “trust store”).<br>Mutual authentication: Both client and server are authenticated during the SSL handshake. In addition to the digital certificate of the server in a trust store, the client will need its own digital certificate and the private key used to sign its digital certificate stored in a “key store”.<br>Anonymous connection: Both client and server do not get authenticated and no credentials are needed to establish an SSL connection. Note that this scenario is not fully secure since it is subject to man-in-the-middle attacks.</p></blockquote><p>客户端SSL选项。支持服务器认证（需提供服务器证书）、双向认证（需提供服务器证书及客户端自身私钥生成的证书）、匿名连接。</p><table><thead><tr><th>类型</th><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>struct_id [4]</td><td>必须为”MQTS”</td></tr><tr><td>int</td><td>struct_version</td><td>必须为0</td></tr><tr><td>const char *</td><td>trustStore</td><td>PEM格式服务器证书</td></tr><tr><td>const char *</td><td>keyStore</td><td>PEM格式包括客户端的公共证书链及私钥</td></tr><tr><td>const char *</td><td>privateKey</td><td>PEM格式客户端私钥</td></tr><tr><td>const char *</td><td>privateKeyPassword</td><td>客户端私钥密码，若加密的话</td></tr><tr><td>const char *</td><td>enabledCipherSuites</td><td>密码套件列表</td></tr><tr><td>int</td><td>enableServerCertAuth</td><td>布尔值。是否启用服务器证书认证</td></tr><tr><td>int</td><td>sslVersion</td><td>SSL版本</td></tr><tr><td>int</td><td>verify</td><td>是否执行连接后检查，包括证书是否匹配主机名</td></tr><tr><td>const char *</td><td>CApath</td><td>包含PEM格式的CA证书的文件夹</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQTTClient_SSLOptions_initializer &#123; &#123;<span class="meta-string">'M'</span>, <span class="meta-string">'Q'</span>, <span class="meta-string">'T'</span>, <span class="meta-string">'S'</span>&#125;, 2, NULL, NULL, NULL, NULL, NULL, 1, MQTT_SSL_VERSION_DEFAULT, 0, NULL &#125;</span></span><br></pre></td></tr></table></figure><h2 id="MQTTClient-message"><a href="#MQTTClient-message" class="headerlink" title="MQTTClient_message"></a>MQTTClient_message</h2><blockquote><p>A structure representing the payload and attributes of an MQTT message. The message topic is not part of this structure.</p></blockquote><p>客户端发送的消息（不含消息主题）。</p><table><thead><tr><th>类型</th><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>struct_id [4]</td><td>必须为”MQTM”</td></tr><tr><td>int</td><td>struct_version</td><td>必须为0</td></tr><tr><td>int</td><td>payloadlen</td><td>payload字节数</td></tr><tr><td>void *</td><td>payload</td><td>payload</td></tr><tr><td>int</td><td>qos</td><td>quality of service</td></tr><tr><td>int</td><td>retained</td><td>1:MQTT服务器将会保留消息副本，并传送值此主题的新订阅者，新订阅者将会知晓这是MQTT保留的旧消息;<br>0:MQTT服务器不会保留此消息，订阅者认为此为普通消息</td></tr><tr><td>int</td><td>dup</td><td>布尔值。是否是重复消息</td></tr><tr><td>int</td><td>msgid</td><td>message id</td></tr><tr><td>MQTTProperties</td><td>properties</td><td>MQTT属性</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQTTClient_message_initializer &#123; &#123;<span class="meta-string">'M'</span>, <span class="meta-string">'Q'</span>, <span class="meta-string">'T'</span>, <span class="meta-string">'M'</span>&#125;, 1, 0, NULL, 0, 0, 0, 0, MQTTProperties_initializer &#125;</span></span><br></pre></td></tr></table></figure><h1 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h1><h2 id="MQTTClient-create"><a href="#MQTTClient-create" class="headerlink" title="MQTTClient_create"></a>MQTTClient_create</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_create</span><span class="params">(MQTTClient* handle, <span class="keyword">const</span> <span class="keyword">char</span>* serverURI, <span class="keyword">const</span> <span class="keyword">char</span>* clientId, <span class="keyword">int</span> persistence_type, <span class="keyword">void</span>* persistence_context)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient *</td><td>handle</td><td>预先定义好的空client</td></tr><tr><td>const char *</td><td>serverURI</td><td>服务器地址， 形如： protocol://host:port</td></tr><tr><td>const char *</td><td>clientId</td><td>client id</td></tr><tr><td>int</td><td>persistence_type</td><td>1）MQTTCLIENT_PERSISTENCE_NONE： 在内存中持久化;<br> 2）MQTTCLIENT_PERSISTENCE_DEFAULT: 使用默认持久机制（基于文件系统）;<br>3）MQTTCLIENT_PERSISTENCE_USER： 使用特定应用持久实现，应用应实现MQTTClient_persistence 接口</td></tr><tr><td>void *</td><td>persistence_context</td><td>对应于persistence_type:<br> 1)应为NULL;<br> 2)应为持久目录路径，若为NULL则使用工作目录;<br> 3)有效的指向MQTTClient_persistence的指针</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIETN_SUCCESS</td><td>client创建成功</td></tr><tr><td>[error code]</td><td>错误码</td></tr></tbody></table><blockquote><p>This function creates an MQTT client ready for connection to the specified server and using the specified persistent storage (see MQTTClient_persistence). See also MQTTClient_destroy().</p></blockquote><p>创建一个有效的client。使用参数创建一个client，并将其赋值给之前声明的client</p><h2 id="MQTTClient-setCallbacks"><a href="#MQTTClient-setCallbacks" class="headerlink" title="MQTTClient_setCallbacks"></a>MQTTClient_setCallbacks</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_setCallbacks</span><span class="params">(MQTTClient handle, <span class="keyword">void</span>* context, MQTTClient_connectionLost* cl, MQTTClient_messageArrived* ma, MQTTClient_deliveryComplete* dc)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>void*</td><td>context</td><td>任意特定应用上下文，传递给回调函数用于访问应用上下文</td></tr><tr><td>MQTTClient_connectionLost*</td><td>cl</td><td>MQTTClient_connectionLost() 回调函数</td></tr><tr><td>MQTTClient_messageArrived*</td><td>ma</td><td>MQTTClient_messageArrived() 回调函数</td></tr><tr><td>MQTTClient_deliveryComplete*</td><td>dc</td><td>MQTTClient_deliveryComplete() 回调函数</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>成功设置回调函数</td></tr><tr><td>MQTTCLIENT_FAILURE</td><td>发生错误</td></tr></tbody></table><blockquote><p>This function sets the callback functions for a specific client.If your client application doesn’t use a particular callback, set the　relevant parameter to NULL. Calling MQTTClient_setCallbacks() puts the　client into multi-threaded mode. Any necessary message acknowledgements and　status communications are handled in the background without any intervention　from the client application. See @ref async for more information.</p></blockquote><p>设置回调函数。</p><h2 id="MQTTClient-connect"><a href="#MQTTClient-connect" class="headerlink" title="MQTTClient_connect"></a>MQTTClient_connect</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_connect</span><span class="params">(MQTTClient handle, MQTTClient_connectOptions* options)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>MQTTClient_connectOptions*</td><td>options</td><td>struct，连接选项</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>成功连接服务器</td></tr><tr><td><b>1</b></td><td>Connection refused: Unacceptable protocol version</td></tr><tr><td><b>2</b></td><td>Connection refused: Identifier rejected</td></tr><tr><td><b>3</b></td><td>Connection refused: Server unavailable</td></tr><tr><td><b>4</b></td><td>Connection refused: Bad user name or password</td></tr><tr><td><b>5</b></td><td>Connection refused: Not authorized</td></tr><tr><td><b>6-255</b></td><td>Reserved for future use</td></tr></tbody></table><p>（Error codes greater than 0 are returned by the MQTT protocol）</p><blockquote><p>This function attempts to connect a previously-created client (see MQTTClient_create()) to an MQTT server using the specified options. If you want to enable asynchronous message and status notifications, you must call MQTTClient_setCallbacks() prior to MQTTClient_connect().</p></blockquote><p>建立客户端与服务器的连接。</p><h2 id="MQTTClient-subscribe"><a href="#MQTTClient-subscribe" class="headerlink" title="MQTTClient_subscribe"></a>MQTTClient_subscribe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_subscribe</span><span class="params">(MQTTClient handle, <span class="keyword">const</span> <span class="keyword">char</span>* topic, <span class="keyword">int</span> qos)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>const char*</td><td>topic</td><td>订阅的主题，可含通配符</td></tr><tr><td>int</td><td>qos</td><td>quality of service</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>订阅请求成功</td></tr><tr><td>[error code]</td><td>订阅出现问题</td></tr></tbody></table><blockquote><p>Subscribe is synchronous.  QoS list parameter is changed on return to granted QoSs.Returns return code, MQTTCLIENT_SUCCESS == success, non-zero some sort of error (TBD)<br>This function attempts to subscribe a client to a single topic, which may contain wildcards (see @ref wildcard). This call also specifies the @ref qos requested for the subscription (see also MQTTClient_subscribeMany()).</p></blockquote><p>订阅某个主题。</p><p>类似地，取消订阅函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_unsubscribe</span><span class="params">(MQTTClient handle, <span class="keyword">const</span> <span class="keyword">char</span>* topic)</span></span></span><br></pre></td></tr></table></figure><h2 id="MQTTClient-subscribeMany"><a href="#MQTTClient-subscribeMany" class="headerlink" title="MQTTClient_subscribeMany"></a>MQTTClient_subscribeMany</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_subscribeMany</span><span class="params">(MQTTClient handle, <span class="keyword">int</span> count, <span class="keyword">char</span>* <span class="keyword">const</span>* topic, <span class="keyword">int</span>* qos)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>int</td><td>count</td><td>订阅的主题数量</td></tr><tr><td>char<em> const</em></td><td>topic</td><td>一组指针，订阅的主题，可含通配符</td></tr><tr><td>int*</td><td>qos</td><td>一组指针，quality of service</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>订阅请求成功</td></tr><tr><td>[error code]</td><td>订阅出现问题</td></tr></tbody></table><blockquote><p>This function attempts to subscribe a client to a list of topics, which may contain wildcards (see @ref wildcard). This call also specifies the @ref qos requested for each topic (see also MQTTClient_subscribe()).</p></blockquote><p>同时订阅多个主题。</p><p>类似地，取消订阅函数如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_unsubscribeMany</span><span class="params">(MQTTClient handle, <span class="keyword">int</span> count, <span class="keyword">char</span>* <span class="keyword">const</span>* topic)</span></span></span><br></pre></td></tr></table></figure><h2 id="MQTTClient-publish"><a href="#MQTTClient-publish" class="headerlink" title="MQTTClient_publish"></a>MQTTClient_publish</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_publish</span><span class="params">(MQTTClient handle, <span class="keyword">const</span> <span class="keyword">char</span>* topicName, <span class="keyword">int</span> payloadlen, <span class="keyword">void</span>* payload, <span class="keyword">int</span> qos, <span class="keyword">int</span> retained, MQTTClient_deliveryToken* dt)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>const char*</td><td>topicName</td><td>主题</td></tr><tr><td>int</td><td>payloadlen</td><td>payload字节数</td></tr><tr><td>void*</td><td>payload</td><td>payload</td></tr><tr><td>int</td><td>qos</td><td>quality of service</td></tr><tr><td>int</td><td>retained</td><td>服务器是否保留</td></tr><tr><td>MQTTClient_deliveryToken*</td><td>dt</td><td>函数成功返回则赋值一个代表此message的token，若应用未使用delivery tokens，则应置为NULL</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>成功发布</td></tr><tr><td>[error code]</td><td>发布出现问题</td></tr></tbody></table><blockquote><p>This function attempts to publish a message to a given topic (see also MQTTClient_publishMessage()). An ::MQTTClient_deliveryToken is issued when this function returns successfully. If the client application needs to test for succesful delivery of QoS1 and QoS2 messages, this can be done either asynchronously or synchronously (see @ref async, ::MQTTClient_waitForCompletion and MQTTClient_deliveryComplete()).</p></blockquote><p>对给定主题发布一条message。</p><h2 id="MQTTClient-publishMessage"><a href="#MQTTClient-publishMessage" class="headerlink" title="MQTTClient_publishMessage"></a>MQTTClient_publishMessage</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_publishMessage</span><span class="params">(MQTTClient handle, <span class="keyword">const</span> <span class="keyword">char</span>* topicName, MQTTClient_message* msg, MQTTClient_deliveryToken* dt)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>const char*</td><td>topicName</td><td>主题</td></tr><tr><td>MQTTClient_message*</td><td>msg</td><td>消息</td></tr><tr><td>MQTTClient_deliveryToken*</td><td>dt</td><td>函数成功返回则赋值一个代表此message的token，若应用未使用delivery tokens，则应置为NULL</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>成功发布</td></tr><tr><td>[error code]</td><td>发布出现问题</td></tr></tbody></table><blockquote><p>This function attempts to publish a message to a given topic (see also MQTTClient_publish()). An ::MQTTClient_deliveryToken is issued when his function returns successfully. If the client application needs to test for succesful delivery of QoS1 and QoS2 messages, this can be done either asynchronously or synchronously (see @ref async, ::MQTTClient_waitForCompletion and MQTTClient_deliveryComplete()).</p></blockquote><p>对给定主题发布一条message。</p><h2 id="MQTTClient-waitForCompletion"><a href="#MQTTClient-waitForCompletion" class="headerlink" title="MQTTClient_waitForCompletion"></a>MQTTClient_waitForCompletion</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_waitForCompletion</span><span class="params">(MQTTClient handle, MQTTClient_deliveryToken dt, <span class="keyword">unsigned</span> <span class="keyword">long</span> timeout)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>MQTTClient_deliveryToken</td><td>dt</td><td>Delivery tokens are issued by the publishing functions MQTTClient_publish() and MQTTClient_publishMessage()</td></tr><tr><td>unsigned long</td><td>timeout</td><td>最大等待时间（毫秒）</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>成功发布</td></tr><tr><td>[error code]</td><td>发布出现问题</td></tr></tbody></table><blockquote><p>This function is called by the client application to synchronize execution of the main thread with completed publication of a message. When called, MQTTClient_waitForCompletion() blocks execution until the message has been successful delivered or the specified timeout has expired. See @ref async.</p></blockquote><p>异步客户端中用于等待message的成功发布。</p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *server_address;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *trust_store;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *client_id;</span><br><span class="line">    <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *username;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *password;</span><br><span class="line"></span><br><span class="line">&#125; Connect_param;</span><br></pre></td></tr></table></figure><h2 id="异步发布"><a href="#异步发布" class="headerlink" title="异步发布"></a>异步发布</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asyn_pub_with_ssl</span><span class="params">(Connect_param *param, <span class="keyword">const</span> <span class="keyword">char</span> *topic, <span class="keyword">const</span> <span class="keyword">char</span> *payload, <span class="keyword">int</span> qos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MQTTClient client;</span><br><span class="line">    MQTTClient_deliveryToken token;</span><br><span class="line">    MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;</span><br><span class="line">    MQTTClient_message pubmsg = MQTTClient_message_initializer;</span><br><span class="line">    MQTTClient_SSLOptions ssl_opts = MQTTClient_SSLOptions_initializer;</span><br><span class="line">    ssl_opts.trustStore = param-&gt;trust_store;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    MQTTClient_create(&amp;client, param-&gt;server_address, param-&gt;client_id,</span><br><span class="line">                      MQTTCLIENT_PERSISTENCE_NONE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    conn_opts.keepAliveInterval = <span class="number">20</span>;</span><br><span class="line">    conn_opts.cleansession = <span class="number">1</span>;</span><br><span class="line">    conn_opts.ssl = &amp;ssl_opts;</span><br><span class="line"></span><br><span class="line">    MQTTClient_setCallbacks(client, <span class="literal">NULL</span>, connlost, msgarrvd, delivered);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((rc = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to connect, return code %d\n"</span>, rc);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    pubmsg.payload = (<span class="keyword">void</span> *) payload;</span><br><span class="line">    pubmsg.payloadlen = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(payload);</span><br><span class="line">    pubmsg.qos = qos;</span><br><span class="line">    pubmsg.retained = <span class="number">0</span>;</span><br><span class="line">    deliveredtoken = <span class="number">0</span>;</span><br><span class="line">    MQTTClient_publishMessage(client, topic, &amp;pubmsg, &amp;token);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Waiting for publication of %s\n"</span></span><br><span class="line">           <span class="string">"on topic %s for client with ClientID: %s\n"</span>,</span><br><span class="line">           payload, topic, param-&gt;client_id);</span><br><span class="line">    rc = MQTTClient_waitForCompletion(client, token, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) param-&gt;timeout);</span><br><span class="line">    <span class="comment">//while(deliveredtoken != token);</span></span><br><span class="line">    MQTTClient_disconnect(client, <span class="number">10000</span>);</span><br><span class="line">    MQTTClient_destroy(&amp;client);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步订阅"><a href="#异步订阅" class="headerlink" title="异步订阅"></a>异步订阅</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asyn_sub_with_ssl</span><span class="params">(Connect_param *param, <span class="keyword">const</span> <span class="keyword">char</span> *topic, <span class="keyword">int</span> qos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MQTTClient client;</span><br><span class="line">    MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;</span><br><span class="line">    MQTTClient_SSLOptions ssl_opts = MQTTClient_SSLOptions_initializer;</span><br><span class="line">    ssl_opts.trustStore = param-&gt;trust_store;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">    MQTTClient_create(&amp;client, param-&gt;server_address, param-&gt;client_id,</span><br><span class="line">                      MQTTCLIENT_PERSISTENCE_NONE, <span class="literal">NULL</span>);</span><br><span class="line">    conn_opts.keepAliveInterval = <span class="number">20</span>;</span><br><span class="line">    conn_opts.cleansession = <span class="number">1</span>;</span><br><span class="line">    conn_opts.ssl = &amp;ssl_opts;</span><br><span class="line"></span><br><span class="line">    MQTTClient_setCallbacks(client, <span class="literal">NULL</span>, connlost, msgarrvd, delivered);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((rc = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to connect, return code %d\n"</span>, rc);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Subscribing to topic %s\nfor client %s using QoS%d\n\n"</span></span><br><span class="line">           <span class="string">"Press Q&lt;Enter&gt; to quit\n\n"</span>, topic, param-&gt;client_id, qos);</span><br><span class="line">    MQTTClient_subscribe(client, topic, qos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125; <span class="keyword">while</span> (ch != <span class="string">'Q'</span> &amp;&amp; ch != <span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line">    MQTTClient_unsubscribe(client, topic);</span><br><span class="line">    MQTTClient_disconnect(client, <span class="number">10000</span>);</span><br><span class="line">    MQTTClient_destroy(&amp;client);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MQTT客户端分为同步客户端和异步客户端.　一般流程如下：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.创建一个客户端对象；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2.设置连接MQTT服务器的选项；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  3.如果多线程（异步模式）操作被使用则设置回调函数；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  4.订阅客户端需要接收的任意话题；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  5.重复以下操作直到结束：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a.发布客户端需要的任意信息；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b.处理所有接收到的信息；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  6.断开客户端连接；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  7.释放客户端使用的所有内存。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="mqtt" scheme="https://antfaiz5z.github.io/tags/mqtt/"/>
    
  </entry>
  
  <entry>
    <title>泛型编程与模板的几点问题</title>
    <link href="https://antfaiz5z.github.io/2018/07/12/generic-programming/"/>
    <id>https://antfaiz5z.github.io/2018/07/12/generic-programming/</id>
    <published>2018-07-12T03:19:23.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<p>Template!!!</p><a id="more"></a><h1 id="声明与定义函数模板的两种方式"><a href="#声明与定义函数模板的两种方式" class="headerlink" title="声明与定义函数模板的两种方式"></a>声明与定义函数模板的两种方式</h1><h2 id="声明与实现都放在-h中"><a href="#声明与实现都放在-h中" class="headerlink" title="声明与实现都放在.h中"></a>声明与实现都放在.h中</h2><h2 id="声明在-h中，实现在-cpp中"><a href="#声明在-h中，实现在-cpp中" class="headerlink" title="声明在.h中，实现在.cpp中"></a>声明在.h中，实现在.cpp中</h2><p>即：类模板内部使用泛型和非泛型类型，类外定义函数成员</p><p>优点：简化条理化代码，实现声明和实现分离，高内聚低耦合，对外提供简单的接口，对内高内聚 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TinyVector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 模板类里面的正常函数</span></span><br><span class="line">    TinyVector( <span class="keyword">const</span> T&amp; value );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板类里面含有模板函数 </span></span><br><span class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T2 &gt;</span><br><span class="line">    TinyVector&lt;T,N&gt;&amp; <span class="keyword">operator</span>= ( <span class="keyword">const</span> TinyVector&lt;T2,N&gt;&amp; v );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部实现：</span><br><span class="line"><span class="comment">// 模板类的正常函数</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T, <span class="keyword">int</span> N &gt;</span><br><span class="line">TinyVector&lt;T,N&gt;::TinyVector( <span class="keyword">const</span> T&amp; value )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i ) &#123;</span><br><span class="line">        data_[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类里面的模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T, <span class="keyword">int</span> N &gt;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T2 &gt;</span><br><span class="line">TinyVector&lt;T,N&gt;&amp; TinyVector&lt;T,N&gt;::<span class="keyword">operator</span>= ( <span class="keyword">const</span> TinyVector&lt;T2,N&gt;&amp; v )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i ) &#123;</span><br><span class="line">        data_[i] = v(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即需要在类名后添加类模板的类型参数。</p><p>注意：类模板中所有函数成员都需要如此，即使没有用到泛型变量。</p><h2 id="模板声明和实现分离后的调用原理"><a href="#模板声明和实现分离后的调用原理" class="headerlink" title="模板声明和实现分离后的调用原理"></a>模板声明和实现分离后的调用原理</h2><p>模板不能分离的原因：</p><p>C++标准明确表示，当一个模板不被用到的时侯它就不该被实例化出来，cpp中没有将模板类实例化，所以实际上.cpp编译出来的t.obj文件中关于模板实例类型的一行二进制代码，于是连接器就傻眼了，只好给出一个连接错误。所以这里将.cpp包含进来，其实还是保持模板的完整抽象，main中可以对完整抽象的模板实例化。</p><p>进行分离的方法：</p><p>类的声明必须在实现的前面，所以使用的时候包含cpp就可以把.h和.cpp中定义的内容一并包含了，其实是放在同一个文件中一个意思。<br>这种模板分离的方式缺点：如果这个模板类的cpp有非模板的定义，能够有效实例化，但是会导致重复包含定义而出错所以有些模板的实现和分离放到了.tcc格式或者.inl格式的文件中(这些格式的文件都是来自于txt文本的不能从cpp直接修改得到)，在.h中直接包含进去,代码中就可以直接包含ClassTemplate.h了，避免包含.cpp奇怪的行为。</p><h1 id="模板参数作容器参数迭代器报错"><a href="#模板参数作容器参数迭代器报错" class="headerlink" title="模板参数作容器参数迭代器报错"></a>模板参数作容器参数迭代器报错</h1><h2 id="vector-lt-T-const-iterator"><a href="#vector-lt-T-const-iterator" class="headerlink" title="vector&lt;T>::const_iterator"></a>vector&lt;T>::const_iterator</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::const_iterator iter;</span><br><span class="line"><span class="comment">//error: expected ‘;’ before ‘iter’</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//solution:</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::const_iterator iter;</span><br></pre></td></tr></table></figure><p>原因：</p><p> 首先类除了可以定义数据成员或函数成员之外，还可以定义类型成员。使用std::vector<t>::const_iterator时，编译器假定这样的名字指定的是数据成员，而不是数据类型成员。如果希望编译器将const_iterator当做类型，则必须显示告诉编译器这样做，这就是我们加typename的原因。</t></p><h2 id="typename-const"><a href="#typename-const" class="headerlink" title="typename const"></a>typename const</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::iterator end = dest.end();  <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::iterator end = dest.end();  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>原因：</p><p>应该是typename后面接的下一个单词须是个类型名，而不应是const。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Template!!!&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="template" scheme="https://antfaiz5z.github.io/tags/template/"/>
    
  </entry>
  
  <entry>
    <title>CMake 入门</title>
    <link href="https://antfaiz5z.github.io/2018/07/09/cmake/"/>
    <id>https://antfaiz5z.github.io/2018/07/09/cmake/</id>
    <published>2018-07-09T08:16:46.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="官方wiki"><a href="#官方wiki" class="headerlink" title="官方wiki"></a><a href="https://gitlab.kitware.com/cmake/community/wikis/home" target="_blank" rel="noopener">官方wiki</a></h3><h3 id="CMake-入门实战"><a href="#CMake-入门实战" class="headerlink" title="CMake 入门实战"></a><a href="http://www.hahack.com/codes/cmake/#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">CMake 入门实战</a></h3><h3 id="常用变量、常用环境变量、常用语法总结"><a href="#常用变量、常用环境变量、常用语法总结" class="headerlink" title="常用变量、常用环境变量、常用语法总结"></a><a href="https://blog.csdn.net/bytxl/article/details/50634868" target="_blank" rel="noopener">常用变量、常用环境变量、常用语法总结</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;官方wiki&quot;&gt;&lt;a href=&quot;#官方wiki&quot; class=&quot;headerlink&quot; title=&quot;官方wiki&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://gitlab.kitware.com/cmake/community/wikis/home&quot; targ
      
    
    </summary>
    
      <category term="Linux" scheme="https://antfaiz5z.github.io/categories/Linux/"/>
    
    
      <category term="cmake" scheme="https://antfaiz5z.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>(Always-Update) 常用链接</title>
    <link href="https://antfaiz5z.github.io/2018/07/09/link-list/"/>
    <id>https://antfaiz5z.github.io/2018/07/09/link-list/</id>
    <published>2018-07-09T08:04:53.000Z</published>
    <updated>2019-05-27T12:38:50.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="消息队列函数-msgget、msgctl、msgsnd、msgrcv-及其范例"><a href="#消息队列函数-msgget、msgctl、msgsnd、msgrcv-及其范例" class="headerlink" title="消息队列函数(msgget、msgctl、msgsnd、msgrcv)及其范例"></a><a href="https://blog.csdn.net/guoping16/article/details/6584024" target="_blank" rel="noopener">消息队列函数(msgget、msgctl、msgsnd、msgrcv)及其范例</a></h3><h3 id="gcc编译器-CFLAGS-标志参数说明"><a href="#gcc编译器-CFLAGS-标志参数说明" class="headerlink" title="gcc编译器 CFLAGS 标志参数说明"></a><a href="http://blog.chinaunix.net/uid-20672257-id-3408132.html" target="_blank" rel="noopener">gcc编译器 CFLAGS 标志参数说明</a></h3><h3 id="Makefile-使用总结"><a href="#Makefile-使用总结" class="headerlink" title="Makefile 使用总结"></a><a href="https://www.cnblogs.com/wang_yb/p/3990952.html" target="_blank" rel="noopener">Makefile 使用总结</a></h3><h3 id="Makefile-中subst、foreach、wildcard、notdir函数"><a href="#Makefile-中subst、foreach、wildcard、notdir函数" class="headerlink" title="Makefile 中subst、foreach、wildcard、notdir函数"></a><a href="https://blog.csdn.net/bhj1119/article/details/54970794" target="_blank" rel="noopener">Makefile 中subst、foreach、wildcard、notdir函数</a></h3><h3 id="C中的volatile用法"><a href="#C中的volatile用法" class="headerlink" title="C中的volatile用法"></a><a href="https://www.cnblogs.com/reality-soul/p/6140192.html" target="_blank" rel="noopener">C中的volatile用法</a></h3><h3 id="Linux-malloc底层实现原理"><a href="#Linux-malloc底层实现原理" class="headerlink" title="Linux: malloc底层实现原理"></a><a href="https://blog.csdn.net/mmshixing/article/details/51679571" target="_blank" rel="noopener">Linux: malloc底层实现原理</a></h3><h3 id="Linux环境下段错误的产生原因及调试方法小结"><a href="#Linux环境下段错误的产生原因及调试方法小结" class="headerlink" title="Linux环境下段错误的产生原因及调试方法小结"></a><a href="https://blog.csdn.net/yuzeze/article/details/53144072" target="_blank" rel="noopener">Linux环境下段错误的产生原因及调试方法小结</a></h3><h3 id="Linux进程被信号杀死后退出状态码-exit-code-的分析"><a href="#Linux进程被信号杀死后退出状态码-exit-code-的分析" class="headerlink" title="Linux进程被信号杀死后退出状态码(exit code)的分析"></a><a href="https://blog.csdn.net/halfclear/article/details/72783900" target="_blank" rel="noopener">Linux进程被信号杀死后退出状态码(exit code)的分析</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;消息队列函数-msgget、msgctl、msgsnd、msgrcv-及其范例&quot;&gt;&lt;a href=&quot;#消息队列函数-msgget、msgctl、msgsnd、msgrcv-及其范例&quot; class=&quot;headerlink&quot; title=&quot;消息队列函数(msgget、
      
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="always-update" scheme="https://antfaiz5z.github.io/tags/always-update/"/>
    
  </entry>
  
</feed>
