<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>antFaiz5z&#39;s Fantastic Fertilizer</title>
  
  <subtitle>Coding the World.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://antfaiz5z.github.io/"/>
  <updated>2019-08-24T12:47:42.166Z</updated>
  <id>https://antfaiz5z.github.io/</id>
  
  <author>
    <name>antFaiz5z</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《APUE》阅读笔记</title>
    <link href="https://antfaiz5z.github.io/2019/07/30/apue/"/>
    <id>https://antfaiz5z.github.io/2019/07/30/apue/</id>
    <published>2019-07-30T06:59:54.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX 环境高级编程(Advanced Programming in the UNIX Environment)》</p><a id="more"></a><h2 id="第7章-进程环境"><a href="#第7章-进程环境" class="headerlink" title="第7章 进程环境"></a>第7章 进程环境</h2><h2 id="第8章-进程控制"><a href="#第8章-进程控制" class="headerlink" title="第8章 进程控制"></a>第8章 进程控制</h2><h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><p>ID 为 0 的进程通常是调度进程（交换进程）, 是内核的一部分, 不执行任何磁盘上的程序, 因此也被成为系统进程;<br>ID 为 1 的进程通常是 init 进程, 在自举过程结束时由内核调用, 负责在自举内核后启动一个 UNIX 系统, 负责接管所有孤儿进程, 不会终止, 是一个普通的用户进程, 但以超级用户特权运行.</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>子进程获得父进程的 数据空间、堆和栈的副本（拷贝地址空间）, 但不共享这些存储空间部分, 由于 fork 之后常常跟随 exec, 所以很多实现并不执行数据段、堆和栈的完全副本, 而使用 Copy-On-Write 技术.<br>父子进程共享正文段.</p><p>clone(2) 作为 fork 的推广形式, 它允许调用者控制哪些部分由父进程和子进程共享.</p><p>在 fork 之后, 父子进程的执行顺序是不确定的, 这取决于内核的调度算法.</p><p>write() 是不带缓冲的; 而标准 I/O 库（如 printf）是带缓冲的, 如果标准输出连到终端设备, 则它是行缓冲的, 否则（将标准输出重定向到一个文件时）它是全缓冲的, 这种情况下 fork 之前父进程 printf 的缓冲数据 fork 后将会被拷贝到子进程中, 若 printf 则会又打印出来.<br><code>setbuf(stdout, NUll);</code>可将标准输出的缓冲设置为空, 使其实时输出.</p><p>fork 使得 子进程继承了父进程的：<br>    所有打开文件描述符;<br>    父子进程每个相同的打开描述符共享一个文件表项;（因此重定向父进程的标准输出时, 子进程的标准输出也被重定向）<br>    父子进程共享同一个文件偏移量;（因此一般 1. 父进程等待子进程完成; 2. 父子进程各自执行不同的程序段, 不干扰对方使用的文件描述符）<br>    实际用户 ID、实际组 ID、有效用户 ID、有效组 ID;<br>    附属组 ID;<br>    进程组 ID;<br>    会话 ID;<br>    控制终端;<br>    设置用户 ID 标志和设置组 ID 标志;<br>    当前工作目录;<br>    根目录;<br>    文件模式创建屏蔽字;<br>    信号屏蔽和安排;<br>    对任一打开文件描述符的执行关闭（close-on-exec）标志;<br>    环境;<br>    连接的共享存储段;<br>    存储映像;<br>    资源限制;</p><p>父子进程的区别如下：<br>    fork 的返回值不同;<br>    进程 ID 不同;<br>    父进程 ID 不同;<br>    子进程的 tms_utime、tms_stime、tms_cutime 和 tms_ustime 的值设置为 0;<br>    子进程不继承父进程设置的文件锁;<br>    子进程的未处理闹钟被清除;<br>    子进程的未处理信号集设置为空集;</p><h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>vfork 与 fork 的区别：<br>    1、vfork 创建的新进程的目的是 exec 一个新程序, 不过在子进程调用 exec 或 exit 之前会在父进程的空间运行;（因此并不将父进程的地址空间完全复制到子进程）<br>    2、vfork 保证子进程先运行, 在它调用 exec 或 exit 后父进程才可能被调度运行;（如果在调用这两个函数之前子进程依赖父进程的进一步动作则会导致死锁）</p><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>进程有 5 种正常终止和 3 中异常终止方式：<br>    1、main 函数中执行 return, 相当于对用 exit;<br>    2、调用 exit;（调用终止处理程序, 关闭所有标准 I/O 流等; 但不处理文件描述符、多进程以及作业控制; 由 ISO C 定义）<br>    3、调用 _exit 或 _Exit;(在 UNIX 系统中两种调用等价, 并不冲洗标准 I/O 流; 处理 UNIX 系统特定的细节; exit 调用 _exit; 由 POSIX.1 说明)<br>    4、在进程的最后一个线程在其启动例程中执行 return;（进程以终止状态 0 返回）<br>    5、进程的最后一个线程调用 pthread_exit 函数;<br>    1、调用 abort;（产生 SIGABRT 信号, 是下一种异常终止的一种特例）<br>    2、进程接收到某些信号;（信号可由进程自身（调用 abort）、其他进程或内核产生）<br>    3、最后一个线程对取消请求作出响应;</p><p>不论进程如何终止, 最后都会执行内核中的同一段代码, 即关闭描述符、释放存储器.<br>子进程正常或异常终止时, 内核向其父进程发送 SIGCHLD 信号.</p><p>父进程在子进程前终止：在父进程终止的时候, 内核逐个检查所有活动进程, 若是子进程则将其父进程改为 init 进程.<br>子进程在父进程前终止：子进程需要告知父进程其如何终止（1. 将退出状态（exit status）作为参数传递给 exit、_exit、_Exit; 2. 异常终止时内核而不是进程本身产生一个指示其异常终止原因的终止状态（termination status））,父进程使用 wait 或 waitpid 取得内核为每个终止子进程保存的一定量信息, 这些信息至少包括 进程 ID、进程终止状态、进程使用的 CPU 时间总量.</p><p>一个已经终止而其父进程还未对其获取信息及释放资源的进程称为僵死进程.（ps(1) 打印其状态为 Z）</p><p>为防止系统中塞满僵死进程, init 进程设计成只要有子进程终止就会调用 wait 获取其终止状态. 如果一个进程 fork 一个子进程, 但不想父进程等待子进程终止, 也不想子进程处于僵死状态直到父进程终止, 方法是调用 fork 两次, 即通过让子进程终止使子子进程被 init 进程接管.</p><h3 id="wait-和-waitpid"><a href="#wait-和-waitpid" class="headerlink" title="wait 和 waitpid"></a>wait 和 waitpid</h3><p>waitpid 可等待一个特定的进程, 而 wait 返回任一终止进程的状态;<br>waitpid 提供了一个 wait 的非阻塞版本;<br>waitpid 通过 WUNTRACED 和 WCONTINUED 选项支持作业控制.</p><p>历史遗留：waitid()、wait3()、wait4().</p><h2 id="第10章-信号"><a href="#第10章-信号" class="headerlink" title="第10章 信号"></a>第10章 信号</h2><h2 id="第11章-线程"><a href="#第11章-线程" class="headerlink" title="第11章 线程"></a>第11章 线程</h2><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p>多线程作用：<br>1、通过为每种事件类型分配单独的处理线程, 可以简化处理异步事件的代码;<br>2、多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符放入共享, 而多个线程自动地可以访问相同的存储地址空间和文件描述符;<br>3、有些问题可以分解从而提高整个程序的吞吐量;<br>4、交互的程序可以通过多线程改善响应时间;</p><p>即使程序运行在单核处理器上, 仍然可以享受多线程模型的好处, 可以改善响应时间和吞吐量.</p><h3 id="线程标示"><a href="#线程标示" class="headerlink" title="线程标示"></a>线程标示</h3><p>进程 ID (pid_t) 在整个系统中是唯一的, 而线程 ID (pthread_t) 只有在它所属的进程上下文中才有意义.</p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>进程中任意线程调用 exit、_Exit 或者 _exit, 那么整个进程就会终止.</p><p>单个线程可以通过 3 中方式退出：<br>1、简单地从启动例程中返回, 返回值是线程的退出码 (return);<br>2、被同一进程中的其他线程取消 (pthread_cancel);<br>3、线程调用 pthread_exit (pthread_exit);</p><p>线程通过调用 return 返回或者调用 pthread_exit 退出, 进程中的其他线程可以通过调用 pthread_join 获得该线程的退出状态. 默认情况下, 线程的终止状态会保存直到对该线程调用 pthread_join.</p><p>pthread_exit 和 pthread_create 的 void* 参数可以是一个简单数值, 也可以是一个复杂结构体. 只是这个结构所使用的的内存在调用者完成调用以后必须是有效的, 比如 pthread_join 会试图使用该结构. 因此可以使用全局结构或用 malloc 分配堆空间.</p><p>pthread_cancel 并不等待线程终止, 它仅仅提出请求, 对方线程可以选择忽略取消或者控制如何被取消.</p><p>使用 pthread_cleanup_push 注册的线程清理函数 rtn 只有当线程采取以下动作时才会被调用：<br>1、调用 pthread_exit 时;<br>2、相应取消请求时;<br>3、用非零参数调用 pthread_cleanup_pop 时;</p><p>而简单使用 return 返回时不会执行线程清理程序.</p><p>并且线程处理函数注册在栈中, 因此执行顺序与它们注册时相反.</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>待更新</p><table><thead><tr><th>同步原语</th><th>进程</th><th>线程 POSIX</th><th>线程 STL</th></tr></thead><tbody><tr><td>获取 ID</td><td>getpid</td><td>pthread_self</td><td>std::this_thread::get_id()</td></tr><tr><td>创建</td><td>fork</td><td>pthread_create<br>pthread_detach<br>pthread_join<br></td><td>std::thread和其成员函数</td></tr><tr><td>终止</td><td>exit</td><td>pthread_exit</td><td></td></tr><tr><td>非正常终止</td><td>abort</td><td>pthread_cancel</td><td></td></tr><tr><td>终止时清理</td><td>atexit</td><td>pthread_cleanup_push<br>pthread_cleanup_pop</td><td></td></tr><tr><td>互斥量</td><td>N/A</td><td>pthread_mutex_init<br>pthread_mutex_destroy<br>pthread_mutex_lock<br>pthread_mutex_trylock<br>pthread_mutex_unlock<br>pthread_mutex_timedlock</td><td>std::mutex类<br>std::unique_lock&lt;&gt;模板<br>std::lock_guard&lt;&gt;模板</td></tr><tr><td>条件变量</td><td>N/A</td><td>pthread_cond_init<br>pthread_cond_destroy<br>pthread_cond_wait<br>pthread_cond_timedwait<br>pthread_cond_signal<br>pthread_cond_broadcast</td><td>std::condition_variable<br>std::condition_variable_any</td></tr><tr><td>读写锁</td><td>N/A</td><td>pthread_rwlock_init<br>pthread_rwlock_destroy<br>pthread_rwlock_rdlock<br>pthread_rwlock_wrlock<br>pthread_rwlock_tryrdlock<br>pthread_rwlock_trywrlock<br>pthread_rwlock_unlock<br>pthread_rwlock_timedrdlock<br>pthread_rwlock_timedwrlock</td><td></td></tr><tr><td>自旋锁</td><td>N/A</td><td>pthread_spin_init<br>pthread_spin_destroy<br>pthread_spin_lock<br>pthread_spin_trylock<br>pthread_spin_unlock<br></td><td></td></tr><tr><td>屏障</td><td>N/A</td><td>pthread_barrier_init<br>pthread_barrier_destroy<br>pthread_barrier_wait</td></tr></tbody></table><h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>如果线程试图对同一个互斥量加锁两次, 那么它自身就会陷入死锁状态.</p><p>如果锁的粒度太粗, 就会出现很多线程阻塞等待相同的锁, 这可能并不能改善并发性;<br>如果锁的粒度太细, 那么过多的锁开销就会使系统性能受到影响;<br>程序员需要在代码复杂性和性能之间找到正确的平衡.</p><p>pthread_mutex_t 静态初始化：PTHREAD_MUTEX_INITIALIZER<br>pthread_mutex_t 动态初始化：pthread_mutex_init/pthread_mutex_destroy<br>(条件变量 pthread_cond_t、<br>读写锁 pthread_rwlock_t、<br>自旋锁 pthread_spinlock_t、<br>屏障 pthread_barrier_t 类似)</p><p>如果动态分配互斥量（如通过调用 malloc 函数）, 在释放内存前需要调用 pthread_mutex_destroy.<br>（条件变量 pthread_cond_init/destroy、<br>读写锁 pthread_rwlock_init/destroy、<br>自旋锁 pthread_spin_init/destroy、<br>屏障 pthread_barrier_init/destroy 类似）</p><p>pthread_mutex_trylock 不阻塞直接返回：加锁成功返回 0, 失败返回 EBUSY. 用来避免线程阻塞.<br>pthread_mutex_timedlock 指定线程愿意阻塞等待的绝对时间, 若超时未加锁成功则返回 ETIMEOUT. 用来避免线程永久阻塞.<br>（条件变量 pthread_cond_timedwait、<br>读写锁 pthread_rwlock_&lt;try/timed&gt;&lt;rdlock/wrlock&gt;、<br>自旋锁 pthread_spin_trylock 类似）</p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>条件变量本身是由互斥量保护的, 线程在改变条件状态之前必须先锁住互斥量, 其他线程在得到互斥量之前不会察觉到这种改变.</p><p>传递给 pthread_cond_wait 的互斥量对条件进行保护. 调用者把锁住的互斥量传给函数, 函数然后自动把线程放到等待条件的线程列表上, 对互斥量解锁. 这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道, 于是线程不会错过条件的任何变化. pthread_cond_wait 返回时互斥量再次被锁住.</p><p>pthread_cond_timedwait 传入的绝对时间参数为 timespec 结构, 可以使用 clock_gettime 获取 timespec 结构表示的当前时间, 或者使用 gettimeofday 获取 timeval 结构表示的当前时间再转换成 timespec 结构.</p><p>从 pthred_cond_[timed]wait 调用成功返回时, 线程需要重新计算条件, 因为另一个线程可能已经在运行并改变了条件.</p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁非常适合于对数据结构读的次数远大于写的情况. 与互斥量相比, 读写锁在使用之前必须初始化, 在释放它们底层的内存之前必须销毁.</p><p>有的实现可能会对共享模式（读模式）下可获取的读锁的次数进行限制（避免读锁长期占用而使写锁请求得不到满足）, 所以需要检查 pthread_rwlock_rdlock 的返回值.</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>应用场景：锁的持有时间短, 而且线程不希望在重新调度上花费太多的成本.</p><p>当线程等待锁变为可用时, CPU 不能做其他的事情, 这也是自旋锁只能够被持有一小段时间的原因. 事实上, 某些自旋锁的实现在试图获得互斥量的时候会自旋一小段时间, 在自旋计数达到某一阈值的时候才会休眠.</p><p>pthread_spin_lock 和 pthread_spin_trylock 对自旋锁加锁, 前者在获取之前一直自旋, 后者不能自旋.</p><h4 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h4><p>对某个线程来说, pthread_barrier_wait 的返回值为 PTHREAD_BARRIER_SERIAL_THREAD, 剩下的线程看到的返回值为 0. 这使得一个线程可以作为主线程, 它可以工作在其他所有线程已完成的工作结果上.</p><p>一旦达到屏障计数值, 而且线程处于非阻塞状态, 屏障就可以重用. 但是除非连续调用  pthread_barrier_destroy 和 pthread_barrier_init 后, 否则屏障计数不会改变.</p><h2 id="第15章-进程间通信"><a href="#第15章-进程间通信" class="headerlink" title="第15章 进程间通信"></a>第15章 进程间通信</h2><p>管道（匿名、FIFO）、消息队列、共享内存、信号量、套接字、信号</p><p>总结：</p><p>管道： 单向传输（半双工）, 效率低下（a 传输给 b, 只有等 b 取数据后 a 才能返回）, 不适合频繁通信，优点是简单.</p><p>消息队列： 可以解决管道效率低下的问题, 但是仍不适合发送数据多且频繁的场景, 因为拷贝开销过大.</p><p>共享内存： 可以解决消息队列拷贝时间的问题, 通过各自一段虚拟地址映射至同一段物理内存.</p><p>信号量： 可以解决共享内存多进程竞争问题, 本质是一个计数器</p><p><a href="https://stackoverflow.com/questions/4582968/system-v-ipc-vs-posix-ipc" target="_blank" rel="noopener">system-v-ipc-vs-posix-ipc</a></p><table><thead><tr><th></th><th>System V</th><th></th><th></th><th>POSIX</th><th></th><th></th></tr></thead><tbody><tr><td></td><td>消息队列</td><td>信号量</td><td>共享内存</td><td>消息队列</td><td>信号量</td><td>共享内存</td></tr><tr><td>头文件</td><td>&lt;sys/msg.h&gt;</td><td>&lt;sys/sem.h&gt;</td><td>&lt;sys/shm.h&gt;</td><td>&lt;mqueue.h&gt;</td><td>&lt;semaphore.h&gt;</td><td>&lt;sys/mman.h&gt;</td></tr><tr><td>创建或打开IPC的函数<br>(删除IPC的函数)</td><td>msgget</td><td>semget</td><td>shmget</td><td>mq_open<br>mq_close<br>mq_unlink<br></td><td>sem_open<br>sem_close<br>sem_unlink<br>sem_init<br>sem_destroy</td><td>shm_open<br>shm_unlink<br></td></tr><tr><td>控制IPC操作的函数</td><td>msgctl</td><td>semctl</td><td>shmctl</td><td>mq_getattr<br>mq_setattr</td><td></td><td>ftruncate<br>fstat</td></tr><tr><td>IPC操作函数</td><td>msgsnd<br>msgrcv</td><td>semop</td><td>shmat<br>shmdt</td><td>mq_send<br>mq_receive<br>mq_notify</td><td>sem_wait<br>sem_trywait<br>sem_timedwait<br>sem_post<br>sem_getvalue</td><td>mmap<br>munmap</td></tr></tbody></table><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>历史上是半双工的, 即数据只在一个方向上流动, 现在某些系统提供全双工管道.</p><p>固定 fd[0] 为读端, fd[1] 为写端.</p><p>常量 PIPE_BUF 规定了内核的管道缓冲区大小, 如果多个进程对同一管道调用 write, 而且要求写的字节数超过 PIPE_BUF, 那么各个进程所写的数据可能会相互交叉.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>FIFO 是一种文件类型, 使用 open 打开时, 可以指定非阻塞标志（O_NONBLOCK）.</p><p>应用程序可以使用 mknod 和 mknodat 函数创建 FIFO（mknod 现已添加在 POSIX.1 的 XSI 扩展中）.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,  <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="POSIX-信号量"><a href="#POSIX-信号量" class="headerlink" title="POSIX 信号量"></a>POSIX 信号量</h3><p>POSIX 信号量接口解决了 XSI 信号量接口的几个缺陷：<br>1、更高性能<br>2、接口使用更简单：没有信号量集<br>3、在删除时表现更完美：XSI 信号量被删除时使用这个信号量标识符的操作会失败, 并将 errno 置为 EIDRM; 而使用 POSIX 信号量时, 操作能继续正常工作到该信号量的最后一次引用被释放.</p><p>POSIX 信号量包括 命名的和未命名的.</p><h2 id="第16章-网络-IPC：套接字"><a href="#第16章-网络-IPC：套接字" class="headerlink" title="第16章 网络 IPC：套接字"></a>第16章 网络 IPC：套接字</h2><h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>套接字描述符在 UNIX 系统中被当做是一种文件描述符, 但不是所有参数为文件描述符的函数都可以接受套接字描述符.</p><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>Linux 3.2.0 - 小端<br>Mac OSX 10.6.8 - 小端<br>Solaris 10 - 大端<br>TCP/IP 协议栈 - 大端</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p><code>int bind(int sockfd, struct sockaddr *addr, socklen_t len);</code></p><p>一般只能将一个套接字端点绑定到一个给定地址上, 尽管有些协议支持多重绑定.</p><p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t len);</code></p><p>使用 UDP (无连接的套接字)同样可以调用 connect, 表示只一对一发送, 如此可以使用 send.</p><p><code>int listen(int sockfd, int backlog);</code></p><p>参数 backlog 提供了一个提示, 提示系统该进程所要入队的未完成连接请求数量（对于 TCP, 其默认值为 128）, 一旦队列满系统就会拒绝多余的连接请求.</p><p><code>int accept(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict len);</code></p><p>如果没有连接请求在等待, accept 会阻塞直到一个请求到来. 如果 sockfd 处于非阻塞模式, accept 会返回 -1, 并将 errno 设置为 EAGAIN 或 EWOULDBLOCK.<br>可以使用 poll 或 select 来等待一个请求的到来, 此时一个带有等待连接请求的套接字会以可读的方式出现.</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p><code>ssize_t send(int sockfd, cosnt void *buf, size_t nbytes, int flags);</code></p><p>send 类似于 write, 但可以通过指定标志来改变处理传输数据的方式.<br>使用 send 时套接字必须已经连接.<br>即使 send 成功返回, 也并不表示连接的另一端的进程就一定接受了数据, 只能保证无误地发送到了网络驱动程序上.<br>对于支持报文边界的协议, 如果尝试发送的单个报文的长度超过协议所支持的最大长度, 那么 send 会失败, 并将 errno 设为 EMSGSIZE;<br>对于字节流协议, send 会阻塞直到整个数据传输完成.</p><p><code>ssize_t sendto(int sockfd, cosnt void *buf, size_t nbytes, int flags, const struct sockaddr *destaddr, socklen_t destlen);</code></p><p>与 send 相比, 区别在于 sendto 可以在无连接的套接字上指定一个目标地址.</p><p><code>ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</code></p><p>使用 msghdr 结构来指定多重缓冲区传输数据, 类似于 writev.</p><p><code>ssize_t recv(int sockfd, cosnt void *buf, size_t nbytes, int flags);</code><br><code>ssize_t recvfrom(int sockfd, cosnt void *buf, size_t nbytes, int flags, const struct sockaddr *destaddr, socklen_t destlen);</code><br><code>ssize_t recvmsg(int sockfd, const struct msghdr *msg, int flags);</code></p><p>类似于 readv.</p><h3 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h3><p>TCP 支持带外数据, UDP 不支持.</p><p>TCP 将带外数据称为紧急数据, 仅支持一个字节的紧急数据, 但是允许紧急数据在普通数据传递机制数据流之外传输.<br>为了产生紧急数据, 可以在 3 个 send 函数里指定 MSG_OOB 标志.<br>如果带 MSG_OOB 标志发送的数据超过一个时, 最后一个字节被视为紧急数据.<br>如果在接受当前的紧急数据字节之前又有新的紧急数据到来, 那么已有的字节会被丢弃.</p><h3 id="非阻塞与异步-I-O"><a href="#非阻塞与异步-I-O" class="headerlink" title="非阻塞与异步 I/O"></a>非阻塞与异步 I/O</h3><p>通常, 当套接字输出队列没有足够空间来发送消息时, send 函数会阻塞; recv 函数没有数据可用时会阻塞等待. 而在套接字非阻塞模式下, 这些函数不会阻塞而是失败, 将 errno 设为 EAGAIN 或 EWOULDBLOCK, 一般可以使用 poll 或 select 来判断能否接受或传输数据.</p><p>一些文献把经典的基于套接字的异步 I/O 机制称为 “基于信号的 I/O”, 区别于 Single UNIX Specification 中的通用异步 I/O 机制.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX 环境高级编程(Advanced Programming in the UNIX Environment)》&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="https://antfaiz5z.github.io/categories/Reading/"/>
    
    
      <category term="apue" scheme="https://antfaiz5z.github.io/tags/apue/"/>
    
  </entry>
  
  <entry>
    <title>《Muduo》阅读笔记</title>
    <link href="https://antfaiz5z.github.io/2019/06/28/muduo/"/>
    <id>https://antfaiz5z.github.io/2019/06/28/muduo/</id>
    <published>2019-06-28T09:05:28.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>原书《Linux 多线程服务端编程：使用 muduo C++ 网络库》.</p><a id="more"></a><h2 id="第三章-多线程服务器的适用场合与常用编程模型"><a href="#第三章-多线程服务器的适用场合与常用编程模型" class="headerlink" title="第三章 多线程服务器的适用场合与常用编程模型"></a>第三章 多线程服务器的适用场合与常用编程模型</h2><p>每个进程有自己独立的地址空间, 线程的特点是共享地址空间, 从而高效地共享数据. 多线程的价值在于更好地发挥多核处理器的效能.</p><p>“Reactor” 模型 = “non-blocking IO” + “IO multiplexing”</p><p>Reactor 模型的优点：<br>编程不难、效率不错;<br>不仅可以用于读写 socket、连接的建立, 甚至 DNS 解析都可以用非阻塞方式进行, 以提高并发度和吞吐量, 对于 IO 密集型应用是个不错的选择.</p><p>基于事件驱动的编程模型的缺点：<br>它要求事件回调函数必须是非阻塞的, 对于涉及网络 IO 的请求响应式协议, 它容易割裂业务逻辑, 使其散布于多个回调函数之中, 相对不容易理解与维护.</p><p>实用方案：<br>1、thread-per-connection<br>2、单线程 reactor<br>3、reactor + 线程池<br>4、one loop per thread（reactors）<br>5、one loop per thread（reactors）+ 线程池</p><p>方案间的区别在于 接受新连接的线程、网络 IO 的线程、计算任务的线程 是否为同一个线程. 计算任务的线程基本对应于线程池.<br>muduo 直接支持后四种.</p><p>thread per connection 不适合高并发场景, 其伸缩性不佳.<br>one loop per thread 的并发度足够大, 且与 CPU 核数成正比.<br>基于 IO multiplexing 的 一个 event loop 的并发连接数可以轻松达到几千乃至上万.</p><p>one loop（或者说 reactor） per thread 优点：<br>1、线程数目基本固定, 可以在程序启动的时候设置, 不会频繁创建与销毁;<br>2、可以很方便地在线程间调配负载;<br>3、IO 事件发生的线程是固定的, 同一个 TCP 连接不必考虑事件并发.</p><p>必须使用单线程的场合：<br>1、程序可能会 fork(). 多线程程序不是不能调用 fork(), 而是这么做会遇到很多麻烦<br>2、限制程序的 CPU 占用率.</p><p>无论是 IO 密集型或是 CPU 密集型的服务,  多线程都没有什么绝对意义上的性能优势. 意思是, 如果用很少的 CPU 负载就能让 IO 跑满, 或者用很少的 IO 流量就能让 CPU 跑满, 那么多线程没什么用处.<br>虽然多线程不能提高绝对性能, 但能提高平均响应性能.</p><p>多线程适用的场景：<br>提高响应速度, 让 IO 和 “计算” 相互重叠, 降低延迟.</p><p>一般多线程程序中的线程主要有三类：IO 线程、计算线程、第三方库所使用的线程如 logging、database connection.</p><p>一个多线程的进程和多个单线程的进程的取舍：<br>如果工作集较大, 那么就用多线程, 避免 CPU cache 换入换出, 影响性能;<br>否则就用单线程进程, 享受单线程编程的便利.</p><h2 id="第九章-分布式工程实践"><a href="#第九章-分布式工程实践" class="headerlink" title="第九章 分布式工程实践"></a>第九章 分布式工程实践</h2><p>将”随时能重启进程”作为程序设计目标, 要求程序只使用操作系统能自动回收的 IPC, 不使用生命期大于进程的 IPC, 也不使用无法重建的 IPC. 具体来说, 只使用 TCP 作为进程间通信的唯一手段.</p><h3 id="心跳协议的设计"><a href="#心跳协议的设计" class="headerlink" title="心跳协议的设计"></a>心跳协议的设计</h3><p>应用层心跳必不可少：<br>1、操作系统崩溃导致机器重启, 没有机会发送 FIN 分节<br>2、服务器硬件故障导致机器重启, 也没有机会发送 FIN 分节<br>3、并发连接数很高时, 操作系统或进程如果重启, 可能没有机会断开全部连接, 即 FIN 分节可能出现丢包, 但没有机会重试<br>4、网络故障, 连接双方能得知这一情况的唯一方案是检测心跳超时</p><p>为什么 TCP keepalive 不能代替应用层心跳?<br>心跳除了说明进程还在、网络通畅, 更重要的是表明应用程还能正常工作;<br>而 TCP keepalive 由操作系统负责探查, 即使进程死锁或阻塞, 操作系统也会如常收发 TCP keepalive 消息, 对方无法得知这一异常.</p><p>进程 C 依赖于 S, 则一般 S 为 sender, C 为 receiver.</p><p>心跳设计关键：（高置信度与低反应时间不可兼得）<br>1、通常 sender 的发送周期和 receiver 的检查周期相同, 为 T; timeout 时间一般为 2T<br>2、T 越小, 开销越大; T 越大, receiver 检测到故障的延迟也就越大<br>3、心跳信息应该包含<code>发送方的标识符</code>; 建议也包含<code>当前负载</code>, 便于客户端做负载均衡<br>4、如果 sender 和 receiver 之间有其他消息中转进程, 那么还应该加上 sender 的<code>发送时间</code>, 防止消息在传输过程中堆积而导致假心跳<br>5、要在工作线程中发送, 不要单独起一个”心跳线程”, 防止伪心跳（防止工作线程死锁或阻塞时还在发送心跳）<br>6、与业务信息用同一个连接, 不要单独用”心跳连接”, 防止伪心跳（如果验证的不是收发业务数据的 TCP 连接畅通则意义不大）</p><h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><p>以四元组 ip:port:start_time:pid 作为分布式系统中的 gpid.<br>进一步,还可以把程序的名称和版本号作为 gpid 的一部分, 起到锦上添花的作用.<br>如此生成全局唯一的消息 id 字符串也十分简单, 只要在进程内使用一个原子计数器, 用计数器递增的值和 gpid 即可组成每个消息的全局唯一 id.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原书《Linux 多线程服务端编程：使用 muduo C++ 网络库》.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="https://antfaiz5z.github.io/categories/Reading/"/>
    
    
      <category term="Muduo" scheme="https://antfaiz5z.github.io/tags/Muduo/"/>
    
  </entry>
  
  <entry>
    <title>数据库相关书籍阅读笔记</title>
    <link href="https://antfaiz5z.github.io/2019/06/17/sql/"/>
    <id>https://antfaiz5z.github.io/2019/06/17/sql/</id>
    <published>2019-06-17T01:47:02.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>《数据库系统概念》、《高性能 MySQL》、《深入理解 MySQL》、《MySQL 技术内幕: InnoDB 存储引擎》等.</p><a id="more"></a><h2 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>原子性（atomicity）:<br>事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；<br>恢复系统 保证</li><li>一致性（consistency）:<br>执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；<br>程序员 保证</li><li>隔离性（isolation）:<br>并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；<br>并发控制系统 保证</li><li>持久性（durability）:<br>一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。<br>恢复系统 保证</li></ul><h3 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h3><p><img src="/images/sql-transaction.png" alt></p><h3 id="并发问题及相应隔离级别"><a href="#并发问题及相应隔离级别" class="headerlink" title="并发问题及相应隔离级别"></a>并发问题及相应隔离级别</h3><ul><li>丢失修改（Lost to modify）:<br>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li><li>脏读（Dirty read）:<br>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li>不可重复读（Unrepeatable read）:<br>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li>幻读（Phantom read）:<br>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。<br>不可重复度和幻读区别：不可重复读的重点是修改，幻读的重点在于新增或者删除。</li></ul><ul><li>未提交读（read uncommitted）:<br>允许读取未提交数据.</li><li>已提交读（read committed）:<br>只允许读取已提交数据.</li><li>可重复读（repeatable read）:<br>只允许读取已提交数据, 而且在一个事务两次读取一个数据项期间, 其他事务不得更新该数据.</li><li>可串行化（serializable）:<br>通常保证可串行化调度.</li></ul><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center"></th><th style="text-align:center">未提交读</th><th style="text-align:center"></th><th style="text-align:center">已提交读</th><th style="text-align:center"></th><th style="text-align:center">可重复读</th><th style="text-align:center"></th><th style="text-align:center">可串行化</th></tr></thead><tbody><tr><td style="text-align:center">并发问题</td><td style="text-align:center">丢失修改?</td><td style="text-align:center"></td><td style="text-align:center">脏读</td><td style="text-align:center"></td><td style="text-align:center">不可重复读</td><td style="text-align:center"></td><td style="text-align:center">幻读</td></tr></tbody></table><p>以上所有隔离级别都不允许脏写（dirty write）, 即如果一个数据项已经被另外一个尚未提交或中止的事务写入, 则不允许对该数据执行写操作.</p><p>“串行化”为最高隔离级别, 完全服从 ACID;</p><p>在 SQL 中, 除了接受系统的默认设置, 还可以显示地设置隔离性级别. 例如, “set transaction isolation serializable”.</p><p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 SERIALIZABLE (可串行化)隔离级别。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失。</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE (可串行化)隔离级别。</p><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>机制: 锁、时间戳、多版本和快照隔离.</p><ul><li><p>两段锁: 第一个阶段只获得锁不释放锁, 第二个阶段只释放锁不获得锁.</p></li><li><p>共享锁: 用于事务读的数据项</p></li><li>排他锁: 用于数据写的数据项</li></ul><p>这两种锁模式以及两阶段封锁协议在保证可串行化的前提下允许数据的并发读.</p><h2 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h2><p>Record Lock：单个行记录上的锁<br>Gap Lock：间隙锁, 锁定一个范围, 但不包含记录本身<br>Next-Key Lock：Record Lock + Gap Lock, 锁定一个范围, 并锁定记录本身</p><p>Nexy-Key Lock 降级为 Record Lock 仅在查询的列是唯一索引的情况下, 若是辅助索引则情况不同, 此时对聚集索引加的是 Record Lock, 对辅助索引加的是 Next-Key Lock. 需要特别注意的是, InnoDB 引擎还会对辅助索引下一个键值加上 Gap Lock.</p><p>Gap Lock 的作用是为了阻止多个事务将记录插入到同一范围内, 这会导致幻影读的问题产生.<br>Phantom Problem 是指在同一事务下, 连续执行两次同样的 SQL 语句可能导致不同的结果, 第二次的 SQL 语句可能会返回之前不存在的行.</p><p>InnoDB 引擎在默认可重复读隔离级别下采用 Next-Key Lock加锁, 而在已提交读级别下仅采用 Record Lock.</p><p>用户可通过 InnoDB 的 Next-Key Lock 机制在应用层面实现唯一性的检查.</p><h2 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h2><p>索引是存储引擎用于快速找到记录的一种数据结构. 由存储引擎实现索引.</p><h3 id="索引优点"><a href="#索引优点" class="headerlink" title="索引优点"></a>索引优点</h3><p>1、索引大大减少了服务器需要扫描的数据量<br>2、索引可以帮助服务器避免排序和临时表<br>3、索引可以将随机 IO 变为顺序 IO</p><h3 id="常用索引类别"><a href="#常用索引类别" class="headerlink" title="常用索引类别"></a>常用索引类别</h3><ul><li><p>顺序索引:</p></li><li><p>哈希索引:<br>基于哈希表实现, 只有精确匹配索引所有列的查询才有效, 即不支持部分索引列匹配查找, 也不支持任何范围查询. 只支持等值比较查询, 包括 =、IN()、&lt;=&gt;.<br>哈希索引数据并不是按照索引值顺序存储的, 所以也就无法排序.<br>在 MySQL 中只有 Memory 引擎显示支持哈希索引, 并且其支持非唯一哈希索引.<br>访问哈希索引的速度非常快, 除非有很多哈希冲突.<br>在数据仓库应用中有一种经典的星型 schema, 需要关联很多查找表, 哈希索引就非常适合查找表的需求.<br>InnoDB 有一个特殊功能”自适应哈希索引”, 即针对某些使用频繁的索引值, 在内存中基于 B-Tree 索引之上再创建一个哈希索引, 使得 B-Tree 索引也具有哈希索引的一些优点.<br>也有创建自定义哈希索引的方法, 就是新增一个用于索引的哈希值列.</p></li><li><p>B-Tree 索引:<br>B-Tree 索引适用于全键值、键值范围或键前缀查找, 其中键前缀查找只适用于根据最左前缀的查找（所以在优化性能的时候可能需要使用相同的列但顺序不同的索引来满足不同类型的查询请求）.<br>支持以下查询: 全值匹配、匹配最左前缀、匹配列前缀、匹配范围值、精确匹配某一列并范围匹配另一列、只访问索引的查询.</p></li><li><p>R-Tree 索引（空间数据索引）:<br>MyISAM 表支持空间索引, 可以用作地理数据存储.</p></li><li><p>full-text 索引（全文索引）:<br>全文索引是一种特殊类型的索引, 它查找的是文本中的关键词, 而不是直接比较索引中的值. 与其他几类索引的匹配方式完全不同.<br>仅可用于MyISAM表，针对较大的数据，生成全文索引非常的消耗时间和空间（在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引）。</p></li></ul><p>聚集索引（主索引）<br>非聚集索引（辅助索引）</p><p>稠密索引<br>稀疏索引</p><h3 id="索引评价"><a href="#索引评价" class="headerlink" title="索引评价"></a>索引评价</h3><ul><li><p>第一颗星:<br>索引将相关的记录放在一起</p></li><li><p>第二颗星:<br>索引中的数据顺序和查找中的排列顺序一致</p></li><li><p>第三颗星:<br>索引中的列包含了查询中需要的全部列</p></li></ul><h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><p>正确地创建和使用索引是实现高性能查询的基础.</p><ul><li><p>独立的列:<br>即索引列不能是表达式的一部分, 也不能是函数的参数.</p></li><li><p>前缀索引:<br>索引很长的字符列, 会让索引变得大且慢.<br>前缀索引是一种能使索引更小更快的有效办法.<br>MySQL无法使用前缀索引做 ORDER BY 和 GROUP BY 以及做覆盖扫描.<br>对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列, 必须使用前缀索引, 因为 MySQL 不允许索引这些列的完整长度.<br>后缀索引也有用途, 例如查找某个域名的所有电子邮件. MySQL 原生并不支持反向索引, 但是可以把字符串反转后存储, 并基于此建立前缀索引, 通过触发器维护这种索引.</p></li><li><p>多列索引</p></li></ul><p>又叫组合索引、联合索引。用多个列组合构建的索引，这多个列中的值不允许有空值。可以在创建表的时候指定，也可以修改表结构。</p><p><code>ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；</code></p><p>为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。创建复合索引时应该将最常用（频率）作限制条件的列放在最左边，依次递减。示例的组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。</p><p>在多个列上建立单独的单列索引大部分情况下并不能提高 MySQL 的查询性能.<br>MySQL 5.0 之后引入了”索引合并”的策略, 一定程度上可以使用表上的多个单列索引来定位指定的行. 索引合并策略有时候是一种优化的结果, 但实际上更多时候说明表上的索引建得很糟糕.<br>当出现服务器对多个索引作相交操作时（通常有多个 AND 条件）, 通常意味着需要一个包含所有相关列的多列索引, 而不是多个独立的单列索引.</p><ul><li>选择合适的索引列顺序<br>当不需要考虑分组和排序的时候, 将选择性最高的列放在最前面通常是很好的.</li></ul><blockquote><p>索引的选择性是指, 不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值, 范围在 1/#T 到 1 之间.</p></blockquote><ul><li><p>聚簇索引<br>聚簇索引并不是一种单独的索引类型, 而是一种数据存储方式. 具体的细节依赖于其实现方式, 但 InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行.<br>因为无法把数据行同时存放在两个不同的地方, 所以一个表只能有一个聚簇索引（不过覆盖索引可以模拟聚簇索引的情况）.<br>InnoDB 通过主键聚集数据, 即索引列为主键列. 如果没有定义主键, InnoDB 则会选择一个唯一的非空索引代替. 若没有这样的索引则隐式定义一个主键来作为聚簇索引.<br>一些数据库服务器允许选择哪个索引作为聚簇索引, 但目前没有一个 MySQL 内建存储引擎支持这一点.<br>优点：<br>  1、可以把相关数据保存在一起<br>  2、数据访问更快<br>  3、使用覆盖索引扫描的查询可以直接使用叶节点中的键值<br>缺点：<br>  1、聚簇索引最大限度地提高了 I/O 密集型应用的性能, 但如果数据全部放在内存中, 则访问顺序就没那么重要了, 聚簇索引也就没什么优势了<br>  2、插入速度严重依赖于插入顺序<br>  3、更新聚簇索引列的代价很高<br>  4、基于聚簇索引的表在插入新行或者主键被更新导致需要移动行的时候, 可能面临”页分裂”的问题<br>  5、聚簇索引可能导致全表扫描变慢, 尤其是行比较稀疏, 或者由于页分裂导致数据存储不连续的时候<br>  6、二级索引（非聚簇索引）可能比想象的要更大, 因为在二级索引的叶子节点包含了引用行的主键列<br>  7、二级索引访问需要两次索引查找, 而不是一次<br>InnoDB 的二级索引与聚簇索引很不相同. InnoDB 二级索引的叶子节点中存储的不是”行指针”而是主键值, 这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作.</p></li><li><p>覆盖索引<br>指从辅助索引中就能获取到需要的记录，而不需要查找主键索引中的记录。使用覆盖索引的一个好处是因为辅助索引不包括一条记录的整行信息，所以数据量较聚集索引要少，可以减少大量io操作。</p></li></ul><p>索引包含所有需要查询的字段的值, 而无需回表查询.<br>覆盖索引必须要存储索引列的值, 而哈希索引、空间索引和全文索引都不存储索引列的值, 所以 MySQL 只能使用 B-Tree 索引做覆盖索引.<br>当发起一个被索引覆盖的查询（也叫做索引覆盖查询）时, 在 EXPLAIN 时 Extra 列的值为 “Using index”.</p><ul><li><p>使用索引扫描来做排序<br>EXPLAIN 的 type 列表示这个查询访问数据的方式, 或者说是 MySQL 查找行的方式.<br>当 MySQL 使用了索引扫描来做排序时, 在 EXPLAIN 时 type 列的值为 “index”.<br>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致, 并且所有列的排序方向都一致时, MySQL 才能够使用索引来对结果做排序…</p></li><li><p>压缩（前缀压缩）索引<br>MyISAM 使用前缀压缩来减少索引的大小, 可能只需要原来的十分之一大小的存储空间, 从而让更多的索引可以放入内存中, 代价是某些操作更慢, 因为每个值得压缩前缀都依赖前面的值, 所以查找时无法使用二分查找而只能从头扫描.<br>对于 I/O 密集型应用, 对某些查询带来的好处会比成本多得多;<br>而对于 CPU 密集型应用, 因为扫描需要随机查找, 压缩索引使得 MyISAM 在索引查找上要慢上好几倍, 倒序扫描就更慢了.</p></li><li><p>冗余和重复索引<br>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引. 应该避免这样创建重复索引.<br>冗余索引则不同, 比如 索引（A）是索引（A, B）的冗余索引, 因为后者是前者的前缀索引.<br>  （A, B）&lt;- （A）            冗余<br>  （A, B）&lt;- （B, A）或（B）  非冗余<br>  （A）   &lt;- （A, 主键）      冗余  因为对 InnoDB 来说主键列已经包含在二级索引中了, 所以也是冗余的.<br>其他不同类型的索引也不会是 B-Tree 索引的冗余索引, 无论覆盖的索引列是什么.<br>表中的索引越多, 数据插入速度就会越慢, .</p></li><li><p>未使用的索引<br>利用工具删除</p></li><li><p>索引和锁<br>即是使用了索引, InnoDB 也可能锁住一些不需要的数据.<br>InnoDB 在二级索引上使用共享（读）锁, 但访问主键索引需要排他（写）锁, 这消除了使用覆盖索引的可能性.</p></li></ul><h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="使用-EXPLAIN-进行分析"><a href="#使用-EXPLAIN-进行分析" class="headerlink" title="使用 EXPLAIN 进行分析"></a>使用 EXPLAIN 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。<br>比较重要的字段有：</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><p>1、减少请求的数据量</p><ul><li>只返回必要的列：最好不要使用 SELECT * 语句</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的</li></ul><p>2、减少服务器端扫描的行数</p><p>最有效的方式是使用索引来覆盖查询。</p><h3 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h3><ol><li><p>切分大查询<br>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询</p></li><li><p>分解大连接查询<br>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p></li></ol><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询</li><li>减少锁竞争</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效</li></ul><h2 id="存储引擎（MyISAM-与-InnoDB）"><a href="#存储引擎（MyISAM-与-InnoDB）" class="headerlink" title="存储引擎（MyISAM 与 InnoDB）"></a>存储引擎（MyISAM 与 InnoDB）</h2><p>对于索引,<br>前者使用前缀压缩技术使得索引更小;<br>后者按照原数据格式进行存储.<br>前者通过数据的物理位置引用被索引的行;<br>后者根据主键引用被索引的行.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《数据库系统概念》、《高性能 MySQL》、《深入理解 MySQL》、《MySQL 技术内幕: InnoDB 存储引擎》等.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="https://antfaiz5z.github.io/categories/Reading/"/>
    
    
      <category term="MySQL" scheme="https://antfaiz5z.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>科学上网 与 路由器 All in One</title>
    <link href="https://antfaiz5z.github.io/2019/05/27/fqrouter/"/>
    <id>https://antfaiz5z.github.io/2019/05/27/fqrouter/</id>
    <published>2019-05-27T12:22:34.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>one for all.</p><a id="more"></a><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><h3 id="vps"><a href="#vps" class="headerlink" title="vps"></a>vps</h3><h3 id="shadowsocks-R-、V2Ray"><a href="#shadowsocks-R-、V2Ray" class="headerlink" title="shadowsocks(R)、V2Ray"></a>shadowsocks(R)、V2Ray</h3><h3 id="数字移民"><a href="#数字移民" class="headerlink" title="数字移民"></a>数字移民</h3><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><h3 id="路由器选购"><a href="#路由器选购" class="headerlink" title="路由器选购"></a>路由器选购</h3><h3 id="二级路由、软路由、旁路由、Mesh"><a href="#二级路由、软路由、旁路由、Mesh" class="headerlink" title="二级路由、软路由、旁路由、Mesh"></a>二级路由、软路由、旁路由、Mesh</h3><h3 id="openwrt、LEDE"><a href="#openwrt、LEDE" class="headerlink" title="openwrt、LEDE"></a>openwrt、LEDE</h3><h3 id="DNS、花生壳"><a href="#DNS、花生壳" class="headerlink" title="DNS、花生壳"></a>DNS、花生壳</h3><h3 id="NAS、内网穿透"><a href="#NAS、内网穿透" class="headerlink" title="NAS、内网穿透"></a>NAS、内网穿透</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;one for all.&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="router" scheme="https://antfaiz5z.github.io/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>《Redis 设计与实现》阅读笔记</title>
    <link href="https://antfaiz5z.github.io/2019/05/17/redis/"/>
    <id>https://antfaiz5z.github.io/2019/05/17/redis/</id>
    <published>2019-05-17T02:43:24.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>第 1 版, 此书基于 Redis 2.9.</p><a id="more"></a><h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><p>Redis 没有直接使用以下几种数据结构来实现键值对数据库, 而是基于这些数据结构创建了一个对象系统.<br>Redis 的每个键值对都是由对象组成, 键总是一个字符串对象, 值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象.</p><h3 id="sds"><a href="#sds" class="headerlink" title="sds"></a>sds</h3><p>Redis 使用 SDS 用作默认字符串表示, C 字符串只会作为字符串字面量用在一些无需对字符串进行修改的地方如打印日志.</p><p><img src="/images/redis-sds.png" alt></p><h3 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h3><p>链表 (双向无环) 是列表键的底层实现之一.</p><p><img src="/images/redis-list.png" alt></p><h3 id="dict-ht"><a href="#dict-ht" class="headerlink" title="dict/ht"></a>dict/ht</h3><p>Redis 的数据库使用字典来作为底层实现, 字典还是哈希键的底层实现之一.<br>字典 使用哈希表作为底层实现.<br>哈希表 使用链地址法 (separate chaining) 来解决键冲突.</p><p><img src="/images/redis-ht.png" alt></p><h3 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h3><p>Redis 使用跳跃表作为有序集合键的底层实现之一.<br>Redis 只在两个地方用到了跳跃表, 一个是实现有序集合键, 一个是在集群节点中用作内部数据结构.<br>每个跳跃表节点的层高都是 1~32 之间的随机数.<br>在同一跳跃表中, 多个节点可以包含相同的分值, 但每个节点的成员对象必须是唯一的.<br>跳跃表中的节点按照分值大小进行排序, 当分值相同时, 节点按照成员对象大小进行排序.</p><p><img src="/images/redis-sl.png" alt></p><h3 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h3><p>整数集合是集合键的底层实现之一.<br>证书集合的底层实现为数组, 这个数组以有序、无重复的方式保存几何元素, 在有需要的时候, 程序会根据新添加元素的类型，改变这个数组的类型. (类型有INSERT_ENC_INT16/32/64)<br>整数集合只支持升级操作, 不支持降级操作.</p><p><img src="/images/redis-intset.png" alt></p><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>压缩列表被用作列表键和哈希键的底层实现之一.<br>压缩列表是一种为节约内存而开发的顺序性数据结构.<br>压缩列表可以包含多个节点, 每个节点可以保存一个字节数组或整数值.<br>在压缩列表中添加新节点或者删除节点, 可能会引发连锁更新操作, 但这种操作出现的几率并不高.</p><p><img src="/images/redis-ziplist1.png" alt></p><p><img src="/images/redis-ziplist2.png" alt></p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>当我们称呼一个键为 “列表键” 时, 我们指的是 “这个数据库键所对应的值为列表对象”.</p><p>Redis 的对象系统实现了基于引用计数的内存回收机制, 继而实现了对象共享机制.<br>Redis 的对象带有访问时间记录信息, 可用于计算数据库键的空转时长, 在服务器启用了 maxmemory 功能的情况下, 空转时长较大的那些键可能会优先被服务器删除.</p><p>TYPE 命令返回数据库键对应的值对象的类型, 而不是键对象的类型.</p><p>字符串对象是 Redis 五种类型对象中唯一一种会被其他四种对象嵌套的对象.</p><p>Redis 只对包含整数值的字符串对象进行共享, 因为尽管共享更复杂对象可以节省更多内存, 但验证操作的时间复杂度也更高.</p><p>Redis 在初始化服务器时, 会预先创建一万个字符串对象用于共享, 包含从 0 至 9999 所有整数值.</p><h2 id="单机数据库"><a href="#单机数据库" class="headerlink" title="单机数据库"></a>单机数据库</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>过期键删除策略有定时删除、惰性删除、定期删除, Redis 采用的是后两种, 服务器可以很好地在合理使用 CPU 时间和避免浪费内存空间之间取得平衡.</p><h3 id="RDB-与-AOF-持久化"><a href="#RDB-与-AOF-持久化" class="headerlink" title="RDB 与 AOF 持久化"></a>RDB 与 AOF 持久化</h3><p>RDB 持久化通过保存数据库中的键值对来记录数据库状态, AOF (Append File Only) 持久化通过保存 Redis 服务器所执行的写命令来记录服务器状态.</p><p>由于 AOF 文件的更新频率比 RDB 文件更高, 所以如果服务器开启了 AOF 持久化功能, 服务器会优先使用 AOF 文件来还原服务器状态.</p><p>SAVE、BGSAVE (background) 命令用于生成 RDB 文件.<br>当 SAVE 命令执行时, Redis 服务器会被阻塞, 此时客户端所有命令请求都会被阻塞.<br>而 BGSAVE 命令的保存工作是由子进程执行的, 所以执行时 Redis 服务器仍可以响应客户端请求.<br>服务器在载入 RDB 文件期间, 会一直处于阻塞状态, 直到载入工作完成.<br>可通过 save 选项配置 BGSAVE 自动间隔性执行.</p><p>Redis 将 AOF 重写程序同样也是放到子程序中执行, 以达到两个目的：<br>1、子进程进行 AOF 重写期间, 服务器进程 (父进程) 可以继续处理命令请求.<br>2、子进程带有服务器进程的数据副本, 使用子进程而不是线程, 可以在避免使用锁的情况下,  保证数据的安全性.<br>但是使用子进程有一个问题, 子进程在进行 AOF 重写期间, 数据库状态可能发生改变, 从而使得重写后的 AOF 所保存的数据库状态已经是过时的了.<br>为了解决这种数据不一致问题, Redis 服务器设置了一个 AOF 重写缓冲区, 即用来记录重写期间的服务器执行的写命令, 当子进程重写完成后会调用一个信号处理函数通知父进程, 将 AOF 重写缓冲区中的内容写入新 AOF 文件中并原子地覆盖原有 AOF 文件, 使得新 AOF 文件所保存的数据库状态和服务器当前的数据库状态一致.</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Redis 服务器是一个事件驱动程序, 其中存在文件事件和时间事件两种事件类型.</p><p>文件事件包括可写事件与可读事件.<br>Redis 基于 Reactor 模式开发了自己的文件事件处理器 (file event handler), 采用单线程 I/O 多路复用.<br>如果一个套接字可读又可写的话, 服务器会先读再写.</p><p>时间事件包括定时事件与周期性事件<br>目前版本 (2.9) Redis  只使用周期性事件, 没有使用定时事件.<br>服务器将所有时间事件放入一个无序链表中, 每次需要遍历查找整个链表中已到达的时间事件, 但无序并不影响时间事件处理器的性能.</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区内, 每个客户端状态都有两个输出缓冲区可用, 一个大小固定, 一个大小可变 (通过使用链表连接多个字符串对象), 前者用于保存那些长度较小的回复 (比如 OK, 简短的字符串值, 整数值, 错误回复等等), 后者用于保存那些长度较大的回复.</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>serverCron 函数默认以每 100 毫秒一次的频率更新 unixtime 和 mstime, 所以其精度并不高.<br>服务器只会在打印日志、更新服务器的 LRU 时间、决定是否执行持久化任务、计算服务器上线时间这类对时间精确度要求不高的功能上使用 unixtime 和 mstime.<br>对于为键设置过期时间、添加慢查询日志这种需要高精度时间的功能来说, 服务器还是会再次执行系统调用, 从而获得最准确的系统当前时间.</p><p>Redis 将服务器进程的 SIGTERM 信号关联到信号关联处理器 sigtermHandler 函数. 服务器在关闭自身之前会进行 RDB 持久化操作, 这也是服务器拦截 SIGTERM 信号的原因, 如果服务器一接到 SIGTERM 信号就立即关闭, 那它就没办法进行持久化操作了.</p><h2 id="多机数据库"><a href="#多机数据库" class="headerlink" title="多机数据库"></a>多机数据库</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>部分重同步通过复制偏移量、复制积压缓冲区、服务器运行 ID 三个部分实现.<br>复制积压缓冲区是由主服务器维护的一个固定长度的 FIFO 队列.</p><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>Sentinel 本质上是一个运行在特殊模式下的 Redis 服务器.</p><p>Sentinel 在连接主服务器或从服务器时, 会同时创建命令连接和订阅连接, 但是在连接其他 Sentinel 时却只会创建命令连, 而不创建订阅连接.<br>其中命令连接用于向主服务器发送命令请求, 而订阅连接则用于接收指定频道的消息.</p><p>用户设置的 down-after-milliseconds 选项的值, 不仅会被 Sentinel 用来判断主服务器的主观下线状态, 还会被用于判断主服务器属下的所有从服务器, 以及所有同样监视这个主服务器的其他 Sentinel 的主观下线状态.</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>Redis 集群是 Redis 提供的分布式数据库方案, 集群通过分片 (sharding) 来进行数据共享, 并提供复制和故障转移功能.<br>一个集群通常由多个节点 (node) 组成, 一个节点就是运行在集群模式下的 Redis 服务器.</p><h2 id="独立功能"><a href="#独立功能" class="headerlink" title="独立功能"></a>独立功能</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Redis 的事务和传统的关系型数据库事务最大的区别在于, Redis 不支持事务回滚机制, 即使事务队列中的某个命令在执行期间出现了错误, 整个事务也会继续执行下去.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><ul><li><p><a href="https://github.com/Weiwf/redis-mindmap" target="_blank" rel="noopener">通过思维导图整理 redis 的重要知识点</a></p></li><li><p><a href="https://github.com/Snailclimb/JavaGuide/tree/master/docs/database/Redis" target="_blank" rel="noopener">JavaGuide 中关于 redis 的总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第 1 版, 此书基于 Redis 2.9.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="https://antfaiz5z.github.io/categories/Reading/"/>
    
    
      <category term="Redis" scheme="https://antfaiz5z.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《STL 源码剖析》阅读笔记</title>
    <link href="https://antfaiz5z.github.io/2019/04/29/stl-source/"/>
    <id>https://antfaiz5z.github.io/2019/04/29/stl-source/</id>
    <published>2019-04-29T09:01:15.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>本书针对于 SGI STL.</p><a id="more"></a><h2 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h2><h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>最常用到的迭代器相应型别有五种:</p><ul><li>value type</li><li>difference type</li><li>pointer</li><li>reference</li><li>iterator category</li></ul><p>针对最后一种型别, 根据移动特性和施行措施, 迭代器被分为五类:</p><ul><li>Input Iterator<br>  (struct input_iterator_tag)</li><li>Output Iterator<br>  (struct output_iterator_tag)</li><li>Forward Iterator<br>  (struct forward_iterator_tag)</li><li>Bidirectional Iterator<br>  (struct bidirectional_iterator_tag)</li><li>Random Access Iterator<br>  (struct random_access_iterator_tag)</li></ul><p><img src="/images/iterator.png" alt="各迭代器继承关系"></p><p>原生指针是一种 Random Access Iterator.</p><p>traits 编程技法大量运用于 STL 实现品中. 它利用”内嵌型别”的编程级别与编译器的 template 参数推导功能, 增强 C++ 未能提供的关于型别认证方面的能力, 弥补 C++ 不为强型别 (strong typed) 语言的遗憾.</p><p>iterator_traits 负责萃取迭代器的特性, __type_traits 负责萃取型别 (type) 的特性. 此处关注的型别特性是指, 这个型别是否具有 default cto？ 是否具有 non-trivial copy ctor？ 是否具有 non-trivial assignment operator? 是否具有 non-trivial dtor? 等. 如果答案是否定的, 在对这个型别进行构造、析构、拷贝、赋值操作时, 就可以采用内存直接处理操作如 malloc()、memcpy 等, 获得最高效率.</p><ul><li>__type_traits&lt;T>::has_trivial_constructor</li><li>__type_traits&lt;T>::has_trivial_copy_constructor</li><li>__type_traits&lt;T>::has_trivial_assignment_operator</li><li>__type_traits&lt;T>::has_trivial_destructor</li><li>__type_traits&lt;T>::is_POD_type</li></ul><p>上述式子的返回值不是只是简单的 bool 值, 而是空的结构体: struct <code>__true_type</code> 和 struct <code>__false_type</code>, 因为如此编译器可以做类型推导. 一般具现体 (general instantiation), 内含对所有型别都必定有效的保守值. 上述各个 has_trivial_xxx 及 is_POD_type 型别都被定义为 <code>__false_type</code>, 就是对所有型别都必定有效的保守值. 而对于 C++ 基本型别 (char、int、unsigned int 等) 在 &lt;type_traits.h&gt; 中提供特化版本, 上述每一个成员的值都是 <code>__true_type</code>, 表示这些型别可以采用最快速方式 (例如 memcpy) 来进行拷贝或赋值操作.</p><h2 id="container"><a href="#container" class="headerlink" title="container"></a>container</h2><p><img src="/images/container.png" alt="SGI STL 的各种容器 (以内缩方式表示基层与衍生层关系)"></p><p>这里所谓的衍生并非派生 (inheritance) 关系, 而是内含 (containment) 关系. 例如<br>heap 内含一个 vector,<br>priority_queue 内含一个 heap,<br>stack 和 queue 内含一个 deque,<br>set/map/multiset/multimap 都内含一个 RB-tree,<br>hash_&lt;set/map/multiset/multimap&gt; 都内含一个 hashtable.</p><h3 id="sequence-containers"><a href="#sequence-containers" class="headerlink" title="sequence containers"></a>sequence containers</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>vector 默认使用 alloc 作为空间配置器.<br>vector 的迭代器是普通指针, 也就是 Random Access Iterator.</p><p>增加新元素时若超过 capacity, 则 capacity 扩充至两倍 (不同 STL 实现此数字可不同), 若两倍仍不足则继续扩充. 容量的扩充必须经历”重新配置、元素移动、释放原空间”等过程.<br>重新配置: 如果原大小为 0, 则配置 1 (个元素大小), 不为 0 则配置为原来的两倍.<br>元素移动: 先将原 vector 从 start 至 position (插入点) 的部分拷贝至新 vector (此时新 vector 的 finish == position), 再将新 vector 从 finish 开始的剩余部分赋初值 x (原插入值), 接着 ++finish (相当于已将 x 插入), 最后将原 vector 从 position 开始的剩余部分拷贝至新 vector.<br>释放原空间: 调用 destroy() 和 deallocate().</p><p>在 push_back() 中因备用空间不够而调用的 insert_aux() 即是采用上述流程, 然而在 push_back() 中实际上插入点 position 已经等于 finish, 所以流程中后半部分的将 position 到 finish 部分进行拷贝是否必要有待商榷, 书中提到了译者侯捷对此也抱有疑问.</p><p>在 insert() 中便区分有三种情况: (finish - position) &gt; n、(finish - position) &lt;= n、备用空间不够， 其中 n 为插入个数. 第三种情况即是采用上述流程, 稍微不同的是中间是插入 n 个 x 而不是简单的 ++finish. 第一种情况直接将插入点后的元素向后拷贝 copy_backward(), 第二中情况先在 finish 之后填充 x 再 copy_backward() 再在 finish 之前覆盖 x.</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list 默认使用 alloc 作为空间配置器，并据此定义了一个 list_node_allocator.<br>list 不仅是一个双向链表, 还是一个环状双向链表, 所以它只需要一个指针便可以完整表现整个链表. 所以 list 提供的是 Bidirectional Iterator.</p><p>list 进行 insert() 和 spice() 操作都不会使迭代器失效 (而 vector 的插入操作可能会使内存重新配置而导致所有迭代器失效), 甚至 erase() 操作也只会使指向被删除元素的迭代器失效其他不受影响.</p><p>list 初始化时即有一个空白节点, begin() 初始时指向此, end() 始终指向于此.</p><p>(<code>p138</code>) ??? next = first // 修正区段范围</p><p>list 不能使用 STL 算法 sort(), 必须使用自己的 sort() 成员函数 (使用了快排<code>p142</code>), 因为前者只接受 RandomAccessIterator.</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque 没有所谓容量 (capacity) 概念, 因为它是以分段连续空间组合而成, 随时可以增加一段新的空间并链接起来.</p><p>deque 提供 Random Access Iterator, 但它的迭代器并不是普通指针, 其复杂度高 (实现代码分量比 vector 和 list 多得多).</p><p>中控器 map (非 STL 中的 map 容器), 一个 map 要管理多个节点, 最少8个, 最多是 “所需节点数加 2”(前后各预留一个, 扩充时可用).</p><p>(<code>p151</code>) ??? __deque_iterator&lt;&gt; 没有为 (finish -1) 定义运算子.<br>         ??? // 下行最后有两个 ‘;’, 虽奇怪但符合语法</p><p>deque 自行定义了两个专属的空间配置器: data_allocator (每次配置一个元素大小)、map_allocator (每次配置一个指针大小)</p><p>deque 的最初状态 (无任何元素时) 保留有一个缓冲区, y因此 clear() 完成后恢复初始状态也一样保留一个缓冲区：若 start 与 finish 在不同缓冲区, 将除头缓冲区与尾缓冲区之外的缓冲区内的所有元素析构并释放缓冲区内存, 再将头尾缓冲区的元素析构并释放尾缓冲区的内存而保留头缓冲区; 若 start 与 finish 在同一缓冲区, 则析构这唯一缓冲区所有元素并保留此缓冲区.</p><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>SGI STL 默认以 deuqe 作为 stack 的底部结构 (以 list 同样可以做到), 因此其实现非常简单. 往往被归类为容器配接器.</p><p>stack 不提供遍历功能, 也不提供迭代器.</p><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>SGI STL 默认以 deuqe 作为 queue 的底部结构 (以 list 同样可以做到), 因此其实现非常简单. 往往被归类为容器配接器.</p><p>queue 不提供遍历功能, 也不提供迭代器.</p><h4 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h4><p>heap 不属于 STL 容器组件, 扮演 priority_queue 的助手. priority_queue 的复杂度最好介于 queue 与 binary search tree 之间, 因此 binary heap 便是这种条件下的适当候选人. 所谓 binary heap 就是一种 complete binary tree.</p><p>一种 array 隐式表述 tree 的方式: 将 array 的 #0 元素保留, 那么当某个节点位于 array 的 #i 处, 它的左子节点位于 #2i 处, 右子节点位于 #2i +1处, 父节点位于 #i/2 处.</p><p>推荐使用 vector 而不是 array, array无法动态改变大小, 因此不可以对满载的 array 进行 push_heap() 操作.</p><p>按照元素排列方式, heap 可分为 max-heap 和 min-heap, STL 提供的是 max-heap.</p><p>heap 不提供遍历功能, 也不提供迭代器.</p><h5 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap()"></a>push_heap()</h5><p>percolate up (上溯)：<br>新加入的元素首先一定放在最下一层作为叶节点, 填补在从左至右第一个空格, 也就是插入到 vector 的 end() 处.<br>为满足 mxa-heap 的条件 (每个节点的键值都大于等于其子节点键值), 如果键值比父节点大, 就父子对换键值, 直到不需对换或到根节点为止.</p><p>该函数接受两个迭代器用来表现 heap 底部容器 vector 的头尾, 并且前提是新元素已插入到 end().</p><p>(<code>p175</code>) ??? parent = (holeIndex - 1) /2<br>意味着具体实现并不是如上所述将 #0 保留的隐式表述法?</p><h5 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap()"></a>pop_heap()</h5><p>percoalte down (下溯)：<br>pop_heap() 操作取走根节点 (具体实现中是首先将根节点与最右下节点键值对换, 最后用 pop_back() 原根节点, pop_heap() 中未调用 pop_back()), 任务是将最右下的元素重新找一个合适的位置, 首先将其填入根节点位置, 再与左右子节点比较键值, 如果其键值较小, 则与较大子节点对换键值, 直到不需对换或下放到叶节点为止.</p><p>该函数接受两个迭代器用来表现 heap 底部容器 vector 的头尾.</p><p>(<code>p177</code>) ??? 未比较 value 与左右子节点键值大小<br>总是小于右子节点？</p><h5 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap()"></a>sort_heap()</h5><p>多次 pop_heap() 且每次操作范围从后向前缩减一个元素 (pop_heap() 会将最大元素放在底部容器最尾端), 最后便得到一个递增序列. 排序过后, 原来的 heap 就不是一个合法的 heap 了.</p><p>该函数接受两个迭代器用来表现 heap 底部容器 vector 的头尾.</p><h5 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap()"></a>make_heap()</h5><p>这个算法用来将一段现有的数据转化为一个 heap, 主要依据前文所述的隐式表述法.</p><p>(<code>p180</code>) ??? parent = (len -2) /2<br>最后一层叶子节点在后续的 adjust_heap() 中自然会归于上下有序.</p><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>priority_queue 默认使用一个 max-heap 完成.</p><p>SGI STL 默认以 vector 作为 priority_queue 的底部结构, 再加上 heap 处理规则, 因此其实现非常简单. 往往被归类为容器配接器.</p><p>priority_queue 不提供遍历功能, 也不提供迭代器.</p><p>构造函数调用 make_heap();<br>push() 先后调用 push_back()、push_heap();<br>pop() 先后调用 pop_heap()、pop_back();</p><h4 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h4><p>SGI STL 提供单向链表, 不在标准之内.</p><p>slist 和 list 的主要区别在于前者的迭代器属于 Forward Iterator, 而后者为 Bidirectional Iterator.</p><p>基于效率考虑, slist 特别提供了 insert_after() 和 erase_after(), 并不提供 push_back(), 只提供 push_front().</p><p>??? end() 指向空, 不是如 list 一般的空节点.</p><h3 id="associative-containers"><a href="#associative-containers" class="headerlink" title="associative containers"></a>associative containers</h3><p>RB-tree 有自动排序功能, 而 hashtable 没有. 意味着 [multi]&lt;set/map&gt; 有自动排序功能, 而 hash_[multi]&lt;set/map&gt; 没有. 如果表格足够大, 后者可出现排序假象.</p><h4 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h4><p>为了更大的弹性, SGI 将 RB-tree 迭代器实现为两层 (双层节点结构与双层迭代器结构设计), 这种设计理念和 slist 类似.</p><p>RB-tree 迭代器属于 Bidrectional Iterator, 其提领操作和成员访问操作与 list 十分相似.</p><p>(<code>p216</code>) ??? node-&gt;parent-&gt;parent = node<br>实现上的技巧: header-&gt;parent == root; root-&gt;parent == header; header-&gt;left == leftmost; header-&gt;right == rightmost;<br>??? RB-tree 的 begin() == leftmost; end() == header;<br>RB-tree 初始化时产生一个 header 节点空间, 令其为红色, header 左右子节点为自己.</p><p>RB-tree 一开始即要求用户必须明确设定所谓的 KeyOfValue 仿函数, 从实值 (value) 取出键值 (key).</p><p>(<code>p224</code>) !!! insert_unique()<br>             __rb_tree_rebalance()</p><h4 id="multi-lt-set-map-gt"><a href="#multi-lt-set-map-gt" class="headerlink" title="[multi]&lt;set/map&gt;"></a>[multi]&lt;set/map&gt;</h4><p>set\<t>::iterator 被定义为底层 RB-tree 的 const_iterator, 杜绝写入操作, 也就是说, set 的 iterator 是一种 constant iterator, 相对于 mutable iterator 来说.<br>map 的键值不可改变, 实值可以改变, 因此 map 的 iterator 既不是 constant iterator 也不是 mutable iterator.</t></p><p>几乎所有的 set、map 操作行为都只是转调 RB-tree 的操作行为而已.</p><p>set、map 一定使用 RB-tree 的 insert_unique(), multiset、multimap 才使用 RB-tree 的 insert_equal().</p><p><code>template &lt;... class Compare = less&lt;key&gt; ...&gt;</code>: 默认采用递增排序.</p><p>面对关联容器, 应该使用其所提供的 find 函数来搜寻元素, 会比使用 STL 的算法 find() 更有效率, 因为后者只是循序搜寻.</p><h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><p>bst 具有对数平均时间的表现, 而 hashtable 具有常数平均时间的表现, 且这种表现是以统计为基础, 不需仰赖输入元素的随机性.</p><p>包括有: 线性探测 (linear probing)、二次探测 (quadratic probing)、开链 (separate chaining)<br>前二者负载系数永远在 0~1 之间, 而开链策略可以大于 1.<br>SGI STL 的 hashtable 便是采用 开链.</p><p>元素的删除必须采用惰性删除, 也就是只标记删除记号, 实际删除操作则待表格重新整理 (rehashing) 时再进行, 这是因为hashtable 中每个元素不仅表述自己, 也关系到其他元素的排列.<br>二次探测主要用来解决主集团 (primary clustering) 的问题, 但却可能造成次集团 (secondary clustering) 的问题 (两个元素经 hash function 计算出来的位置若相同, 则插入时所探测的位置也相同, 造成某种浪费), 当然消除次集团的办法也有, 例如复式散列 (double hashing). 如果我们假设表格大小为<code>质数</code>, 而且永远保持负载系数在 0.5 以下, 那么就可以确定每插入一个新元素所需要的探测次数不多于 2.</p><p>在 SGI STL 中采用开链策略的 hashtable 中, buckets 以 vector 完成, bucket 所维护的链表, 并不采用 STL 的 list 或 slist, 而是自行维护 struct __hashtable_node.<br>迭代器为 Forward Iterator, operator++ 操作为 尝试访问当前节点的 next, 非空即是结果, 否则即是链表的尾端, 就跳至下一个 bucket.<br>虽然开链法不要求表格大小必须为质数, 但 SGI STL 仍然以质数来设计表格大小, 并且先将 28 个质数 (逐渐呈现约两倍的关系, 53、97、193、389…) 计算好, 以备随时访问.<br>插入行为可 insert_unique() (对应于非 multi) 与 insert_equal() (对应于 multi).<br>“表格重建与否”的判断原则为: 拿元素个数 (包括新增元素) 和 bucket vector 的大小比较, 如果前者大于后者就重建表格. 重建时, 先建立一个新 bucket vector, 将每个节点重新计算应该落在哪个 bucket 上后转移到新 bucket vector 上,最后与旧 bucket vector 进行 swap().</p><p>hashtable.size() 变化, 而不一定等于 hashtable.bucket_count(), 后者发生重建时变化.</p><p>SGI hashtable 无法处理 string (char* 却可以)、double、float 这些型别 (insert() 时才出错), 欲处理这些型别, 用户必须自行为它们定义 hash function.</p><h4 id="hash-multi-lt-set-map-gt"><a href="#hash-multi-lt-set-map-gt" class="headerlink" title="hash_[multi]&lt;set/map&gt;"></a>hash_[multi]&lt;set/map&gt;</h4><p>hash_[multi]&lt;set/map&gt; 默认表格大小为 100 (根据 STL 的设计, 采用质数 193).</p><h2 id="algorithms"><a href="#algorithms" class="headerlink" title="algorithms"></a>algorithms</h2><p><code>#include &lt;numeric&gt;</code> <code>#include &lt;algorithm&gt;</code></p><p>质变算法, 诸如拷贝 (copy)、互换(swap)、替换(replace)、填写(fill)、删除(remove)、排列组合(permutation)、分割(partition)、随机重排(random shuffing)、排序(sort).<br>如果将此类算法运用于一个常数区间上, 编译器将会报错.<br>非质变算法, 诸如查找 (find)、匹配 (search)、计数 (count)、巡访 (for_each)、比较 (equal, mismatch)、寻找极值 (max, min).</p><p>所有泛型算法的前两个参数都是一对迭代器 [first, last), 必要条件是能够经由 increment 操作符的反复运用从 first 到达 last, 而编译器本身无法强求这一点, 如果不成立将会导致不可预期的结果.</p><p>将无效或者说不匹配的迭代器传给某个算法, 虽然是一种错误, 但却不能保证在编译期就能够被捕捉, 因为所谓”迭代器类型”并不是真正的型别, 它们只是一种型别参数 (type parameters).</p><h2 id="functors-function-objects"><a href="#functors-function-objects" class="headerlink" title="functors / function objects"></a>functors / function objects</h2><p><code>#include &lt;functional&gt;</code></p><p>虽然函数指针可以达到”将整组操作当做算法的参数”, 但其不能满足 STL 对抽象性的要求, 且无法和 STL 其他组件 (如 adapter) 搭配, 产生更灵活的变化.</p><p>仿函数按操作数 (operand) 个数分为 一元和二元 (STL 不支持三元仿函数), 按功能分为 算术运算 (Arithmetic)、关系运算 (Rational)、逻辑运算 (Logical).</p><p>证同 (identity)、选择 (select)、投射 (project) 仿函数并不在 C++标准规格之内, 但它们常常存在于各个实现品中作为内部使用<br>证同: 直接返回参数. 在 …set 中用来指定 RB-tree 所需的 KeyOfValue op, 因为 set 的键值即其实值.<br>选择: 接收 pair, 直接返回 first 或 last. 在 …map 中用来指定 RB-tree 所需的 KeyOfValue op, 因为 map 的键值即 pair 的 first.<br>投射: 接收两个参数, 直接返回第一参数或第二参数.</p><h2 id="adapters"><a href="#adapters" class="headerlink" title="adapters"></a>adapters</h2><p>container adapters: 包括 queue 和 stack 即是修饰 deque 的接口而成.<br>iterator adapters: 包括 insert iterator、reverse iterator、iostream iterator.<br>functor/funciton adapters: 配接操作包括 绑定 (bind)、否定 (negate)、组合 (compose).</p><p>所有期望获得配接能力的组件, 本身必须是可配接的 (adaptable). 换句话说, 一元仿函数必须继承自 unary_function, 二元仿函数必须继承自 binary_function, 成员函数必须以 mem_fun 处理过, 一般函数必须以 ptr_fun 处理过. 一个未经 ptr_fun 处理过的一般函数, 虽然也可以函数指针的形式传给 STL 算法使用, 却无法拥有任何配接能力.</p><p>insert iterator 有三种: back_insert_iterator、front_insert_iterator、insert_iterator, 其 iterator_category 都为 output_iterator_tag;<br>reverse_iterator<iterator> 的 5 种相应型别都与其对应的正向迭代器相同;<br>istream_iterator 的 iterator_category 为 input_iterator_tag;<br>ostream_iterator 的 iterator_category 为 output_iterator_tag.</iterator></p><p><img src="/images/riterator.png" alt="reverse iterator"></p><p>container adapter 内藏了一个 container member;<br>insert iterator   内藏了一个 pointer to container (并因而取得其 iterator);<br>reverse iterator  内藏了一个 iterator number;<br>stream iterator   内藏了一个 pointer to stream;<br>function adapter  内藏了一个 member object, 其型别等同于它所要配接的对象 (这个对象当然是一个 adaptable functor).</p><p>源码中经常出现的 pred 一次, 是 predicate 的缩写, 意指会返回真假值 (bool)  的表达式.</p><h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>容器以 class template 完成;<br>算法以 function templates 完成;<br>仿函数是一种将 operator() 重载的 class template;<br>迭代器是一种将 operator++ 和 operator* 等指针习惯常行为重载的 class template;<br>配接器中的 container adapter 和 iterator adapter 都是一种 class template, 而 function adapter.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本书针对于 SGI STL.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="https://antfaiz5z.github.io/categories/Reading/"/>
    
    
      <category term="STL" scheme="https://antfaiz5z.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++ 相关书籍阅读笔记</title>
    <link href="https://antfaiz5z.github.io/2019/04/26/effective-cpp/"/>
    <id>https://antfaiz5z.github.io/2019/04/26/effective-cpp/</id>
    <published>2019-04-26T06:23:29.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>《Effective C++》、《Effective Modern C++》、《C++ Concurrency In Action》、《Essential C++》、《More Effective C++》等.</p><a id="more"></a><h2 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h2><h2 id="Effective-Modern-C"><a href="#Effective-Modern-C" class="headerlink" title="Effective Modern C++"></a>Effective Modern C++</h2><h3 id="Item-3-理解-decltype"><a href="#Item-3-理解-decltype" class="headerlink" title="Item 3: 理解 decltype"></a>Item 3: 理解 decltype</h3><p>decltyp e大多数情况下总是不加修改地产出变量和表达式的类型, 对于 T 类型的 lvalue 表达式, decltype 总是产出 T&amp;.</p><p>C++14 支持 decltype(auto), 和auto一样, 他从一个初始化器中推导类型, 只不过使用的是 decltype 类型推导规则. 这一开始看起来可能有点矛盾的东西确实完美地结合在一起：auto明确了类型需要被推导, decltype 明确了推导时使用 decltype 推导规则.</p><p>在 C++11 中，也许 decltype 最主要的用途就是用来声明 返回值类型依赖于参数类型的 函数模板.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line">cosnt Widget&amp; cw = w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw;</span><br><span class="line"><span class="comment">//myWidget1的类型是Widget</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw</span><br><span class="line"><span class="comment">//myWidget2的类型是const Widget&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) f1()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x;   <span class="comment">//decltypex(x)是int，所以f1返回int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) f2()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (x); <span class="comment">//decltype((x))是int&amp;，所以f2返回int&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//记住f2不仅仅是返回值和f1不同，它还返回了一个局部变量。这是一种把你推向未定义行为的陷阱代码</span></span><br></pre></td></tr></table></figure><p>rvalue 不能和 lvalue 引用绑定 (除非是 const 左值引用( lvalue-references-to-const ))</p><h3 id="Item-18-22-智能指针"><a href="#Item-18-22-智能指针" class="headerlink" title="Item 18-22: 智能指针"></a>Item 18-22: 智能指针</h3><p>auto_ptr 和 unique_ptr 采用的是 ownership (建立所有权) 概念, 对于特定对象, 只能被一个智能指针所拥有, 这样, 只有拥有该对象的智能指针的析构函数才会删除该对象, 然后要注意的是, 赋值操作会转让操作权.<br>虽然 auto_ptr 和 unique_ptr 都采用该策略, 但是 unique_ptr 的策略更严格. 当出现上述情况时, 程序会编译出错 (这是因为 unique_ptr 内部将拷贝构造函数给 delete 了, 但赋值是允许的), 而 auto_ptr 则会在执行阶段 core dumped.<br>shared_ptr 则采用 reference counting (引用计数) 的策略, 例如, 赋值时, 计数 +1, 指针过期时, 计数 -1. 只有当计数为 0 时, 即最后一个指针过期时, 才会被析构掉.</p><p>要安全的重用 unique_ptr 指针, 可给它赋新值. C++为其提供了 std::move() 方法. 而 auto_ptr 由于策略没有 unique_ptr 严格, 无需使用move方法. 由于 unique_ptr 使用了 C++11 新增的移动构造函数和右值引用, 所以可以区分安全和不安全的用法.</p><p>auto_ptr 和 shared_ptr 可以和 new 一起使用, 但不可以和 new[] 一起使用, 但是 unique_ptr 可以和 new[] 一起使用.</p><p>weak_ptr 是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少, 没有重载 * 和 -&gt; 但可以使用 lock() 获得一个可用的 shared_ptr 对象.<br>weak_ptr 的一个重要用途是通过 lock() 获得 this 指针的 shared_ptr, 使对象自己能够生产 shared_ptr 来管理自己, 但助手类 enable_shared_from_this 的 shared_from_this 会返回 this 的 shared_ptr, 只需要让想被 shared_ptr 管理的类从它继承即可.</p><p>当多个对象指向同一个对象的指针时, 应选择 shared_ptr.<br>用 new 申请的内存, 返回指向这块内存的指针时, 选择 unique_ptr 就不错.<br>unique_ptr 为右值(不准确的说类似无法寻址)时, 可以赋给shared_ptr.</p><h3 id="Item-23-理解-std-move-与-std-forward"><a href="#Item-23-理解-std-move-与-std-forward" class="headerlink" title="Item 23: 理解 std::move 与 std::forward"></a>Item 23: 理解 std::move 与 std::forward</h3><p>std::move 无条件将它的参数转化为 rvalue, 只作转换, 不作 move, 且建议参数为非 const 的 rvalue reference, 这是由于 const 的参数被转换成 const rvalue, 将会被传递给 copy constructor, 实际上并没有 “move”. 这样的行为对于保持const 的正确性是必须的. 从一个对象里 move 出一个值通常会改变这个对象, 所以语言不允许将 const 对象传递给像 move constructor 这样的会改变对象的函数.</p><p>std::forward 的情况和 std::move 相类似, 但 std::forward 是一个有条件的转换, 它只把用 rvalue 初始化的参数转换成 rvalue.</p><p>注意 std::move 只需要一个函数参数, 而 std::forward 却需要一个函数参数以及一个模板类型参数. std::move 和 std::forward 在运行期都没有做任何事情.</p><h2 id="C-Concurrency-In-Action"><a href="#C-Concurrency-In-Action" class="headerlink" title="C++ Concurrency In Action"></a>C++ Concurrency In Action</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>join_threads类的实例(来自于第8章)③用来汇聚所有线程。当然也需要析构函数：仅设置done标志⑪，并且join_threads确保所有线程在线程池销毁前全部执行完成。注意成员声明的顺序很重要：done标志和worker_queue必须在threads数组之前声明，而数据必须在joiner前声明。这就能确保成员能以正确的顺序销毁；比如，所有线程都停止运行时，队列就可以安全的销毁了。</p><h2 id="Essential-C"><a href="#Essential-C" class="headerlink" title="Essential C++"></a>Essential C++</h2><h2 id="More-Effective-C"><a href="#More-Effective-C" class="headerlink" title="More Effective C++"></a>More Effective C++</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Effective C++》、《Effective Modern C++》、《C++ Concurrency In Action》、《Essential C++》、《More Effective C++》等.&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="https://antfaiz5z.github.io/categories/Reading/"/>
    
    
      <category term="effective" scheme="https://antfaiz5z.github.io/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>面试问题整理</title>
    <link href="https://antfaiz5z.github.io/2019/03/21/interview/"/>
    <id>https://antfaiz5z.github.io/2019/03/21/interview/</id>
    <published>2019-03-21T07:37:13.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对于 C++ 面试中常见问题进行整理并尽量作口语化而非书面化的回答。</p><a id="more"></a><p>本文转移至 github 仓库 <a href="https://github.com/antFaiz5z/Interview-Questions" target="_blank" rel="noopener">Interview-Questions</a></p><p><img src="/images/all.png" alt="思维导图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要针对于 C++ 面试中常见问题进行整理并尽量作口语化而非书面化的回答。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="interview" scheme="https://antfaiz5z.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>使用 LaTeX 进行学术写作</title>
    <link href="https://antfaiz5z.github.io/2019/01/10/latex/"/>
    <id>https://antfaiz5z.github.io/2019/01/10/latex/</id>
    <published>2019-01-10T04:56:17.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<pre><code>待填坑.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;待填坑.
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="Academic" scheme="https://antfaiz5z.github.io/categories/Academic/"/>
    
    
      <category term="latex" scheme="https://antfaiz5z.github.io/tags/latex/"/>
    
      <category term="tex live" scheme="https://antfaiz5z.github.io/tags/tex-live/"/>
    
  </entry>
  
  <entry>
    <title>利用 Travis CI 自动部署博客</title>
    <link href="https://antfaiz5z.github.io/2018/11/30/travis/"/>
    <id>https://antfaiz5z.github.io/2018/11/30/travis/</id>
    <published>2018-11-30T04:22:36.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续集成到共享主线（mainline）的一种举措。</p></blockquote><p>简单来说，我们通过持续集成，能够简化 Hexo 发布博客的步骤，即：将清除缓存 hexo clean，生成静态文件 hexo generate 和部署到 GitHub Pages hexo deploy 这些步骤通过持续集成工具来帮助我们自动执行。</p><p>这样我们在本地对博客文件进行修改、新增博文内容或者新增博客文章，只需要通过 git 推送到 GitHub 仓库之后，持续集成工具就可以帮助我们在线构建博客静态文件并直接部署到 GitHub Pages。这之后，我们发布博客内容就不需要本地三步走了。</p><h3 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h3><p>我们所利用的持续集成平台是 Travis CI.<br>首先，我们到 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 官网，用自己的 GitHub 账户直接关联登录，并允许 Travis CI 查看自己的公有仓库。</p><p>然后我们到 Travis CI 账户页面 开启我们的博客仓库。</p><h3 id="配置持续集成文件"><a href="#配置持续集成文件" class="headerlink" title="配置持续集成文件"></a>配置持续集成文件</h3><p>.travis.yml 是 Travis CI 的部署配置文件，Travis CI 部署时会自动读取我们每次 Commit 中是否包含 .travis.yml，有此文件才会开始部署。</p><p>在博客项目源代码分支下创建文件 .travis.yml，并添加如下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">whopro</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">export</span> <span class="string">TZ='Asia/Shanghai'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span> <span class="bullet">-g</span> <span class="string">cnpm</span> <span class="bullet">--registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cnpm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="bullet">-g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  provider:</span> <span class="string">pages</span></span><br><span class="line"><span class="attr">  skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  github_token:</span> <span class="string">$GITHUB_TOKEN</span></span><br><span class="line"><span class="attr">  local_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$GIT_NAME</span></span><br><span class="line"><span class="attr">  email:</span> <span class="string">$GIT_EMAIL</span></span><br><span class="line"><span class="attr">  keep-history:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  target-branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  on:</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">whopro</span></span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><p>language：编译语言、环境；</p></li><li><p>node_js：Node.js 版本；</p></li><li><p>sudo：需要管理员权限；</p></li><li><p>install：安装环境 npm；</p></li><li><p>branches：工作仓库分支（hexo 分支）；</p></li><li><p>before_install：配置时区为中国时区东八区（UTC + 8），安装组件 hexo；</p></li><li><p>install：安装依赖 npm install；</p></li><li><p>script：执行脚本，清除缓存，生成静态文件并放在 public 文件夹下；</p></li><li><p>deploy：执行部署。</p></li></ul><blockquote><p>其他文档可能提到了利用 hexo-deployer-git 进行部署，但是由于 Travis CI 本身支持直接部署到 GitHub Pages 的工具，因此无需另行安装 hexo-deployer-git 了；<br><br>其他文档也可能提到在 .travis.yml 中加入如下内容，来缓存 node_modules 下的内容，从而加快编译速度。但是经过我的尝试，node_modules 经常会由于没有及时更新，在添加其他组件之后出现「博客生成静态文件步骤」失败的情况，因此建议不进行缓存处理。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules</span></span><br></pre></td></tr></table></figure><h3 id="在-Travis-CI-中配置变量"><a href="#在-Travis-CI-中配置变量" class="headerlink" title="在 Travis CI 中配置变量"></a>在 Travis CI 中配置变量</h3><p>在配置文件中我们使用了三个变量：</p><ul><li><p>$GIT_NAME：git 用户名</p></li><li><p>$GIT_EMAIL：git 用户邮箱</p></li><li><p>$GITHUB_TOKEN：GitHub 通行证 (token) 字符串</p></li></ul><p>最后一项 GitHub 通行证 (token) 我们在 GitHub 中进行申请：</p><p>访问 GitHub 账户设置 &gt; Tokens</p><p>生成新 Token: Generate new token</p><p>填入 Token 描述，并给予 Token 第一项 repo 的全部权限</p><p>将生成的 Token 复制，保存（生成 Token 的页面只有一次机会看见，请保存妥当。）</p><p>在 Travis CI 仓库配置中，将三个变量填入设置（位于 Settings &gt; Environment Variables 处并保存：</p><p>在 Travis CI 仓库配置中，将三个变量填入设置（位于 Settings &gt; Environment Variables 处并保存：</p><p>这样，在每次我们将博客的源文件通过 git 推送到 GitHub 的 hexo 分支上后，Travis CI 就会自动检测并主动开始构建我们的博客静态文件，并自动部署到 GitHub Pages 中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续集成到共享主线（mainline）的一种举措。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，我们通过持续集
      
    
    </summary>
    
      <category term="CI" scheme="https://antfaiz5z.github.io/categories/CI/"/>
    
    
      <category term="hexo" scheme="https://antfaiz5z.github.io/tags/hexo/"/>
    
      <category term="travis" scheme="https://antfaiz5z.github.io/tags/travis/"/>
    
  </entry>
  
  <entry>
    <title>Back to Windows With WSL or CygWin ?</title>
    <link href="https://antfaiz5z.github.io/2018/11/27/wsl/"/>
    <id>https://antfaiz5z.github.io/2018/11/27/wsl/</id>
    <published>2018-11-27T03:07:09.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><p>初学 C/C++, 在windows上使用 codeblocks 写写算法甚是不错,  visual studio 宇宙最强 IDE 自然也是不虚(大概是太强了, 至今没有玩明白…).</p><p>后接触 linux  开发, 便使用上了 vmware , 快照回滚、双机调试、镜像备份等特别适合于折腾 ubuntu 时环境复现、编译内核啥的.</p><p>之后看到了 deepin , 自带 wine 与软件商店尤适合于日常使用, 于是一直执着于纯 deepin 或是 deepin + windows 双系统.</p><p>现觉, linux 总是会出现各种兼容性问题比如显卡驱动、办公软件等, 诚然, linux 的斜杠与 LF 和 windows 的反斜杠与 CRLF 相比, “人类”与”反人类”必定是前者令人心驰神往, 但时常由于工作场景需要在双系统或双机器间来回切换总归令人不快, 便寻摸着如何回归 windows…</p><p>其实, cmake、git、docker、node等一直都有提供 windows 平台对应的十分成熟的软件，甚至提供 GUI 工具, 于是问题便在于可编写跨平台程序的 C/C++ 编译器.</p><h2 id="几种方案"><a href="#几种方案" class="headerlink" title="几种方案"></a>几种方案</h2><h3 id="CygWin"><a href="#CygWin" class="headerlink" title="CygWin"></a>CygWin</h3><p>MinGW 与 CygWin 都能让你在 windows 下编译 unix 风格的 C/C++ 代码. MinGW 与 CygWin 的区别:</p><ol><li>修改编译器, 让 windows 下的编译器把诸如 fork 的调用翻译成等价的形式, 这就是 MinGW 的做法.</li><li>修改库, 让 windows 提供一个类似 unix 提供的库,他们对程序的接口如同 unix 一样, 而这些库当然是由 win32 的 API 实现的, 这就是 CygWin 的做法.</li></ol><p>CygWin 与 MinGW 的最大区别在于：使用 CygWin 可以在 windows 下调用 unix-like 的 API （如fork、spawn、signals、select、sockets 等）. 但是如果调用了 unix 特有的 API 函数, 在 windows 环境下不能正常运行, 如果想在 windows 下正常运行的，就必须依赖 cygwin1.dll , 速度上会有些影响.</p><p>而用 MinGW 编译出来的程序, 如果源代码里面调用了 unix 环境的 API , 则 MinGW 会把这些对 UNIX 的 API 调用翻译成 win32 下等价的形式. 同时这个程序是不能在 windows 下运行的.</p><p>如果你是想在 windows 环境下开发 linux 运行程序, 那么 CygWin 是你的不二之选. 而如果你想开发的是 windows 运行程序, 并且追求速度, 那么二者相比而言, MinGW 是更好的选择.</p><h3 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h3><p>全称 Windows Subsystem for Linux</p><p>如今可在 windows 10 应用商店直接下载安装多个版本的 linux .</p><h4 id="初次安装配置"><a href="#初次安装配置" class="headerlink" title="初次安装配置"></a>初次安装配置</h4><p>1、设置 -&gt; 开发者选项 -&gt; 开发人员模式</p><p>2、控制面板 -&gt; 程序 -&gt; 启用或关闭Windows功能  -&gt; 适用于Linux的Windows子系统</p><p>3、Microsoft Store 下载安装任意版本Linux</p><p>4、PowerShell（管理员）（Win + X） -&gt;  <code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code> -&gt; 重启</p><h4 id="使用-wslconfig-命令进行管理"><a href="#使用-wslconfig-命令进行管理" class="headerlink" title="使用 wslconfig 命令进行管理"></a>使用 wslconfig 命令进行管理</h4><ol><li>设置默认运行的 linux 系统</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /setdefault &lt;DistributionName&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>卸载 linux 系统</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /unregister &lt;DistributionName&gt;</span><br></pre></td></tr></table></figure><p>当系统出现问题，我们可以卸载后重新安装。如：wslconfig /unregeister ubuntu</p><ol start="3"><li>查看已安装的 linux 系统</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /list</span><br></pre></td></tr></table></figure><h4 id="文件系统互相访问"><a href="#文件系统互相访问" class="headerlink" title="文件系统互相访问"></a>文件系统互相访问</h4><ol><li>WSL中访问本地文件</li></ol><p>在“/mnt”目录下有“c”、“d”、“e”等文件夹, 分别表示本地的 C 盘、D 盘、E 盘.</p><ol start="2"><li>本地访问 WSL 的根目录</li></ol><p><code>C:\Users\XXXX\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs</code></p><p>不过不建议在外部直接对其文件进行编辑、新建等操作，因为会出现一些问题。</p><h2 id="安装图形界面"><a href="#安装图形界面" class="headerlink" title="安装图形界面"></a>安装图形界面</h2><ul><li><a href="http://csuncle.com/2017/08/08/Windows-linux%E5%AD%90%E7%B3%BB%E7%BB%9F-%E5%85%A5%E9%97%A8%E5%88%B0GUI/" target="_blank" rel="noopener">Windows linux子系统–入门到GUI</a></li><li><a href="https://blog.csdn.net/novasliver/article/details/83190269" target="_blank" rel="noopener">Win10Linux子系统（WSL）图形界面的安装</a></li></ul><h2 id="Clion-与-WSL"><a href="#Clion-与-WSL" class="headerlink" title="Clion 与 WSL"></a>Clion 与 WSL</h2><p>利用 xServer 与 xLaunch 安装 WSL 的图形界面实际上是在本地利用 ssh 与子系统进行通信, 缺点是反应太慢．于是从常用工具同样是宇宙最强 IDE inteliJ 的开发商开发的 C/C++ IDE Clion 出发考虑其他方案．</p><ul><li><a href="http://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-clion.html" target="_blank" rel="noopener">JetBrains官方指导：Working with WSL Environment</a></li></ul><p>于是乎 Clion 采用的是子系统中的编译工具链, 完全无需考虑兼容性问题．</p><h3 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h3><p>windows 的终端界面和字体实在太丑, 可下载 cmder 工具．由于 WSL 已提供 bash, 于是下载 mini 版即可．</p><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><ul><li><p><a href="https://www.cnblogs.com/xiaoliangge/p/9134585.html" target="_blank" rel="noopener">在Linux的Windows子系统上(WSL)使用Docker（Ubuntu）</a></p></li><li><p><a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北（简体中文版）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;心路历程&quot;&gt;&lt;a href=&quot;#心路历程&quot; class=&quot;headerlink&quot; title=&quot;心路历程&quot;&gt;&lt;/a&gt;心路历程&lt;/h2&gt;&lt;p&gt;初学 C/C++, 在windows上使用 codeblocks 写写算法甚是不错,  visual studio 宇宙最强
      
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="WSL" scheme="https://antfaiz5z.github.io/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>Deepin 下笔记本外接显示器问题</title>
    <link href="https://antfaiz5z.github.io/2018/11/05/xrandr/"/>
    <id>https://antfaiz5z.github.io/2018/11/05/xrandr/</id>
    <published>2018-11-05T12:04:29.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>最近用小米游戏本的HDMI口外接显示器时发现，只有启动时有Deepin logo一闪而过，之后无信号输出。</p><p>解决办法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ xrandr --listproviders <span class="comment"># 如果有多个provider，那么可能是不同显示口在不同显卡上</span></span><br><span class="line">$ xrandr --setprovideroutputsource 0 1 <span class="comment"># 或</span></span><br><span class="line">$ xrandr --setprovideroutputsource 1 0 <span class="comment"># 做下链接，就可以看到所有硬件接口</span></span><br><span class="line">$ xrandr --output xxx --auto <span class="comment"># 设置输出,xxx形如VGA-1、HDMI-1-1等</span></span><br></pre></td></tr></table></figure><p>问题是重启失效，于是设置开机自启脚本：</p><p>将上设置命令保存到新建文件<code>10custom_init_xrandr</code>，保存至<code>/etc/X11/Xsession.d/</code>目录中。</p><p><code>xrandr --output</code>指令示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ xrandr --output VGA --same-as LVDS --auto</span><br><span class="line"><span class="comment"># 打开外接显示器(--auto:最高分辨率)，与笔记本液晶屏幕显示同样内容（克隆）</span></span><br><span class="line">$ xrandr --output VGA --same-as LVDS --mode 1280x1024</span><br><span class="line"><span class="comment"># 打开外接显示器(分辨率为1280x1024)，与笔记本液晶屏幕显示同样内容（克隆）</span></span><br><span class="line">$ xrandr --output VGA --right-of LVDS --auto</span><br><span class="line"><span class="comment"># 打开外接显示器(--auto:最高分辨率)，设置为右侧扩展屏幕</span></span><br><span class="line">$ xrandr --output VGA --off</span><br><span class="line"><span class="comment"># 关闭外接显示器</span></span><br><span class="line">$ xrandr --output VGA --auto --output LVDS --off</span><br><span class="line"><span class="comment"># 打开外接显示器，同时关闭笔记本液晶屏幕（只用外接显示器工作）</span></span><br><span class="line">xrandr --output VGA --off --output LVDS --auto</span><br><span class="line"><span class="comment"># 关闭外接显示器，同时打开笔记本液晶屏幕 （只用笔记本液晶屏）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近用小米游戏本的HDMI口外接显示器时发现，只有启动时有Deepin logo一闪而过，之后无信号输出。&lt;/p&gt;
&lt;p&gt;解决办法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="deepin" scheme="https://antfaiz5z.github.io/tags/deepin/"/>
    
      <category term="xrandr" scheme="https://antfaiz5z.github.io/tags/xrandr/"/>
    
  </entry>
  
  <entry>
    <title>设计模式原则及分类</title>
    <link href="https://antfaiz5z.github.io/2018/11/05/design-pattern/"/>
    <id>https://antfaiz5z.github.io/2018/11/05/design-pattern/</id>
    <published>2018-11-05T02:39:55.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<ol><li>设计模式的六大原则</li></ol><ul><li>单一职责原则（SRP，Single Responsibility Principle）</li><li>里氏替换原则（LSP，Liskov Substitution Principle）</li><li>依赖倒置原则（DIP，Dependence Inversion Principle）</li><li>接口隔离原则（ISP，Interface Segregation Principle）</li><li>迪米特法则（LoD，Law of Demeter）</li><li>开放封闭原则（OCP，Open Close Principle）</li></ul><ol start="2"><li>设计模式分类</li></ol><table><thead><tr><th>范围</th><th>创建型</th><th>结构型</th><th>行为型</th></tr></thead><tbody><tr><td>类</td><td>Factory Method（工厂方法）</td><td>Adapter(类) （适配器）</td><td>Interpreter（解释器）<br>Template Method（模版方法）</td></tr><tr><td>对象</td><td>Abstract Factory（抽象工厂）<br>Builder（建造者）<br>Prototype（原型）<br>Singleton（单例）</td><td>Adapter(对象)（适配器）<br>Bridge（桥接）<br>Composite（组合）<br>Decorator（装饰者）<br>Façade（外观）<br>Flyweight（享元）<br>Proxy（代理）</td><td>Chain of Responsibility（职责链）<br>Command（命令）<br>Iterator（迭代器）<br>Mediator（中介者）<br>Memento（备忘录）<br>Observer（观察者）<br>State（状体）<br>Strategy（策略）<br>Visitor（访问者）</td></tr></tbody></table><ol start="3"><li>设计模式分类细分</li></ol><table><thead><tr><th>范围</th><th>创建型</th><th>结构型</th><th>行为型</th></tr></thead><tbody><tr><td>对象创建</td><td>Singleton（单例）<br>Prototype（原型）<br>Factory Method（工厂方法）<br>Abstract Factory（抽象工厂）<br>Builder（建造者）</td><td></td><td></td></tr><tr><td>接口适配</td><td></td><td>Adapter（适配器）<br>Bridge（桥接）<br>Façade（外观）</td><td></td></tr><tr><td>对象去耦</td><td></td><td></td><td>Mediator（中介者）<br>Observer（观察者）</td></tr><tr><td>抽象集合</td><td></td><td>Composite（组合）</td><td>Iterator（迭代器）</td></tr><tr><td>行为扩展</td><td></td><td>Decorator（装饰）</td><td>Visitor（访问者）<br>Chain of Responsibility（职责链）</td></tr><tr><td>算法封装</td><td></td><td></td><td>Template Method（模板方法）<br>Strategy（策略）<br>Command（命令）</td></tr><tr><td>性能与对象访问</td><td></td><td>Flyweight（享元）<br>Proxy（代理）</td><td></td></tr><tr><td>对象状态</td><td></td><td></td><td>Memento（备忘录）<br>State（状态）</td></tr><tr><td>其它</td><td></td><td></td><td>Interpreter（解释器）  </td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;设计模式的六大原则&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则（SRP，Single Responsibility Principle）&lt;/li&gt;
&lt;li&gt;里氏替换原则（LSP，Liskov Substitution Principle）&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="design pattern" scheme="https://antfaiz5z.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>IO Multiplexing</title>
    <link href="https://antfaiz5z.github.io/2018/10/25/networking-IO/"/>
    <id>https://antfaiz5z.github.io/2018/10/25/networking-IO/</id>
    <published>2018-10-25T03:36:40.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><ul><li><p>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。</p></li><li><p>异步 I/O：不会阻塞。</p></li></ul><p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。</p><p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p><p><img src="/images/io_models.png" alt="五大 I/O 模型比较"></p><h2 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h2><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p><p>select 会修改描述符，而 poll 不会；<br>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 的描述符类型使用链表实现，没有描述符数量的限制；<br>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。<br>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</p><h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><p>select 和 poll 速度都比较慢。</p><p>select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p><p>select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。</p><p>epoll是select/poll的增强版本，其实现和使用方式与select/poll有很多不同，epoll通过一组函数来完成有关任务，而不是一个函数。</p><p>epoll之所以高效，是因为epoll将用户关心的文件描述符放到内核里的一个事件表中，而不是像select/poll每次调用都需要重复传入文件描述符集或事件集。比如当一个事件发生（比如说读事件），epoll无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入就绪队列的描述符集合就行了。</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><ol><li>select 应用场景</li></ol><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p><p>select 可移植性更好，几乎被所有主流平台所支持。</p><ol start="2"><li>poll 应用场景</li></ol><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p><ol start="3"><li>epoll 应用场景</li></ol><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p><p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p><p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p><p>epoll 仅适用于 Linux OS。</p><p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。LT是select/poll使用的触发方式，比较低效；而ET是epoll的高速工作方式。</p><ol><li>LT 模式</li></ol><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p><ol start="2"><li>ET 模式</li></ol><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p><p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><p>通俗理解（是挺俗的）就是，比如说有一堆女孩，有的很漂亮，有的很凤姐。现在你想找漂亮的女孩聊天，LT就是你需要把这一堆女孩全都看一遍，才可以找到其中的漂亮的（就绪事件）；而ET是你的小弟（内核）将N个漂亮的女孩编号告诉你，你直接去看就好，所以epoll很高效。另外，采用非阻塞方式，小明还需要每隔十分钟回来看一下（select）；如果小明有小弟（内核）帮他守在大门口，女神回来了，小弟会主动打电话，告诉小明女神回来了，快来处理吧！这就是epoll。</p><h2 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h2><ol><li>单线程服务器的常用编程模型：Reactor模式和Proactor模式</li></ol><p>Reactor模式，即“non-blocking IO + IO multiplexing”，程序的基本结构是一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑。其中 IO multiplexing 指的是IO线程的复用，不是IO的复用，具体的话是用select(2)和poll(2)，epoll(4)来监听感兴趣的fd。但是这个编程模型也有一个本质的缺点，它要求回调函数必须是非阻塞的。</p><ol start="2"><li>多线程服务器的常用编程模型：non-blocking IO+ one loop per thread模式</li></ol><p>one loop per thread：每个IO线程有一个event loop（或者叫Reactor）用作IO multiplexing，配合non-blocking IO和定时器用于处理读写和定时事件。</p><p>thread pool用作计算，可以使用生产者消费者队列。</p><p>也就是可以有多个IO线程或单个IO线程，每个IO线程最多有一个event loop，使用线程池作为计算线程，每个计算线程使用blocking queue缓存代办任务。</p><p>在non-blocking网络编程中应用层实现并使用buffer是必需的，buffer使IO线程只阻塞于IO multiplexing函数上，如select/poll/epoll_wait，而不阻塞read()或者write()</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li><p>RAII(资源获取即初始化)，这是C++中用来管理资源的一种方式，即通过栈空间上执行对象的构造和析构实现对资源的获取和释放。书中例子也用到了这种方法来实现互斥锁的加锁解锁，条件变量的使用。</p></li><li><p>善用shared_ptr实现线程安全的对象释放，但是要注意再多个线程读写同一个shared_ptr对象时，需要加锁。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IO模型&quot;&gt;&lt;a href=&quot;#IO模型&quot; class=&quot;headerlink&quot; title=&quot;IO模型&quot;&gt;&lt;/a&gt;IO模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="multi-thread" scheme="https://antfaiz5z.github.io/tags/multi-thread/"/>
    
      <category term="networking" scheme="https://antfaiz5z.github.io/tags/networking/"/>
    
      <category term="io" scheme="https://antfaiz5z.github.io/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>C++ 11 多线程编程</title>
    <link href="https://antfaiz5z.github.io/2018/09/19/multithreads/"/>
    <id>https://antfaiz5z.github.io/2018/09/19/multithreads/</id>
    <published>2018-09-19T00:47:18.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 新标准中引入了五个头文件来支持多线程编程，它们分别是 <code>&lt;atomic&gt;</code>, <code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code>, <code>&lt;condition_variable&gt;</code> 和 <code>&lt;future&gt;</code>。</p><a id="more"></a><ul><li><p><code>&lt;thread&gt;</code>：该头文件主要声明了 std::thread 类，另外 <code>std::this_thread</code> 命名空间也在该头文件中。</p></li><li><p><code>&lt;mutex&gt;</code>：该头文件主要声明了与互斥量(Mutex)相关的类，包括 <code>std::mutex_*</code> 一系列类，<code>std::lock_guard</code>, <code>std::unique_lock</code>, 以及其他的类型和函数。</p></li><li><p><code>&lt;condition_variable&gt;</code>：该头文件主要声明了与条件变量相关的类，包括 <code>std::condition_variable</code> 和 <code>std::condition_variable_any</code>。</p></li><li><p><code>&lt;future&gt;</code>：该头文件主要声明了 <code>std::promise</code>, <code>std::package_task</code> 两个 Provider 类，以及 <code>std::future</code> 和 <code>std::shared_future</code> 两个 Future 类，另外还有一些与之相关的类型和函数，<code>std::async()</code> 函数就声明在此头文件中。</p><ul><li><p><code>&lt;future&gt;</code> 头文件中包含了以下几个类和函数：</p><ul><li><p>Providers 类：<code>std::promise</code>, <code>std::package_task</code></p></li><li><p>Futures 类：<code>std::future</code>, <code>std::shared_future</code></p></li><li><p>Providers 函数：<code>std::async()</code></p></li><li><p>其他类型：<code>std::future_error</code>, <code>std::future_errc</code>, <code>std::future_status</code>, <code>std::launch</code></p></li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化时该 std::future 对象处于为 invalid 状态.</span></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; foo, bar;</span><br><span class="line"><span class="comment">// move 赋值, foo 变为 valid.</span></span><br><span class="line">foo = <span class="built_in">std</span>::async(do_get_value);</span><br><span class="line"><span class="comment">// move 赋值, bar 变为 valid, 而 move 赋值以后 foo 变为 invalid.</span></span><br><span class="line">bar = <span class="built_in">std</span>::move(foo);</span><br></pre></td></tr></table></figure><ul><li><code>&lt;atomic&gt;</code>：该头文主要声明了两个类, <code>std::atomic</code> 和 <code>std::atomic_flag</code>，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++11 新标准中引入了五个头文件来支持多线程编程，它们分别是 &lt;code&gt;&amp;lt;atomic&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;thread&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;mutex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;condition_variable&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;future&amp;gt;&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="multi-thread" scheme="https://antfaiz5z.github.io/tags/multi-thread/"/>
    
  </entry>
  
  <entry>
    <title>新装系统环境配置流程</title>
    <link href="https://antfaiz5z.github.io/2018/09/05/new-machine-init/"/>
    <id>https://antfaiz5z.github.io/2018/09/05/new-machine-init/</id>
    <published>2018-09-05T11:27:04.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<p>Personal.</p><a id="more"></a><h3 id="git-github"><a href="#git-github" class="headerlink" title="git/github"></a>git/github</h3><ol><li><p>查看电脑上是否已经存在SSH密钥：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure><p> 若显示“No such file or directoy”,则需要创建新的ssh key</p></li><li><p>创建新的ssh key:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"&lt;youremail&gt;"</span></span><br></pre></td></tr></table></figure><p> 执行这条命令会提示文件保存路径，可以直接Enter，默认保存在当前用户目录。然后提示输入passphrase，可以直接Enter，即无密码.</p></li><li><p>复制ssh key到Github</p><p> 用编辑器打开.ssh目录下的id_rsa.pub文件，复制里面的全部内容，add ssh key</p></li><li><p>测试ssh连接Github：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p> 期间会提示输入密码，若无则无</p></li><li><p>设置自己的git信息：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"username"</span> </span><br><span class="line">（此处username可修改也不是用于登录github的登录名）</span><br><span class="line">$ git config --global user.email <span class="string">"&lt;youremail&gt;"</span></span><br></pre></td></tr></table></figure><p> 设置自己的git信息即完成安装和设置，可以输入</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><p> 查看自己的git信息</p></li></ol><h3 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure><p>设置系统代理-&gt;手动:</p><p>Socks代理: 127.0.0.1</p><p>本地端口: 1080</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y zsh</span><br></pre></td></tr></table></figure><p>OhMyZsh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>reboot terminal</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.zshrc</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">"agnoster"</span></span><br></pre></td></tr></table></figure><p>为了展示 Agnoster 主题提示符里的三角形，需要 Powerline 字体库的支持。</p><p>使用 Git Clone下来字体库仓库，进入仓库根目录，执行 install.sh 安装。</p><p>字体库链接：<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a> 或直接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install fonts-powerline</span><br></pre></td></tr></table></figure><h3 id="nvm-node-npm"><a href="#nvm-node-npm" class="headerlink" title="nvm/node/npm"></a>nvm/node/npm</h3><p>访问 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a> 查看nvm最新release版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</span><br></pre></td></tr></table></figure><p>访问 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a> 查看node最新LTS版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install [version]</span><br></pre></td></tr></table></figure><p>npm换源：</p><ol><li><p>临时使用</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm --registry https://registry.npm.taobao.org install express</span><br></pre></td></tr></table></figure></li><li><p>持久使用</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p> 配置后可通过下面方式来验证是否成功 </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get registry</span><br></pre></td></tr></table></figure></li><li><p>通过cnpm使用</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p> npm命令都可用cnpm代替。</p></li></ol><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install cmake gcc clang gdb build-essential</span><br></pre></td></tr></table></figure><h3 id="anacode"><a href="#anacode" class="headerlink" title="anacode"></a>anacode</h3><p><a href="https://www.anaconda.com/download/#linux" target="_blank" rel="noopener">https://www.anaconda.com/download/#linux</a></p><h3 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h3><p><a href="https://antfaiz5z.github.io/2017/07/12/hexo/">https://antfaiz5z.github.io/2017/07/12/hexo/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Personal.&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>常用 Git 命令</title>
    <link href="https://antfaiz5z.github.io/2018/08/17/git/"/>
    <id>https://antfaiz5z.github.io/2018/08/17/git/</id>
    <published>2018-08-17T02:32:01.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;path&gt;/&lt;file&gt;</span><br><span class="line">$ git commit -m <span class="string">"&lt;commit_msg&gt;"</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git remote [-v | --verbose]</span><br><span class="line">$ git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;</span><br><span class="line">$ git remote rename &lt;old&gt; &lt;new&gt;</span><br><span class="line">$ git remote remove &lt;name&gt;</span><br><span class="line">$ git remote <span class="built_in">set</span>-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)</span><br><span class="line">$ git remote <span class="built_in">set</span>-branches [--add] &lt;name&gt; &lt;branch&gt;…​</span><br><span class="line">$ git remote get-url [--push] [--all] &lt;name&gt;</span><br><span class="line">$ git remote <span class="built_in">set</span>-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]</span><br><span class="line">$ git remote <span class="built_in">set</span>-url --add [--push] &lt;name&gt; &lt;newurl&gt;</span><br><span class="line">$ git remote <span class="built_in">set</span>-url --delete [--push] &lt;name&gt; &lt;url&gt;</span><br><span class="line">$ git remote [-v | --verbose] show [-n] &lt;name&gt;…​</span><br><span class="line">$ git remote prune [-n | --dry-run] &lt;name&gt;…​</span><br><span class="line">$ git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br></pre></td></tr></table></figure><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># 查看当前分支修改状态</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># log命令可以显示所有提交过的版本信息</span></span><br><span class="line">$ git <span class="built_in">log</span> - -pretty=oneline</span><br><span class="line"><span class="comment"># 将只会显示提交的commit id号和对应的注释。</span></span><br><span class="line">$ git reflog</span><br><span class="line"><span class="comment"># 如果在回退以后又想再次回到之前的版本，git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录</span></span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#本地分支暂存区回退</span></span><br><span class="line">$ git rm [-r] &lt;path&gt;/&lt;file&gt;</span><br><span class="line"><span class="comment"># 对应于git add，使文件不加入版本管理</span></span><br><span class="line">$ git checkout -- &lt;file&gt;</span><br><span class="line"><span class="comment"># 让&lt;file&gt;这个文件回到最近一次git commit或git add时的状态</span></span><br><span class="line"><span class="comment"># 一种是&lt;file&gt;自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</span></span><br><span class="line"><span class="comment"># 一种是&lt;file&gt;已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#本地分支提交回退</span></span><br><span class="line">$ git reset HEAD~</span><br><span class="line">$ git reset HEAD &lt;file&gt;</span><br><span class="line"><span class="comment"># git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本.</span></span><br><span class="line">$ git reset [--hard] &lt;commit_id&gt;</span><br><span class="line"><span class="comment"># hard选项，表示彻底将工作区、暂存区和版本库记录恢复到指定的版本库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#远程分支版本回退</span></span><br><span class="line"><span class="comment"># 远程版本回退可在本地回退后再强制推送至远程分支</span></span><br><span class="line">$ git push -f origin &lt;branch&gt;</span><br><span class="line"><span class="comment"># 本地分支回滚后，版本将落后远程分支，必须使用强制推送覆盖远程分支，否则无法推送到远程分支</span></span><br></pre></td></tr></table></figure><p><img src="/images/reset_and_checkout.png" alt="reset and checkout"></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line"><span class="comment"># 查看当前分支情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#本地新建分支</span></span><br><span class="line">$ git branch &lt;new_branch&gt;</span><br><span class="line"><span class="comment"># 以当前分支为源创建&lt;new branch&gt;分支</span></span><br><span class="line">$ git checkout &lt;new_branch&gt;</span><br><span class="line"><span class="comment"># 进入&lt;new branch&gt;分支</span></span><br><span class="line"><span class="comment">#合体</span></span><br><span class="line">$ git checkout -b &lt;new_branch&gt;</span><br><span class="line"><span class="comment"># 以当前分支为源创建新分支&lt;new branch&gt;，并进入&lt;new branch&gt;分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#远程分支创建</span></span><br><span class="line"><span class="comment"># 本地分支创建后推送至远程仓库即可</span></span><br><span class="line">$ git push origin &lt;new_branch&gt;:master</span><br><span class="line"><span class="comment"># 提交本地&lt;new_branch&gt;分支作为远程的master分支</span></span><br><span class="line">$ git push origin &lt;new_branch&gt;:&lt;new_branch&gt;</span><br><span class="line"><span class="comment"># 提交本地&lt;new_branch&gt;分支作为远程的&lt;new_branch&gt;分支</span></span><br><span class="line">$ git push origin :&lt;new_branch&gt;</span><br><span class="line"><span class="comment"># 刚提交到远程的&lt;new_branch&gt;分支将被删除，但是本地还会保存</span></span><br></pre></td></tr></table></figure><h2 id="子仓库"><a href="#子仓库" class="headerlink" title="子仓库"></a>子仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在仓库当前路径添加子模块</span></span><br><span class="line">git submodule add &lt;git_url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#克隆包含子模块的仓库</span></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="comment">#克隆项目，子模块目录默认被克隆，但是是空的</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;git_url&gt;</span><br><span class="line"><span class="comment">#初始化子模块：初始化本地配置文件</span></span><br><span class="line">$ git submodule init</span><br><span class="line"><span class="comment">#该项目中抓取所有数据并检出父项目中列出的合适的提交</span></span><br><span class="line">$ git submodule update</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="comment">#用--recursive命令，跟方法一样达到效果</span></span><br><span class="line">$ git <span class="built_in">clone</span> --recursive &lt;git_url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新子模块</span></span><br><span class="line">$ git submodule update --remote --merge</span><br><span class="line"><span class="comment"># 或者进入子模块目录如普通仓库一样操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除子模块</span></span><br><span class="line">$ git rm --cached [name]</span><br><span class="line">$ rm -rf [name]</span><br><span class="line">$ rm .gitmodules</span><br><span class="line">$ vim .git/config</span><br><span class="line"><span class="comment"># 删除子模块相关内容，例如下面的内容</span></span><br><span class="line">[submodule <span class="string">"submodule"</span>]</span><br><span class="line">        url = git@gitee.com:xxx.com/submodule.git</span><br><span class="line">        active = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#主仓库推送</span></span><br><span class="line">$ git push --recurse-submodules=check</span><br><span class="line"><span class="comment"># 主仓库推送时，确保子模块的修改已经推送，下面命令会检查子模块修改的内容是否推送，如果没有，主仓库推送也会失败</span></span><br><span class="line">$ git push --recurse-submodules=on-demand</span><br><span class="line"><span class="comment"># 检查到子模块没有推送，会自动推送子模块，然后再推送主模块（如果子模块推送失败，那么主模块也推送失败）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常规&quot;&gt;&lt;a href=&quot;#常规&quot; class=&quot;headerlink&quot; title=&quot;常规&quot;&gt;&lt;/a&gt;常规&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git add &amp;lt;path&amp;gt;/&amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -m &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;commit_msg&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Git" scheme="https://antfaiz5z.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://antfaiz5z.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>mbedTLS (PolarSSL) 的几点问题</title>
    <link href="https://antfaiz5z.github.io/2018/07/20/mbedtls/"/>
    <id>https://antfaiz5z.github.io/2018/07/20/mbedtls/</id>
    <published>2018-07-20T07:54:55.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<ol><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_conf_authmode( &amp;conf, MBEDTLS_SSL_VERIFY_REQUIRED );</span><br></pre></td></tr></table></figure></li></ol><p>第二个参数不建议用MBEDTLS_SSL_VERIFY_OPTIONAL，不然验证通不过的时候也能用，意义不大</p><ol start="2"><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_set_hostname( &amp;ssl, <span class="string">"MQTT"</span> )</span><br></pre></td></tr></table></figure></li></ol><p>第二个参数一定要和生成证书时所指定的CN字段一样</p><ol start="3"><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_conf_max_version(&amp;conf, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_1);</span><br><span class="line">mbedtls_ssl_conf_min_version(&amp;conf, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_1);</span><br></pre></td></tr></table></figure></li></ol><p>这两条语句有可能会用到</p><ol start="4"><li><p>实现收发数据的接口时一定要注意采用阻塞方式还是超时方式，不然可能会死锁</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="mbedTLS" scheme="https://antfaiz5z.github.io/tags/mbedTLS/"/>
    
  </entry>
  
  <entry>
    <title>HTTPs相关</title>
    <link href="https://antfaiz5z.github.io/2018/07/20/certificates/"/>
    <id>https://antfaiz5z.github.io/2018/07/20/certificates/</id>
    <published>2018-07-20T03:51:21.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CA Certificate Authority 认证授权机构</span><br><span class="line">cert Certificate 证书</span><br><span class="line">csr Certificate Signing Request 证书签名申请</span><br><span class="line">pk public key</span><br><span class="line">psk pre-shared key</span><br><span class="line">encryption 加密</span><br><span class="line">decryption 解密</span><br><span class="line">symmetric encryption 对称加密</span><br><span class="line">asymmetric encryption 非对称加密</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h1><p>CA证书顾名思义就是由CA机构发布的数字证书。</p><p>包含有：</p><ul><li>颁发者</li><li>使用者</li><li>版本</li><li>签名算法</li><li>签名哈希算法</li><li>使用者</li><li>公钥</li><li>指纹</li><li>指纹算法</li><li>……</li></ul><p>证书的认证是安装证书链执行的，证书链的意思是有一个证书机构A，A生成证书B，B也可以生成证书C，A证书或者certification authority of wosign证书在整个证书链上就被称为根证书。证书验证的机制是只要根证书是受信任的，那么它的子证书都是可信的。如果一个证书的根证书是不可信的，那么这个证书肯定也是不可信任的。</p><p>中国的安全认证体系分为金融CA和非金融CA。在金融CA方面，根证书由中国人民银行管理，在非金融CA方面，由中国电信负责。中国CA又可分为行业性CA和区域性CA,行业性CA中影响最大是中国金融认证中心和中国电信认证中国；区域性CA主要是以政府为背景，以企业机制运行，其中广东CA中心和上海CA中影响最大。</p><h1 id="SSL与TLS"><a href="#SSL与TLS" class="headerlink" title="SSL与TLS"></a>SSL与TLS</h1><p>https就是http加SSL，SSL（security sockets layer，安全套接层）是为网络通信提供安全及数据完整性的一种安全协议，SSL协议位于TCP/IP协议与各种应用层协议（包括http）之间，SSL3.0版本以后又被称为TLS (transport layer security，传输层安全 )。</p><h1 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h1><ol><li><p>对称加密就是发送双发使用相同的密钥对消息进行加解密。</p><p> 常见的对称加密为DES、3DES、AES等。</p></li><li><p>非对称加密是发送双方各自拥有一对公钥私钥，其中公钥是公开的，私钥是保密的。当发送方向接收方发送消息时，发送方利用接收方的公钥对消息进行加密，接收方收到消息后，利用自己的私钥解密就能得到消息的明文。</p><p> 其中非对称加密方法有RSA、Elgamal、ECC等。</p></li></ol><p>解决第三方冒充的方法是将发送内容进行二次加密，并且通讯双方有可靠的途径知道对方的公钥:</p><ul><li>A发送给B时候，先用A的私钥加密，然后再用B的公钥加密。</li><li>B收到后，先用B的私钥解密，再用A的公钥解密，得到明文。</li></ul><p>获取公钥的可靠途径不一样，就可以有不容的实现方式：</p><ol><li><p>通信双方事先有对方的公钥，这种方法比较麻烦，要面对面交换。显然不适合大规模应用，用在夫妻之间到是比较好的！</p></li><li><p>第三方的数字签名，这个就比较好了，大家都把公钥放在第三方CA那里，通信发起方问CA要双方的公钥，并传给对方。</p></li></ol><p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证安全性，之后使用对称密钥加密进行通信来保证效率。（下图中的 Session Key 就是对称密钥）</p><p><img src="/images/How-HTTPS-Works.png" alt="How HTTPs works"></p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p>通信开始时，客户端需要使用服务器的公开密钥将自己的私有密钥传输给服务器，之后再进行对称密钥加密。</p><p><img src="/images/ca.png" alt="Sign and verify"></p><h1 id="数字签名与签名认证-digital-signature"><a href="#数字签名与签名认证-digital-signature" class="headerlink" title="数字签名与签名认证 digital signature"></a>数字签名与签名认证 digital signature</h1><p>发方将原文用哈希算法求得数字摘要，用签名私钥对数字摘要加密得数字签名，发方将原文与数字签名一起发送给接受方。<br>数字签名的操作过程需要有发方的签名数字证书的私钥及其验证公钥。具体过程如下：首先是生成被签名的电子文件（《电子签名法》中称数据电文），然后对电子文件用哈希算法做数字摘要，再对数字摘要用签名私钥做非对称加密，即做数字签名；之后是将以上的签名和电子文件原文以及签名证书的公钥加在一起进行封装，形成签名结果发送给收方，待收方验证。</p><p>接收方收到数字签名的结果，其中包括数字签名、电子原文和发方公钥，即待验证的数据。接收方进行签名验证。验证过程是：接收方首先用发方公钥解密数字签名，导出数字摘要，并对电子文件原文作同样哈希算法得一个新的数字摘要，将两个摘要的哈希值进行结果比较，结果相同签名得到验证，否则签名无效。这就作到了《电子签名法》中所要求的对签名不能改动，对签署的内容和形式也不能改动的要求。</p><h2 id="摘要-digest"><a href="#摘要-digest" class="headerlink" title="摘要 digest"></a>摘要 digest</h2><p>OpenSSL支持的摘要算法</p><ul><li>md5</li><li>md4</li><li>mdc2</li><li>sha1</li><li>sha</li><li>sha224</li><li>ripemd160</li><li>dss1</li><li>whirlpool</li></ul><h2 id="签名-signature"><a href="#签名-signature" class="headerlink" title="签名 signature"></a>签名 signature</h2><p>签名的一般过程：先对数据进行摘要计算，然后对摘要值用私钥进行签名。</p><h3 id="RSA私钥签名验签"><a href="#RSA私钥签名验签" class="headerlink" title="RSA私钥签名验签"></a>RSA私钥签名验签</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成RSA密钥对</span></span><br><span class="line">$ openssl genrsa -out rsa_private.key</span><br><span class="line"></span><br><span class="line"><span class="comment">#由公钥导出私钥</span></span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> rsa_private.key -pubout -out rsa_public.key</span><br><span class="line"></span><br><span class="line"><span class="comment">#用RSA私钥对SHA1计算得到的摘要值`签名`</span></span><br><span class="line">$ openssl dgst -sign rsa_private.key -sha1 -out sha1_rsa_file.sign file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#用相应的公钥和相同的摘要算法进行`验签`，否则会失败</span></span><br><span class="line">$ openssl dgst -verify rsa_public.key -sha1 -signature sha1_rsa_file.sign file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以使用相同的私钥和相同的摘要算法进行验证</span></span><br><span class="line">$ openssl dgst -prverify rsa_private.key -sha1 -signature sha1_rsa_file.sign file.txt</span><br></pre></td></tr></table></figure><h3 id="DSA密钥签名验签"><a href="#DSA密钥签名验签" class="headerlink" title="DSA密钥签名验签"></a>DSA密钥签名验签</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成DSA参数</span></span><br><span class="line">$ openssl dsaparam -out dsa.param 1024</span><br><span class="line"></span><br><span class="line"><span class="comment">#由DSA参数产生DSA私钥</span></span><br><span class="line">$ openssl gendsa -out dsa_private.key dsa.param</span><br><span class="line"></span><br><span class="line"><span class="comment">#由DSA私钥生成DSA公钥</span></span><br><span class="line">$ openssl dsa -<span class="keyword">in</span> dsa_private.key -out dsa_public.key -pubout</span><br><span class="line"></span><br><span class="line"><span class="comment">#用DSA私钥对SHA384计算的摘要值进行签名。</span></span><br><span class="line">$ openssl dgst -sign dsa_private.key -sha384 -out sha384_dsa.sign file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#用相应的公钥和摘要算法进行验签</span></span><br><span class="line">$ openssl dgst -verify dsa_public.key -sha384 -signature sha384_dsa.sign file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#用相同的私钥和摘要算法验签</span></span><br><span class="line">$ openssl dgst -prverify dsa_private.key -sha384 -signature sha384_dsa.sign file.txt</span><br></pre></td></tr></table></figure><blockquote><p>DSA在每次签名时,使用了随机数k,如果对同一消息进行多次签名,签名结果是不同的,所以DSA是一种随机式数字签名。</p></blockquote><h1 id="SSL握手-handshake"><a href="#SSL握手-handshake" class="headerlink" title="SSL握手 handshake"></a>SSL握手 handshake</h1><ul><li>客户端访问服务器,发送ssl版本、客户端支持的加密算法、随机数等消息。</li><li>服务器向客户端发送ssl版本、随机数、加密算法、证书（证书出现了）等消息。</li><li>客户端收到消息后，判断证书是否可信（如何判断可信，看下文介绍），若可信，则继续通信，发送消息包括：向服务器发送一个随机数，从证书中获取服务器端的公钥，对随机数加密；编码改变通知，表示随后信息都将使用双方协定的加密方法和密钥发送；客户端握手结束通知。</li><li>服务器端对数据解密得到随机数，发送消息：编码改变通知，表示随后信息都将使用双方协定的加密方法和密钥发送。</li></ul><p>非对称加密算法对数据加密非常慢，效率低，而对称加密加密效率很高，因此在整个握手过程要生成一个对称加密密钥，然后数据传输中使用对称加密算法对数据加密。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CA Certificate Authority 认证授权机构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cert Certificate 证书&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;csr Certificate Signing Request 证书签名申请&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pk public key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;psk pre-shared key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;encryption 加密&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;decryption 解密&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;symmetric encryption 对称加密&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;asymmetric encryption 非对称加密&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Others" scheme="https://antfaiz5z.github.io/categories/Others/"/>
    
    
      <category term="CA" scheme="https://antfaiz5z.github.io/tags/CA/"/>
    
      <category term="encryption" scheme="https://antfaiz5z.github.io/tags/encryption/"/>
    
  </entry>
  
  <entry>
    <title>Library paho.mqtt.c API</title>
    <link href="https://antfaiz5z.github.io/2018/07/13/paho-mqtt-c/"/>
    <id>https://antfaiz5z.github.io/2018/07/13/paho-mqtt-c/</id>
    <published>2018-07-13T08:35:34.000Z</published>
    <updated>2019-08-24T12:47:42.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MQTT客户端分为同步客户端和异步客户端.　一般流程如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个客户端对象；</span><br><span class="line">  2.设置连接MQTT服务器的选项；</span><br><span class="line">  3.如果多线程（异步模式）操作被使用则设置回调函数；</span><br><span class="line">  4.订阅客户端需要接收的任意话题；</span><br><span class="line">  5.重复以下操作直到结束：</span><br><span class="line">    a.发布客户端需要的任意信息；</span><br><span class="line">    b.处理所有接收到的信息；</span><br><span class="line">  6.断开客户端连接；</span><br><span class="line">  7.释放客户端使用的所有内存。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="重要变量"><a href="#重要变量" class="headerlink" title="重要变量"></a>重要变量</h1><h2 id="typedef-void-MQTTClient"><a href="#typedef-void-MQTTClient" class="headerlink" title="typedef void* MQTTClient"></a>typedef void* MQTTClient</h2><blockquote><p>A handle representing an MQTT client. A valid client handle is available following a successful call to MQTTClient_create().</p></blockquote><p>使用MQTTClient_create()创建新连接前需预先定义一个MQTTClient，初始为空指针。</p><h2 id="typedef-int-MQTTClient-deliveryToken-amp-typedef-int-MQTTClient-token"><a href="#typedef-int-MQTTClient-deliveryToken-amp-typedef-int-MQTTClient-token" class="headerlink" title="typedef int MQTTClient_deliveryToken &amp;  typedef int MQTTClient_token"></a>typedef int MQTTClient_deliveryToken &amp; <br> typedef int MQTTClient_token</h2><blockquote><p>A value representing an MQTT message. A delivery token is returned to the client application when a message is published. The token can then be used to check that the message was successfully delivered to its destination.</p></blockquote><p>一般用于异步客户端中，token用于记录当前客户端成功发送message所返回的token，若确认message成功发送则使deliveryToken等于当前token，此时即可安全断开客户端与服务器的连接。</p><h1 id="重要结构体"><a href="#重要结构体" class="headerlink" title="重要结构体"></a>重要结构体</h1><h2 id="MQTTClient-connectOptions"><a href="#MQTTClient-connectOptions" class="headerlink" title="MQTTClient_connectOptions"></a>MQTTClient_connectOptions</h2><blockquote><p>MQTTClient_connectOptions defines several settings that control the way the client connects to an MQTT server.<br>Note: Default values are not defined for members of MQTTClient_connectOptions so it is good practice to specify all settings. If the MQTTClient_connectOptions structure is defined as an automatic variable, all members are set to random values and thus must be set by the client application. If the MQTTClient_connectOptions structure is defined as a static variable, initialization (in compliant compilers) sets all values to 0 (NULL for pointers). A keepAliveInterval setting of 0 prevents correct operation of the client and so you must at least set a value for keepAliveInterval.</p></blockquote><p>客户端连接选项。</p><table><thead><tr><th>类型</th><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>struct_id [4]</td><td>必须为”MQTC”</td></tr><tr><td>int</td><td>struct_version</td><td>0: 无SSL选项和serverURIs;<br>1,2,3,4,5,6略</td></tr><tr><td>int</td><td>keepAliveInterval</td><td>最大通信间隔时间（秒）</td></tr><tr><td>int</td><td>cleansession</td><td>布尔值，是否清除session</td></tr><tr><td>int</td><td>reliable</td><td>布尔值。<br>1:上一条message发送完毕才发送下一条；<br> 0:最多允许10条message同时发送</td></tr><tr><td>MQTTClient_willOptions *</td><td>will</td><td>遗嘱选项</td></tr><tr><td>const char *</td><td>username</td><td>用户名（MQTTv3.1.1提供）</td></tr><tr><td>const char *</td><td>password</td><td>密码（MQTTv3.1.1提供）</td></tr><tr><td>int</td><td>connectTimeout</td><td>连接超时</td></tr><tr><td>int</td><td>retryInterval</td><td>重试间隔</td></tr><tr><td>MQTTClient_SSLOptions *</td><td>ssl</td><td>SSL选项</td></tr><tr><td>int</td><td>serverURIcount</td><td>可选的serverURIs数组入口数量，默认0</td></tr><tr><td>char <em>const </em></td><td>serverURIs</td><td>可选的serverURIs数组，形如：protocol://host:port</td></tr><tr><td>int</td><td>MQTTVersion</td><td>MQTT版本，默认先使用v3.1.1</td></tr><tr><td>struct {<br>const char *   serverURI <br>int MQTTVersion <br> int   sessionPresent<br>}</td><td>returned</td><td>连接返回值</td></tr><tr><td>struct {<br>int   len <br>const void *   data<br>}</td><td>binarypwd</td><td>二进制密码</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQTTClient_connectOptions_initializer &#123; &#123;<span class="meta-string">'M'</span>, <span class="meta-string">'Q'</span>, <span class="meta-string">'T'</span>, <span class="meta-string">'C'</span>&#125;, 6, 60, 1, 1, NULL, NULL, NULL, 30, 20, NULL, 0, NULL, MQTTVERSION_DEFAULT, &#123;NULL, 0, 0&#125;, &#123;0, NULL&#125;, -1, 0&#125;</span></span><br></pre></td></tr></table></figure><h2 id="MQTTClient-willOptions"><a href="#MQTTClient-willOptions" class="headerlink" title="MQTTClient_willOptions"></a>MQTTClient_willOptions</h2><blockquote><p>MQTTClient_willOptions defines the MQTT “Last Will and Testament” (LWT) settings for the client. In the event that a client unexpectedly loses its connection to the server, the server publishes the LWT message to the LWT topic on behalf of the client. This allows other clients (subscribed to the LWT topic) to be made aware that the client has disconnected. To enable the LWT function for a specific client, a valid pointer to an MQTTClient_willOptions structure is passed in the MQTTClient_connectOptions structure used in the MQTTClient_connect() call that connects the client to the server. The pointer to MQTTClient_willOptions can be set to NULL if the LWT function is not required.</p></blockquote><p>客户端遗嘱选项。当客户端意外丢失连接，服务器会替此客户端发送LWT主题的LWT消息，订阅了LWT主题的其他客户端可以此知道此客户端已断开连接。</p><table><thead><tr><th>类型</th><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>struct_id [4]</td><td>必须为”MQTW”</td></tr><tr><td>int</td><td>struct_version</td><td>布尔值。0:无二进制payload选项</td></tr><tr><td>const char *</td><td>topicName</td><td>LWT主题</td></tr><tr><td>const char *</td><td>message</td><td>LWT消息</td></tr><tr><td>int</td><td>retained</td><td>是否保留LWT消息</td></tr><tr><td>int</td><td>qos</td><td>quality of service</td></tr><tr><td>struct {<br>int   len<br>const void *   data<br>}<br></td><td>payload</td><td>二进制LWT payload</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQTTClient_willOptions_initializer &#123; &#123;<span class="meta-string">'M'</span>, <span class="meta-string">'Q'</span>, <span class="meta-string">'T'</span>, <span class="meta-string">'W'</span>&#125;, 1, NULL, NULL, 0, 0, &#123;0, NULL&#125; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="MQTTClient-SSLOptions"><a href="#MQTTClient-SSLOptions" class="headerlink" title="MQTTClient_SSLOptions"></a>MQTTClient_SSLOptions</h2><blockquote><p>MQTTClient_sslProperties defines the settings to establish an SSL/TLS connection using the OpenSSL library. It covers the following scenarios:<br>Server authentication: The client needs the digital certificate of the server. It is included in a store containting trusted material (also known as “trust store”).<br>Mutual authentication: Both client and server are authenticated during the SSL handshake. In addition to the digital certificate of the server in a trust store, the client will need its own digital certificate and the private key used to sign its digital certificate stored in a “key store”.<br>Anonymous connection: Both client and server do not get authenticated and no credentials are needed to establish an SSL connection. Note that this scenario is not fully secure since it is subject to man-in-the-middle attacks.</p></blockquote><p>客户端SSL选项。支持服务器认证（需提供服务器证书）、双向认证（需提供服务器证书及客户端自身私钥生成的证书）、匿名连接。</p><table><thead><tr><th>类型</th><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>struct_id [4]</td><td>必须为”MQTS”</td></tr><tr><td>int</td><td>struct_version</td><td>必须为0</td></tr><tr><td>const char *</td><td>trustStore</td><td>PEM格式服务器证书</td></tr><tr><td>const char *</td><td>keyStore</td><td>PEM格式包括客户端的公共证书链及私钥</td></tr><tr><td>const char *</td><td>privateKey</td><td>PEM格式客户端私钥</td></tr><tr><td>const char *</td><td>privateKeyPassword</td><td>客户端私钥密码，若加密的话</td></tr><tr><td>const char *</td><td>enabledCipherSuites</td><td>密码套件列表</td></tr><tr><td>int</td><td>enableServerCertAuth</td><td>布尔值。是否启用服务器证书认证</td></tr><tr><td>int</td><td>sslVersion</td><td>SSL版本</td></tr><tr><td>int</td><td>verify</td><td>是否执行连接后检查，包括证书是否匹配主机名</td></tr><tr><td>const char *</td><td>CApath</td><td>包含PEM格式的CA证书的文件夹</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQTTClient_SSLOptions_initializer &#123; &#123;<span class="meta-string">'M'</span>, <span class="meta-string">'Q'</span>, <span class="meta-string">'T'</span>, <span class="meta-string">'S'</span>&#125;, 2, NULL, NULL, NULL, NULL, NULL, 1, MQTT_SSL_VERSION_DEFAULT, 0, NULL &#125;</span></span><br></pre></td></tr></table></figure><h2 id="MQTTClient-message"><a href="#MQTTClient-message" class="headerlink" title="MQTTClient_message"></a>MQTTClient_message</h2><blockquote><p>A structure representing the payload and attributes of an MQTT message. The message topic is not part of this structure.</p></blockquote><p>客户端发送的消息（不含消息主题）。</p><table><thead><tr><th>类型</th><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>struct_id [4]</td><td>必须为”MQTM”</td></tr><tr><td>int</td><td>struct_version</td><td>必须为0</td></tr><tr><td>int</td><td>payloadlen</td><td>payload字节数</td></tr><tr><td>void *</td><td>payload</td><td>payload</td></tr><tr><td>int</td><td>qos</td><td>quality of service</td></tr><tr><td>int</td><td>retained</td><td>1:MQTT服务器将会保留消息副本，并传送值此主题的新订阅者，新订阅者将会知晓这是MQTT保留的旧消息;<br>0:MQTT服务器不会保留此消息，订阅者认为此为普通消息</td></tr><tr><td>int</td><td>dup</td><td>布尔值。是否是重复消息</td></tr><tr><td>int</td><td>msgid</td><td>message id</td></tr><tr><td>MQTTProperties</td><td>properties</td><td>MQTT属性</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQTTClient_message_initializer &#123; &#123;<span class="meta-string">'M'</span>, <span class="meta-string">'Q'</span>, <span class="meta-string">'T'</span>, <span class="meta-string">'M'</span>&#125;, 1, 0, NULL, 0, 0, 0, 0, MQTTProperties_initializer &#125;</span></span><br></pre></td></tr></table></figure><h1 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h1><h2 id="MQTTClient-create"><a href="#MQTTClient-create" class="headerlink" title="MQTTClient_create"></a>MQTTClient_create</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_create</span><span class="params">(MQTTClient* handle, <span class="keyword">const</span> <span class="keyword">char</span>* serverURI, <span class="keyword">const</span> <span class="keyword">char</span>* clientId, <span class="keyword">int</span> persistence_type, <span class="keyword">void</span>* persistence_context)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient *</td><td>handle</td><td>预先定义好的空client</td></tr><tr><td>const char *</td><td>serverURI</td><td>服务器地址， 形如： protocol://host:port</td></tr><tr><td>const char *</td><td>clientId</td><td>client id</td></tr><tr><td>int</td><td>persistence_type</td><td>1）MQTTCLIENT_PERSISTENCE_NONE： 在内存中持久化;<br> 2）MQTTCLIENT_PERSISTENCE_DEFAULT: 使用默认持久机制（基于文件系统）;<br>3）MQTTCLIENT_PERSISTENCE_USER： 使用特定应用持久实现，应用应实现MQTTClient_persistence 接口</td></tr><tr><td>void *</td><td>persistence_context</td><td>对应于persistence_type:<br> 1)应为NULL;<br> 2)应为持久目录路径，若为NULL则使用工作目录;<br> 3)有效的指向MQTTClient_persistence的指针</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIETN_SUCCESS</td><td>client创建成功</td></tr><tr><td>[error code]</td><td>错误码</td></tr></tbody></table><blockquote><p>This function creates an MQTT client ready for connection to the specified server and using the specified persistent storage (see MQTTClient_persistence). See also MQTTClient_destroy().</p></blockquote><p>创建一个有效的client。使用参数创建一个client，并将其赋值给之前声明的client</p><h2 id="MQTTClient-setCallbacks"><a href="#MQTTClient-setCallbacks" class="headerlink" title="MQTTClient_setCallbacks"></a>MQTTClient_setCallbacks</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_setCallbacks</span><span class="params">(MQTTClient handle, <span class="keyword">void</span>* context, MQTTClient_connectionLost* cl, MQTTClient_messageArrived* ma, MQTTClient_deliveryComplete* dc)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>void*</td><td>context</td><td>任意特定应用上下文，传递给回调函数用于访问应用上下文</td></tr><tr><td>MQTTClient_connectionLost*</td><td>cl</td><td>MQTTClient_connectionLost() 回调函数</td></tr><tr><td>MQTTClient_messageArrived*</td><td>ma</td><td>MQTTClient_messageArrived() 回调函数</td></tr><tr><td>MQTTClient_deliveryComplete*</td><td>dc</td><td>MQTTClient_deliveryComplete() 回调函数</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>成功设置回调函数</td></tr><tr><td>MQTTCLIENT_FAILURE</td><td>发生错误</td></tr></tbody></table><blockquote><p>This function sets the callback functions for a specific client.If your client application doesn’t use a particular callback, set the　relevant parameter to NULL. Calling MQTTClient_setCallbacks() puts the　client into multi-threaded mode. Any necessary message acknowledgements and　status communications are handled in the background without any intervention　from the client application. See @ref async for more information.</p></blockquote><p>设置回调函数。</p><h2 id="MQTTClient-connect"><a href="#MQTTClient-connect" class="headerlink" title="MQTTClient_connect"></a>MQTTClient_connect</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_connect</span><span class="params">(MQTTClient handle, MQTTClient_connectOptions* options)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>MQTTClient_connectOptions*</td><td>options</td><td>struct，连接选项</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>成功连接服务器</td></tr><tr><td><b>1</b></td><td>Connection refused: Unacceptable protocol version</td></tr><tr><td><b>2</b></td><td>Connection refused: Identifier rejected</td></tr><tr><td><b>3</b></td><td>Connection refused: Server unavailable</td></tr><tr><td><b>4</b></td><td>Connection refused: Bad user name or password</td></tr><tr><td><b>5</b></td><td>Connection refused: Not authorized</td></tr><tr><td><b>6-255</b></td><td>Reserved for future use</td></tr></tbody></table><p>（Error codes greater than 0 are returned by the MQTT protocol）</p><blockquote><p>This function attempts to connect a previously-created client (see MQTTClient_create()) to an MQTT server using the specified options. If you want to enable asynchronous message and status notifications, you must call MQTTClient_setCallbacks() prior to MQTTClient_connect().</p></blockquote><p>建立客户端与服务器的连接。</p><h2 id="MQTTClient-subscribe"><a href="#MQTTClient-subscribe" class="headerlink" title="MQTTClient_subscribe"></a>MQTTClient_subscribe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_subscribe</span><span class="params">(MQTTClient handle, <span class="keyword">const</span> <span class="keyword">char</span>* topic, <span class="keyword">int</span> qos)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>const char*</td><td>topic</td><td>订阅的主题，可含通配符</td></tr><tr><td>int</td><td>qos</td><td>quality of service</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>订阅请求成功</td></tr><tr><td>[error code]</td><td>订阅出现问题</td></tr></tbody></table><blockquote><p>Subscribe is synchronous.  QoS list parameter is changed on return to granted QoSs.Returns return code, MQTTCLIENT_SUCCESS == success, non-zero some sort of error (TBD)<br>This function attempts to subscribe a client to a single topic, which may contain wildcards (see @ref wildcard). This call also specifies the @ref qos requested for the subscription (see also MQTTClient_subscribeMany()).</p></blockquote><p>订阅某个主题。</p><p>类似地，取消订阅函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_unsubscribe</span><span class="params">(MQTTClient handle, <span class="keyword">const</span> <span class="keyword">char</span>* topic)</span></span></span><br></pre></td></tr></table></figure><h2 id="MQTTClient-subscribeMany"><a href="#MQTTClient-subscribeMany" class="headerlink" title="MQTTClient_subscribeMany"></a>MQTTClient_subscribeMany</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_subscribeMany</span><span class="params">(MQTTClient handle, <span class="keyword">int</span> count, <span class="keyword">char</span>* <span class="keyword">const</span>* topic, <span class="keyword">int</span>* qos)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>int</td><td>count</td><td>订阅的主题数量</td></tr><tr><td>char<em> const</em></td><td>topic</td><td>一组指针，订阅的主题，可含通配符</td></tr><tr><td>int*</td><td>qos</td><td>一组指针，quality of service</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>订阅请求成功</td></tr><tr><td>[error code]</td><td>订阅出现问题</td></tr></tbody></table><blockquote><p>This function attempts to subscribe a client to a list of topics, which may contain wildcards (see @ref wildcard). This call also specifies the @ref qos requested for each topic (see also MQTTClient_subscribe()).</p></blockquote><p>同时订阅多个主题。</p><p>类似地，取消订阅函数如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_unsubscribeMany</span><span class="params">(MQTTClient handle, <span class="keyword">int</span> count, <span class="keyword">char</span>* <span class="keyword">const</span>* topic)</span></span></span><br></pre></td></tr></table></figure><h2 id="MQTTClient-publish"><a href="#MQTTClient-publish" class="headerlink" title="MQTTClient_publish"></a>MQTTClient_publish</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_publish</span><span class="params">(MQTTClient handle, <span class="keyword">const</span> <span class="keyword">char</span>* topicName, <span class="keyword">int</span> payloadlen, <span class="keyword">void</span>* payload, <span class="keyword">int</span> qos, <span class="keyword">int</span> retained, MQTTClient_deliveryToken* dt)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>const char*</td><td>topicName</td><td>主题</td></tr><tr><td>int</td><td>payloadlen</td><td>payload字节数</td></tr><tr><td>void*</td><td>payload</td><td>payload</td></tr><tr><td>int</td><td>qos</td><td>quality of service</td></tr><tr><td>int</td><td>retained</td><td>服务器是否保留</td></tr><tr><td>MQTTClient_deliveryToken*</td><td>dt</td><td>函数成功返回则赋值一个代表此message的token，若应用未使用delivery tokens，则应置为NULL</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>成功发布</td></tr><tr><td>[error code]</td><td>发布出现问题</td></tr></tbody></table><blockquote><p>This function attempts to publish a message to a given topic (see also MQTTClient_publishMessage()). An ::MQTTClient_deliveryToken is issued when this function returns successfully. If the client application needs to test for succesful delivery of QoS1 and QoS2 messages, this can be done either asynchronously or synchronously (see @ref async, ::MQTTClient_waitForCompletion and MQTTClient_deliveryComplete()).</p></blockquote><p>对给定主题发布一条message。</p><h2 id="MQTTClient-publishMessage"><a href="#MQTTClient-publishMessage" class="headerlink" title="MQTTClient_publishMessage"></a>MQTTClient_publishMessage</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_publishMessage</span><span class="params">(MQTTClient handle, <span class="keyword">const</span> <span class="keyword">char</span>* topicName, MQTTClient_message* msg, MQTTClient_deliveryToken* dt)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>const char*</td><td>topicName</td><td>主题</td></tr><tr><td>MQTTClient_message*</td><td>msg</td><td>消息</td></tr><tr><td>MQTTClient_deliveryToken*</td><td>dt</td><td>函数成功返回则赋值一个代表此message的token，若应用未使用delivery tokens，则应置为NULL</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>成功发布</td></tr><tr><td>[error code]</td><td>发布出现问题</td></tr></tbody></table><blockquote><p>This function attempts to publish a message to a given topic (see also MQTTClient_publish()). An ::MQTTClient_deliveryToken is issued when his function returns successfully. If the client application needs to test for succesful delivery of QoS1 and QoS2 messages, this can be done either asynchronously or synchronously (see @ref async, ::MQTTClient_waitForCompletion and MQTTClient_deliveryComplete()).</p></blockquote><p>对给定主题发布一条message。</p><h2 id="MQTTClient-waitForCompletion"><a href="#MQTTClient-waitForCompletion" class="headerlink" title="MQTTClient_waitForCompletion"></a>MQTTClient_waitForCompletion</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MQTTClient_waitForCompletion</span><span class="params">(MQTTClient handle, MQTTClient_deliveryToken dt, <span class="keyword">unsigned</span> <span class="keyword">long</span> timeout)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>MQTTClient</td><td>handle</td><td>创建成功后有效的client</td></tr><tr><td>MQTTClient_deliveryToken</td><td>dt</td><td>Delivery tokens are issued by the publishing functions MQTTClient_publish() and MQTTClient_publishMessage()</td></tr><tr><td>unsigned long</td><td>timeout</td><td>最大等待时间（毫秒）</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>MQTTCLIENT_SUCCESS</td><td>成功发布</td></tr><tr><td>[error code]</td><td>发布出现问题</td></tr></tbody></table><blockquote><p>This function is called by the client application to synchronize execution of the main thread with completed publication of a message. When called, MQTTClient_waitForCompletion() blocks execution until the message has been successful delivered or the specified timeout has expired. See @ref async.</p></blockquote><p>异步客户端中用于等待message的成功发布。</p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *server_address;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *trust_store;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *client_id;</span><br><span class="line">    <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *username;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *password;</span><br><span class="line"></span><br><span class="line">&#125; Connect_param;</span><br></pre></td></tr></table></figure><h2 id="异步发布"><a href="#异步发布" class="headerlink" title="异步发布"></a>异步发布</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asyn_pub_with_ssl</span><span class="params">(Connect_param *param, <span class="keyword">const</span> <span class="keyword">char</span> *topic, <span class="keyword">const</span> <span class="keyword">char</span> *payload, <span class="keyword">int</span> qos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MQTTClient client;</span><br><span class="line">    MQTTClient_deliveryToken token;</span><br><span class="line">    MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;</span><br><span class="line">    MQTTClient_message pubmsg = MQTTClient_message_initializer;</span><br><span class="line">    MQTTClient_SSLOptions ssl_opts = MQTTClient_SSLOptions_initializer;</span><br><span class="line">    ssl_opts.trustStore = param-&gt;trust_store;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    MQTTClient_create(&amp;client, param-&gt;server_address, param-&gt;client_id,</span><br><span class="line">                      MQTTCLIENT_PERSISTENCE_NONE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    conn_opts.keepAliveInterval = <span class="number">20</span>;</span><br><span class="line">    conn_opts.cleansession = <span class="number">1</span>;</span><br><span class="line">    conn_opts.ssl = &amp;ssl_opts;</span><br><span class="line"></span><br><span class="line">    MQTTClient_setCallbacks(client, <span class="literal">NULL</span>, connlost, msgarrvd, delivered);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((rc = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to connect, return code %d\n"</span>, rc);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    pubmsg.payload = (<span class="keyword">void</span> *) payload;</span><br><span class="line">    pubmsg.payloadlen = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(payload);</span><br><span class="line">    pubmsg.qos = qos;</span><br><span class="line">    pubmsg.retained = <span class="number">0</span>;</span><br><span class="line">    deliveredtoken = <span class="number">0</span>;</span><br><span class="line">    MQTTClient_publishMessage(client, topic, &amp;pubmsg, &amp;token);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Waiting for publication of %s\n"</span></span><br><span class="line">           <span class="string">"on topic %s for client with ClientID: %s\n"</span>,</span><br><span class="line">           payload, topic, param-&gt;client_id);</span><br><span class="line">    rc = MQTTClient_waitForCompletion(client, token, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) param-&gt;timeout);</span><br><span class="line">    <span class="comment">//while(deliveredtoken != token);</span></span><br><span class="line">    MQTTClient_disconnect(client, <span class="number">10000</span>);</span><br><span class="line">    MQTTClient_destroy(&amp;client);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步订阅"><a href="#异步订阅" class="headerlink" title="异步订阅"></a>异步订阅</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asyn_sub_with_ssl</span><span class="params">(Connect_param *param, <span class="keyword">const</span> <span class="keyword">char</span> *topic, <span class="keyword">int</span> qos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MQTTClient client;</span><br><span class="line">    MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;</span><br><span class="line">    MQTTClient_SSLOptions ssl_opts = MQTTClient_SSLOptions_initializer;</span><br><span class="line">    ssl_opts.trustStore = param-&gt;trust_store;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">    MQTTClient_create(&amp;client, param-&gt;server_address, param-&gt;client_id,</span><br><span class="line">                      MQTTCLIENT_PERSISTENCE_NONE, <span class="literal">NULL</span>);</span><br><span class="line">    conn_opts.keepAliveInterval = <span class="number">20</span>;</span><br><span class="line">    conn_opts.cleansession = <span class="number">1</span>;</span><br><span class="line">    conn_opts.ssl = &amp;ssl_opts;</span><br><span class="line"></span><br><span class="line">    MQTTClient_setCallbacks(client, <span class="literal">NULL</span>, connlost, msgarrvd, delivered);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((rc = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to connect, return code %d\n"</span>, rc);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Subscribing to topic %s\nfor client %s using QoS%d\n\n"</span></span><br><span class="line">           <span class="string">"Press Q&lt;Enter&gt; to quit\n\n"</span>, topic, param-&gt;client_id, qos);</span><br><span class="line">    MQTTClient_subscribe(client, topic, qos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125; <span class="keyword">while</span> (ch != <span class="string">'Q'</span> &amp;&amp; ch != <span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line">    MQTTClient_unsubscribe(client, topic);</span><br><span class="line">    MQTTClient_disconnect(client, <span class="number">10000</span>);</span><br><span class="line">    MQTTClient_destroy(&amp;client);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MQTT客户端分为同步客户端和异步客户端.　一般流程如下：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.创建一个客户端对象；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2.设置连接MQTT服务器的选项；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  3.如果多线程（异步模式）操作被使用则设置回调函数；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  4.订阅客户端需要接收的任意话题；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  5.重复以下操作直到结束：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a.发布客户端需要的任意信息；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b.处理所有接收到的信息；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  6.断开客户端连接；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  7.释放客户端使用的所有内存。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://antfaiz5z.github.io/categories/C-C/"/>
    
    
      <category term="mqtt" scheme="https://antfaiz5z.github.io/tags/mqtt/"/>
    
  </entry>
  
</feed>
